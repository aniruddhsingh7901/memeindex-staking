"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@tonconnect";
exports.ids = ["vendor-chunks/@tonconnect"];
exports.modules = {

/***/ "./node_modules/@tonconnect/ui-react/lib/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@tonconnect/ui-react/lib/index.js ***!
  \********************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TonConnectButton: () => (/* binding */ TonConnectButton$1),\n/* harmony export */   TonConnectProviderNotSetError: () => (/* binding */ TonConnectProviderNotSetError),\n/* harmony export */   TonConnectUIContext: () => (/* binding */ TonConnectUIContext),\n/* harmony export */   TonConnectUIProvider: () => (/* binding */ TonConnectUIProvider$1),\n/* harmony export */   TonConnectUIReactError: () => (/* binding */ TonConnectUIReactError),\n/* harmony export */   useIsConnectionRestored: () => (/* binding */ useIsConnectionRestored),\n/* harmony export */   useTonAddress: () => (/* binding */ useTonAddress),\n/* harmony export */   useTonConnectUI: () => (/* binding */ useTonConnectUI),\n/* harmony export */   useTonWallet: () => (/* binding */ useTonWallet)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"react\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tonconnect/ui */ \"./node_modules/@tonconnect/ui/lib/index.js\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__]);\n_tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__) if([\"default\",\"TonConnectButton\",\"TonConnectProviderNotSetError\",\"TonConnectUIContext\",\"TonConnectUIProvider\",\"TonConnectUIReactError\",\"useIsConnectionRestored\",\"useTonAddress\",\"useTonConnectUI\",\"useTonWallet\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\n\n\n\nvar jsxRuntime = { exports: {} };\nvar reactJsxRuntime_production_min = {};\n/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredReactJsxRuntime_production_min;\nfunction requireReactJsxRuntime_production_min() {\n  if (hasRequiredReactJsxRuntime_production_min)\n    return reactJsxRuntime_production_min;\n  hasRequiredReactJsxRuntime_production_min = 1;\n  var f = (react__WEBPACK_IMPORTED_MODULE_0___default()), k = Symbol.for(\"react.element\"), l = Symbol.for(\"react.fragment\"), m = Object.prototype.hasOwnProperty, n = f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p = { key: true, ref: true, __self: true, __source: true };\n  function q(c, a, g) {\n    var b, d = {}, e = null, h = null;\n    void 0 !== g && (e = \"\" + g);\n    void 0 !== a.key && (e = \"\" + a.key);\n    void 0 !== a.ref && (h = a.ref);\n    for (b in a)\n      m.call(a, b) && !p.hasOwnProperty(b) && (d[b] = a[b]);\n    if (c && c.defaultProps)\n      for (b in a = c.defaultProps, a)\n        void 0 === d[b] && (d[b] = a[b]);\n    return { $$typeof: k, type: c, key: e, ref: h, props: d, _owner: n.current };\n  }\n  reactJsxRuntime_production_min.Fragment = l;\n  reactJsxRuntime_production_min.jsx = q;\n  reactJsxRuntime_production_min.jsxs = q;\n  return reactJsxRuntime_production_min;\n}\nvar reactJsxRuntime_development = {};\n/**\n * @license React\n * react-jsx-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar hasRequiredReactJsxRuntime_development;\nfunction requireReactJsxRuntime_development() {\n  if (hasRequiredReactJsxRuntime_development)\n    return reactJsxRuntime_development;\n  hasRequiredReactJsxRuntime_development = 1;\n  if (true) {\n    (function() {\n      var React = (react__WEBPACK_IMPORTED_MODULE_0___default());\n      var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n      var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n      var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n      var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n      var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n      var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n      var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n      var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n      var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n      var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n      var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n      var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n      var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n      var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n      function getIteratorFn(maybeIterable) {\n        if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n          return null;\n        }\n        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n        if (typeof maybeIterator === \"function\") {\n          return maybeIterator;\n        }\n        return null;\n      }\n      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n      function error(format) {\n        {\n          {\n            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n              args[_key2 - 1] = arguments[_key2];\n            }\n            printWarning(\"error\", format, args);\n          }\n        }\n      }\n      function printWarning(level, format, args) {\n        {\n          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;\n          var stack = ReactDebugCurrentFrame2.getStackAddendum();\n          if (stack !== \"\") {\n            format += \"%s\";\n            args = args.concat([stack]);\n          }\n          var argsWithFormat = args.map(function(item) {\n            return String(item);\n          });\n          argsWithFormat.unshift(\"Warning: \" + format);\n          Function.prototype.apply.call(console[level], console, argsWithFormat);\n        }\n      }\n      var enableScopeAPI = false;\n      var enableCacheElement = false;\n      var enableTransitionTracing = false;\n      var enableLegacyHidden = false;\n      var enableDebugTracing = false;\n      var REACT_MODULE_REFERENCE;\n      {\n        REACT_MODULE_REFERENCE = Symbol.for(\"react.module.reference\");\n      }\n      function isValidElementType(type) {\n        if (typeof type === \"string\" || typeof type === \"function\") {\n          return true;\n        }\n        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n          return true;\n        }\n        if (typeof type === \"object\" && type !== null) {\n          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== void 0) {\n            return true;\n          }\n        }\n        return false;\n      }\n      function getWrappedName(outerType, innerType, wrapperName) {\n        var displayName = outerType.displayName;\n        if (displayName) {\n          return displayName;\n        }\n        var functionName = innerType.displayName || innerType.name || \"\";\n        return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n      }\n      function getContextName(type) {\n        return type.displayName || \"Context\";\n      }\n      function getComponentNameFromType(type) {\n        if (type == null) {\n          return null;\n        }\n        {\n          if (typeof type.tag === \"number\") {\n            error(\"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\");\n          }\n        }\n        if (typeof type === \"function\") {\n          return type.displayName || type.name || null;\n        }\n        if (typeof type === \"string\") {\n          return type;\n        }\n        switch (type) {\n          case REACT_FRAGMENT_TYPE:\n            return \"Fragment\";\n          case REACT_PORTAL_TYPE:\n            return \"Portal\";\n          case REACT_PROFILER_TYPE:\n            return \"Profiler\";\n          case REACT_STRICT_MODE_TYPE:\n            return \"StrictMode\";\n          case REACT_SUSPENSE_TYPE:\n            return \"Suspense\";\n          case REACT_SUSPENSE_LIST_TYPE:\n            return \"SuspenseList\";\n        }\n        if (typeof type === \"object\") {\n          switch (type.$$typeof) {\n            case REACT_CONTEXT_TYPE:\n              var context = type;\n              return getContextName(context) + \".Consumer\";\n            case REACT_PROVIDER_TYPE:\n              var provider = type;\n              return getContextName(provider._context) + \".Provider\";\n            case REACT_FORWARD_REF_TYPE:\n              return getWrappedName(type, type.render, \"ForwardRef\");\n            case REACT_MEMO_TYPE:\n              var outerName = type.displayName || null;\n              if (outerName !== null) {\n                return outerName;\n              }\n              return getComponentNameFromType(type.type) || \"Memo\";\n            case REACT_LAZY_TYPE: {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return getComponentNameFromType(init(payload));\n              } catch (x) {\n                return null;\n              }\n            }\n          }\n        }\n        return null;\n      }\n      var assign = Object.assign;\n      var disabledDepth = 0;\n      var prevLog;\n      var prevInfo;\n      var prevWarn;\n      var prevError;\n      var prevGroup;\n      var prevGroupCollapsed;\n      var prevGroupEnd;\n      function disabledLog() {\n      }\n      disabledLog.__reactDisabledLog = true;\n      function disableLogs() {\n        {\n          if (disabledDepth === 0) {\n            prevLog = console.log;\n            prevInfo = console.info;\n            prevWarn = console.warn;\n            prevError = console.error;\n            prevGroup = console.group;\n            prevGroupCollapsed = console.groupCollapsed;\n            prevGroupEnd = console.groupEnd;\n            var props = {\n              configurable: true,\n              enumerable: true,\n              value: disabledLog,\n              writable: true\n            };\n            Object.defineProperties(console, {\n              info: props,\n              log: props,\n              warn: props,\n              error: props,\n              group: props,\n              groupCollapsed: props,\n              groupEnd: props\n            });\n          }\n          disabledDepth++;\n        }\n      }\n      function reenableLogs() {\n        {\n          disabledDepth--;\n          if (disabledDepth === 0) {\n            var props = {\n              configurable: true,\n              enumerable: true,\n              writable: true\n            };\n            Object.defineProperties(console, {\n              log: assign({}, props, {\n                value: prevLog\n              }),\n              info: assign({}, props, {\n                value: prevInfo\n              }),\n              warn: assign({}, props, {\n                value: prevWarn\n              }),\n              error: assign({}, props, {\n                value: prevError\n              }),\n              group: assign({}, props, {\n                value: prevGroup\n              }),\n              groupCollapsed: assign({}, props, {\n                value: prevGroupCollapsed\n              }),\n              groupEnd: assign({}, props, {\n                value: prevGroupEnd\n              })\n            });\n          }\n          if (disabledDepth < 0) {\n            error(\"disabledDepth fell below zero. This is a bug in React. Please file an issue.\");\n          }\n        }\n      }\n      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n      var prefix;\n      function describeBuiltInComponentFrame(name, source, ownerFn) {\n        {\n          if (prefix === void 0) {\n            try {\n              throw Error();\n            } catch (x) {\n              var match = x.stack.trim().match(/\\n( *(at )?)/);\n              prefix = match && match[1] || \"\";\n            }\n          }\n          return \"\\n\" + prefix + name;\n        }\n      }\n      var reentry = false;\n      var componentFrameCache;\n      {\n        var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n        componentFrameCache = new PossiblyWeakMap();\n      }\n      function describeNativeComponentFrame(fn, construct) {\n        if (!fn || reentry) {\n          return \"\";\n        }\n        {\n          var frame = componentFrameCache.get(fn);\n          if (frame !== void 0) {\n            return frame;\n          }\n        }\n        var control;\n        reentry = true;\n        var previousPrepareStackTrace = Error.prepareStackTrace;\n        Error.prepareStackTrace = void 0;\n        var previousDispatcher;\n        {\n          previousDispatcher = ReactCurrentDispatcher.current;\n          ReactCurrentDispatcher.current = null;\n          disableLogs();\n        }\n        try {\n          if (construct) {\n            var Fake = function() {\n              throw Error();\n            };\n            Object.defineProperty(Fake.prototype, \"props\", {\n              set: function() {\n                throw Error();\n              }\n            });\n            if (typeof Reflect === \"object\" && Reflect.construct) {\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                control = x;\n              }\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x) {\n                control = x;\n              }\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x) {\n              control = x;\n            }\n            fn();\n          }\n        } catch (sample) {\n          if (sample && control && typeof sample.stack === \"string\") {\n            var sampleLines = sample.stack.split(\"\\n\");\n            var controlLines = control.stack.split(\"\\n\");\n            var s = sampleLines.length - 1;\n            var c = controlLines.length - 1;\n            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n              c--;\n            }\n            for (; s >= 1 && c >= 0; s--, c--) {\n              if (sampleLines[s] !== controlLines[c]) {\n                if (s !== 1 || c !== 1) {\n                  do {\n                    s--;\n                    c--;\n                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                      var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \");\n                      if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                        _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                      }\n                      {\n                        if (typeof fn === \"function\") {\n                          componentFrameCache.set(fn, _frame);\n                        }\n                      }\n                      return _frame;\n                    }\n                  } while (s >= 1 && c >= 0);\n                }\n                break;\n              }\n            }\n          }\n        } finally {\n          reentry = false;\n          {\n            ReactCurrentDispatcher.current = previousDispatcher;\n            reenableLogs();\n          }\n          Error.prepareStackTrace = previousPrepareStackTrace;\n        }\n        var name = fn ? fn.displayName || fn.name : \"\";\n        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n        {\n          if (typeof fn === \"function\") {\n            componentFrameCache.set(fn, syntheticFrame);\n          }\n        }\n        return syntheticFrame;\n      }\n      function describeFunctionComponentFrame(fn, source, ownerFn) {\n        {\n          return describeNativeComponentFrame(fn, false);\n        }\n      }\n      function shouldConstruct(Component) {\n        var prototype = Component.prototype;\n        return !!(prototype && prototype.isReactComponent);\n      }\n      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n        if (type == null) {\n          return \"\";\n        }\n        if (typeof type === \"function\") {\n          {\n            return describeNativeComponentFrame(type, shouldConstruct(type));\n          }\n        }\n        if (typeof type === \"string\") {\n          return describeBuiltInComponentFrame(type);\n        }\n        switch (type) {\n          case REACT_SUSPENSE_TYPE:\n            return describeBuiltInComponentFrame(\"Suspense\");\n          case REACT_SUSPENSE_LIST_TYPE:\n            return describeBuiltInComponentFrame(\"SuspenseList\");\n        }\n        if (typeof type === \"object\") {\n          switch (type.$$typeof) {\n            case REACT_FORWARD_REF_TYPE:\n              return describeFunctionComponentFrame(type.render);\n            case REACT_MEMO_TYPE:\n              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n            case REACT_LAZY_TYPE: {\n              var lazyComponent = type;\n              var payload = lazyComponent._payload;\n              var init = lazyComponent._init;\n              try {\n                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n              } catch (x) {\n              }\n            }\n          }\n        }\n        return \"\";\n      }\n      var hasOwnProperty = Object.prototype.hasOwnProperty;\n      var loggedTypeFailures = {};\n      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n      function setCurrentlyValidatingElement(element) {\n        {\n          if (element) {\n            var owner = element._owner;\n            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n            ReactDebugCurrentFrame.setExtraStackFrame(stack);\n          } else {\n            ReactDebugCurrentFrame.setExtraStackFrame(null);\n          }\n        }\n      }\n      function checkPropTypes(typeSpecs, values, location, componentName, element) {\n        {\n          var has = Function.call.bind(hasOwnProperty);\n          for (var typeSpecName in typeSpecs) {\n            if (has(typeSpecs, typeSpecName)) {\n              var error$1 = void 0;\n              try {\n                if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                  var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                  err.name = \"Invariant Violation\";\n                  throw err;\n                }\n                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n              } catch (ex) {\n                error$1 = ex;\n              }\n              if (error$1 && !(error$1 instanceof Error)) {\n                setCurrentlyValidatingElement(element);\n                error(\"%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                setCurrentlyValidatingElement(null);\n              }\n              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                loggedTypeFailures[error$1.message] = true;\n                setCurrentlyValidatingElement(element);\n                error(\"Failed %s type: %s\", location, error$1.message);\n                setCurrentlyValidatingElement(null);\n              }\n            }\n          }\n        }\n      }\n      var isArrayImpl = Array.isArray;\n      function isArray(a) {\n        return isArrayImpl(a);\n      }\n      function typeName(value) {\n        {\n          var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\";\n          return type;\n        }\n      }\n      function willCoercionThrow(value) {\n        {\n          try {\n            testStringCoercion(value);\n            return false;\n          } catch (e) {\n            return true;\n          }\n        }\n      }\n      function testStringCoercion(value) {\n        return \"\" + value;\n      }\n      function checkKeyStringCoercion(value) {\n        {\n          if (willCoercionThrow(value)) {\n            error(\"The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.\", typeName(value));\n            return testStringCoercion(value);\n          }\n        }\n      }\n      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n      var RESERVED_PROPS = {\n        key: true,\n        ref: true,\n        __self: true,\n        __source: true\n      };\n      var specialPropKeyWarningShown;\n      var specialPropRefWarningShown;\n      var didWarnAboutStringRefs;\n      {\n        didWarnAboutStringRefs = {};\n      }\n      function hasValidRef(config) {\n        {\n          if (hasOwnProperty.call(config, \"ref\")) {\n            var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n            if (getter && getter.isReactWarning) {\n              return false;\n            }\n          }\n        }\n        return config.ref !== void 0;\n      }\n      function hasValidKey(config) {\n        {\n          if (hasOwnProperty.call(config, \"key\")) {\n            var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n            if (getter && getter.isReactWarning) {\n              return false;\n            }\n          }\n        }\n        return config.key !== void 0;\n      }\n      function warnIfStringRefCannotBeAutoConverted(config, self) {\n        {\n          if (typeof config.ref === \"string\" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n            if (!didWarnAboutStringRefs[componentName]) {\n              error('Component \"%s\" contains the string ref \"%s\". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n              didWarnAboutStringRefs[componentName] = true;\n            }\n          }\n        }\n      }\n      function defineKeyPropWarningGetter(props, displayName) {\n        {\n          var warnAboutAccessingKey = function() {\n            if (!specialPropKeyWarningShown) {\n              specialPropKeyWarningShown = true;\n              error(\"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n            }\n          };\n          warnAboutAccessingKey.isReactWarning = true;\n          Object.defineProperty(props, \"key\", {\n            get: warnAboutAccessingKey,\n            configurable: true\n          });\n        }\n      }\n      function defineRefPropWarningGetter(props, displayName) {\n        {\n          var warnAboutAccessingRef = function() {\n            if (!specialPropRefWarningShown) {\n              specialPropRefWarningShown = true;\n              error(\"%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)\", displayName);\n            }\n          };\n          warnAboutAccessingRef.isReactWarning = true;\n          Object.defineProperty(props, \"ref\", {\n            get: warnAboutAccessingRef,\n            configurable: true\n          });\n        }\n      }\n      var ReactElement = function(type, key, ref, self, source, owner, props) {\n        var element = {\n          $$typeof: REACT_ELEMENT_TYPE,\n          type,\n          key,\n          ref,\n          props,\n          _owner: owner\n        };\n        {\n          element._store = {};\n          Object.defineProperty(element._store, \"validated\", {\n            configurable: false,\n            enumerable: false,\n            writable: true,\n            value: false\n          });\n          Object.defineProperty(element, \"_self\", {\n            configurable: false,\n            enumerable: false,\n            writable: false,\n            value: self\n          });\n          Object.defineProperty(element, \"_source\", {\n            configurable: false,\n            enumerable: false,\n            writable: false,\n            value: source\n          });\n          if (Object.freeze) {\n            Object.freeze(element.props);\n            Object.freeze(element);\n          }\n        }\n        return element;\n      };\n      function jsxDEV(type, config, maybeKey, source, self) {\n        {\n          var propName;\n          var props = {};\n          var key = null;\n          var ref = null;\n          if (maybeKey !== void 0) {\n            {\n              checkKeyStringCoercion(maybeKey);\n            }\n            key = \"\" + maybeKey;\n          }\n          if (hasValidKey(config)) {\n            {\n              checkKeyStringCoercion(config.key);\n            }\n            key = \"\" + config.key;\n          }\n          if (hasValidRef(config)) {\n            ref = config.ref;\n            warnIfStringRefCannotBeAutoConverted(config, self);\n          }\n          for (propName in config) {\n            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n              props[propName] = config[propName];\n            }\n          }\n          if (type && type.defaultProps) {\n            var defaultProps = type.defaultProps;\n            for (propName in defaultProps) {\n              if (props[propName] === void 0) {\n                props[propName] = defaultProps[propName];\n              }\n            }\n          }\n          if (key || ref) {\n            var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n            if (key) {\n              defineKeyPropWarningGetter(props, displayName);\n            }\n            if (ref) {\n              defineRefPropWarningGetter(props, displayName);\n            }\n          }\n          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n        }\n      }\n      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n      function setCurrentlyValidatingElement$1(element) {\n        {\n          if (element) {\n            var owner = element._owner;\n            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n          } else {\n            ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n          }\n        }\n      }\n      var propTypesMisspellWarningShown;\n      {\n        propTypesMisspellWarningShown = false;\n      }\n      function isValidElement(object) {\n        {\n          return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n        }\n      }\n      function getDeclarationErrorAddendum() {\n        {\n          if (ReactCurrentOwner$1.current) {\n            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n            if (name) {\n              return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n            }\n          }\n          return \"\";\n        }\n      }\n      function getSourceInfoErrorAddendum(source) {\n        {\n          if (source !== void 0) {\n            var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n            var lineNumber = source.lineNumber;\n            return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n          }\n          return \"\";\n        }\n      }\n      var ownerHasKeyUseWarning = {};\n      function getCurrentComponentErrorInfo(parentType) {\n        {\n          var info = getDeclarationErrorAddendum();\n          if (!info) {\n            var parentName = typeof parentType === \"string\" ? parentType : parentType.displayName || parentType.name;\n            if (parentName) {\n              info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n            }\n          }\n          return info;\n        }\n      }\n      function validateExplicitKey(element, parentType) {\n        {\n          if (!element._store || element._store.validated || element.key != null) {\n            return;\n          }\n          element._store.validated = true;\n          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n            return;\n          }\n          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;\n          var childOwner = \"\";\n          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n            childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n          }\n          setCurrentlyValidatingElement$1(element);\n          error('Each child in a list should have a unique \"key\" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n          setCurrentlyValidatingElement$1(null);\n        }\n      }\n      function validateChildKeys(node, parentType) {\n        {\n          if (typeof node !== \"object\") {\n            return;\n          }\n          if (isArray(node)) {\n            for (var i = 0; i < node.length; i++) {\n              var child = node[i];\n              if (isValidElement(child)) {\n                validateExplicitKey(child, parentType);\n              }\n            }\n          } else if (isValidElement(node)) {\n            if (node._store) {\n              node._store.validated = true;\n            }\n          } else if (node) {\n            var iteratorFn = getIteratorFn(node);\n            if (typeof iteratorFn === \"function\") {\n              if (iteratorFn !== node.entries) {\n                var iterator = iteratorFn.call(node);\n                var step;\n                while (!(step = iterator.next()).done) {\n                  if (isValidElement(step.value)) {\n                    validateExplicitKey(step.value, parentType);\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      function validatePropTypes(element) {\n        {\n          var type = element.type;\n          if (type === null || type === void 0 || typeof type === \"string\") {\n            return;\n          }\n          var propTypes;\n          if (typeof type === \"function\") {\n            propTypes = type.propTypes;\n          } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {\n            propTypes = type.propTypes;\n          } else {\n            return;\n          }\n          if (propTypes) {\n            var name = getComponentNameFromType(type);\n            checkPropTypes(propTypes, element.props, \"prop\", name, element);\n          } else if (type.PropTypes !== void 0 && !propTypesMisspellWarningShown) {\n            propTypesMisspellWarningShown = true;\n            var _name = getComponentNameFromType(type);\n            error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n          }\n          if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n            error(\"getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.\");\n          }\n        }\n      }\n      function validateFragmentProps(fragment) {\n        {\n          var keys = Object.keys(fragment.props);\n          for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            if (key !== \"children\" && key !== \"key\") {\n              setCurrentlyValidatingElement$1(fragment);\n              error(\"Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.\", key);\n              setCurrentlyValidatingElement$1(null);\n              break;\n            }\n          }\n          if (fragment.ref !== null) {\n            setCurrentlyValidatingElement$1(fragment);\n            error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n            setCurrentlyValidatingElement$1(null);\n          }\n        }\n      }\n      function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n        {\n          var validType = isValidElementType(type);\n          if (!validType) {\n            var info = \"\";\n            if (type === void 0 || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n              info += \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n            }\n            var sourceInfo = getSourceInfoErrorAddendum(source);\n            if (sourceInfo) {\n              info += sourceInfo;\n            } else {\n              info += getDeclarationErrorAddendum();\n            }\n            var typeString;\n            if (type === null) {\n              typeString = \"null\";\n            } else if (isArray(type)) {\n              typeString = \"array\";\n            } else if (type !== void 0 && type.$$typeof === REACT_ELEMENT_TYPE) {\n              typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n              info = \" Did you accidentally export a JSX literal instead of a component?\";\n            } else {\n              typeString = typeof type;\n            }\n            error(\"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\", typeString, info);\n          }\n          var element = jsxDEV(type, props, key, source, self);\n          if (element == null) {\n            return element;\n          }\n          if (validType) {\n            var children = props.children;\n            if (children !== void 0) {\n              if (isStaticChildren) {\n                if (isArray(children)) {\n                  for (var i = 0; i < children.length; i++) {\n                    validateChildKeys(children[i], type);\n                  }\n                  if (Object.freeze) {\n                    Object.freeze(children);\n                  }\n                } else {\n                  error(\"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\");\n                }\n              } else {\n                validateChildKeys(children, type);\n              }\n            }\n          }\n          if (type === REACT_FRAGMENT_TYPE) {\n            validateFragmentProps(element);\n          } else {\n            validatePropTypes(element);\n          }\n          return element;\n        }\n      }\n      function jsxWithValidationStatic(type, props, key) {\n        {\n          return jsxWithValidation(type, props, key, true);\n        }\n      }\n      function jsxWithValidationDynamic(type, props, key) {\n        {\n          return jsxWithValidation(type, props, key, false);\n        }\n      }\n      var jsx2 = jsxWithValidationDynamic;\n      var jsxs = jsxWithValidationStatic;\n      reactJsxRuntime_development.Fragment = REACT_FRAGMENT_TYPE;\n      reactJsxRuntime_development.jsx = jsx2;\n      reactJsxRuntime_development.jsxs = jsxs;\n    })();\n  }\n  return reactJsxRuntime_development;\n}\n(function(module) {\n  if (false) {} else {\n    module.exports = requireReactJsxRuntime_development();\n  }\n})(jsxRuntime);\nconst jsx = jsxRuntime.exports.jsx;\nfunction isClientSide() {\n  return typeof window !== \"undefined\";\n}\nfunction isServerSide() {\n  return !isClientSide();\n}\nconst TonConnectUIContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(null);\nlet tonConnectUI = null;\nconst TonConnectUIProvider = (_a) => {\n  var _b = _a, {\n    children\n  } = _b, options = __objRest(_b, [\n    \"children\"\n  ]);\n  if (isClientSide() && !tonConnectUI) {\n    tonConnectUI = new _tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__.TonConnectUI(options);\n  }\n  return /* @__PURE__ */ jsx(TonConnectUIContext.Provider, { value: tonConnectUI, children });\n};\nconst TonConnectUIProvider$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(TonConnectUIProvider);\nclass TonConnectUIReactError extends _tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__.TonConnectUIError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectUIReactError.prototype);\n  }\n}\nclass TonConnectProviderNotSetError extends TonConnectUIReactError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectProviderNotSetError.prototype);\n  }\n}\nfunction checkProvider(provider) {\n  if (!provider) {\n    throw new TonConnectProviderNotSetError(\n      \"You should add <TonConnectUIProvider> on the top of the app to use TonConnect\"\n    );\n  }\n  return true;\n}\nfunction useTonConnectUI() {\n  const tonConnectUI2 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(TonConnectUIContext);\n  const setOptions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (options) => {\n      if (tonConnectUI2) {\n        tonConnectUI2.uiOptions = options;\n      }\n    },\n    [tonConnectUI2]\n  );\n  if (isServerSide()) {\n    return [null, () => {\n    }];\n  }\n  checkProvider(tonConnectUI2);\n  return [tonConnectUI2, setOptions];\n}\nconst buttonRootId = \"ton-connect-button\";\nconst TonConnectButton = ({ className, style }) => {\n  const [_, setOptions] = useTonConnectUI();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    setOptions({ buttonRootId });\n    return () => setOptions({ buttonRootId: null });\n  }, [setOptions]);\n  return /* @__PURE__ */ jsx(\n    \"div\",\n    {\n      id: buttonRootId,\n      className,\n      style: __spreadValues({ width: \"fit-content\" }, style)\n    }\n  );\n};\nconst TonConnectButton$1 = (0,react__WEBPACK_IMPORTED_MODULE_0__.memo)(TonConnectButton);\nfunction useTonWallet() {\n  const [tonConnectUI2] = useTonConnectUI();\n  const [wallet, setWallet] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    (tonConnectUI2 == null ? void 0 : tonConnectUI2.wallet) || null\n  );\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (tonConnectUI2) {\n      return tonConnectUI2.onStatusChange((value) => {\n        setWallet(value);\n      });\n    }\n  }, [tonConnectUI2]);\n  return wallet;\n}\nfunction useTonAddress(userFriendly = true) {\n  const wallet = useTonWallet();\n  if (wallet) {\n    return userFriendly ? (0,_tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__.toUserFriendlyAddress)(wallet.account.address, wallet.account.chain === _tonconnect_ui__WEBPACK_IMPORTED_MODULE_1__.CHAIN.TESTNET) : wallet.account.address;\n  } else {\n    return \"\";\n  }\n}\nfunction useIsConnectionRestored() {\n  const [restored, setRestored] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const [tonConnectUI2] = useTonConnectUI();\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    if (tonConnectUI2) {\n      tonConnectUI2.connectionRestored.then(() => setRestored(true));\n    }\n  }, [tonConnectUI2]);\n  return restored;\n}\n\n//# sourceMappingURL=index.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWktcmVhY3QvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDc0c7QUFDUDtBQUNoRTtBQUMvQixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4Q0FBVSw0TEFBNEw7QUFDaE47QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLElBQXFDO0FBQzNDO0FBQ0Esa0JBQWtCLDhDQUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1R0FBdUcsZUFBZTtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlJQUFpSTtBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixpQkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDSjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFhO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix3REFBWTtBQUNuQztBQUNBLDZEQUE2RCwrQkFBK0I7QUFDNUY7QUFDQSwrQkFBK0IsMkNBQUk7QUFDbkMscUNBQXFDLDZEQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlEQUFVO0FBQ2xDLHFCQUFxQixrREFBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBLEVBQUUsZ0RBQVM7QUFDWCxpQkFBaUIsY0FBYztBQUMvQiw4QkFBOEIsb0JBQW9CO0FBQ2xELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNCQUFzQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMkNBQUk7QUFDL0I7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBUTtBQUN0QztBQUNBO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHFFQUFxQixrREFBa0QsaURBQUs7QUFDdEcsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtDQUFRO0FBQzFDO0FBQ0EsRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBV0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL21lbWVpbmRleC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC91aS1yZWFjdC9saWIvaW5kZXguanM/YWI0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcFN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19wcm9wSXNFbnVtID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcbnZhciBfX2RlZk5vcm1hbFByb3AgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBrZXkgaW4gb2JqID8gX19kZWZQcm9wKG9iaiwga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUsIHZhbHVlIH0pIDogb2JqW2tleV0gPSB2YWx1ZTtcbnZhciBfX3NwcmVhZFZhbHVlcyA9IChhLCBiKSA9PiB7XG4gIGZvciAodmFyIHByb3AgaW4gYiB8fCAoYiA9IHt9KSlcbiAgICBpZiAoX19oYXNPd25Qcm9wLmNhbGwoYiwgcHJvcCkpXG4gICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYSwgcHJvcCwgYltwcm9wXSk7XG4gICAgfVxuICByZXR1cm4gYTtcbn07XG52YXIgX19vYmpSZXN0ID0gKHNvdXJjZSwgZXhjbHVkZSkgPT4ge1xuICB2YXIgdGFyZ2V0ID0ge307XG4gIGZvciAodmFyIHByb3AgaW4gc291cmNlKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChzb3VyY2UsIHByb3ApICYmIGV4Y2x1ZGUuaW5kZXhPZihwcm9wKSA8IDApXG4gICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gIGlmIChzb3VyY2UgIT0gbnVsbCAmJiBfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhzb3VyY2UpKSB7XG4gICAgICBpZiAoZXhjbHVkZS5pbmRleE9mKHByb3ApIDwgMCAmJiBfX3Byb3BJc0VudW0uY2FsbChzb3VyY2UsIHByb3ApKVxuICAgICAgICB0YXJnZXRbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgfVxuICByZXR1cm4gdGFyZ2V0O1xufTtcbmltcG9ydCByZXF1aXJlJCQwLCB7IGNyZWF0ZUNvbnRleHQsIG1lbW8sIHVzZUNvbnRleHQsIHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBUb25Db25uZWN0VUksIFRvbkNvbm5lY3RVSUVycm9yLCB0b1VzZXJGcmllbmRseUFkZHJlc3MsIENIQUlOIH0gZnJvbSBcIkB0b25jb25uZWN0L3VpXCI7XG5leHBvcnQgKiBmcm9tIFwiQHRvbmNvbm5lY3QvdWlcIjtcbnZhciBqc3hSdW50aW1lID0geyBleHBvcnRzOiB7fSB9O1xudmFyIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbiA9IHt9O1xuLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xudmFyIGhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluO1xuZnVuY3Rpb24gcmVxdWlyZVJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluKVxuICAgIHJldHVybiByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW47XG4gIGhhc1JlcXVpcmVkUmVhY3RKc3hSdW50aW1lX3Byb2R1Y3Rpb25fbWluID0gMTtcbiAgdmFyIGYgPSByZXF1aXJlJCQwLCBrID0gU3ltYm9sLmZvcihcInJlYWN0LmVsZW1lbnRcIiksIGwgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksIG0gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LCBuID0gZi5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lciwgcCA9IHsga2V5OiB0cnVlLCByZWY6IHRydWUsIF9fc2VsZjogdHJ1ZSwgX19zb3VyY2U6IHRydWUgfTtcbiAgZnVuY3Rpb24gcShjLCBhLCBnKSB7XG4gICAgdmFyIGIsIGQgPSB7fSwgZSA9IG51bGwsIGggPSBudWxsO1xuICAgIHZvaWQgMCAhPT0gZyAmJiAoZSA9IFwiXCIgKyBnKTtcbiAgICB2b2lkIDAgIT09IGEua2V5ICYmIChlID0gXCJcIiArIGEua2V5KTtcbiAgICB2b2lkIDAgIT09IGEucmVmICYmIChoID0gYS5yZWYpO1xuICAgIGZvciAoYiBpbiBhKVxuICAgICAgbS5jYWxsKGEsIGIpICYmICFwLmhhc093blByb3BlcnR5KGIpICYmIChkW2JdID0gYVtiXSk7XG4gICAgaWYgKGMgJiYgYy5kZWZhdWx0UHJvcHMpXG4gICAgICBmb3IgKGIgaW4gYSA9IGMuZGVmYXVsdFByb3BzLCBhKVxuICAgICAgICB2b2lkIDAgPT09IGRbYl0gJiYgKGRbYl0gPSBhW2JdKTtcbiAgICByZXR1cm4geyAkJHR5cGVvZjogaywgdHlwZTogYywga2V5OiBlLCByZWY6IGgsIHByb3BzOiBkLCBfb3duZXI6IG4uY3VycmVudCB9O1xuICB9XG4gIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbi5GcmFnbWVudCA9IGw7XG4gIHJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbi5qc3ggPSBxO1xuICByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW4uanN4cyA9IHE7XG4gIHJldHVybiByZWFjdEpzeFJ1bnRpbWVfcHJvZHVjdGlvbl9taW47XG59XG52YXIgcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50ID0ge307XG4vKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG52YXIgaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQ7XG5mdW5jdGlvbiByZXF1aXJlUmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50KCkge1xuICBpZiAoaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQpXG4gICAgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcbiAgaGFzUmVxdWlyZWRSZWFjdEpzeFJ1bnRpbWVfZGV2ZWxvcG1lbnQgPSAxO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIFJlYWN0ID0gcmVxdWlyZSQkMDtcbiAgICAgIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZWxlbWVudFwiKTtcbiAgICAgIHZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wb3J0YWxcIik7XG4gICAgICB2YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5mcmFnbWVudFwiKTtcbiAgICAgIHZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpO1xuICAgICAgdmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QucHJvZmlsZXJcIik7XG4gICAgICB2YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm92aWRlclwiKTtcbiAgICAgIHZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKTtcbiAgICAgIHZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmZvcndhcmRfcmVmXCIpO1xuICAgICAgdmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Quc3VzcGVuc2VcIik7XG4gICAgICB2YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIik7XG4gICAgICB2YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0Lm1lbW9cIik7XG4gICAgICB2YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LmxhenlcIik7XG4gICAgICB2YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpO1xuICAgICAgdmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbiAgICAgIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9IFwiQEBpdGVyYXRvclwiO1xuICAgICAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgICAgIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICAgICAgICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG4gICAgICBmdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmludFdhcm5pbmcoXCJlcnJvclwiLCBmb3JtYXQsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lMiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgICAgICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTIuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgICAgIGlmIChzdGFjayAhPT0gXCJcIikge1xuICAgICAgICAgICAgZm9ybWF0ICs9IFwiJXNcIjtcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KFwiV2FybmluZzogXCIgKyBmb3JtYXQpO1xuICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlO1xuICAgICAgdmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xuICAgICAgdmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7XG4gICAgICB2YXIgZW5hYmxlTGVnYWN5SGlkZGVuID0gZmFsc2U7XG4gICAgICB2YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG4gICAgICB2YXIgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRTtcbiAgICAgIHtcbiAgICAgICAgUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5tb2R1bGUucmVmZXJlbmNlXCIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9QUk9GSUxFUl9UWVBFIHx8IGVuYWJsZURlYnVnVHJhY2luZyB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiB8fCB0eXBlID09PSBSRUFDVF9PRkZTQ1JFRU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSB8fCBlbmFibGVDYWNoZUVsZW1lbnQgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTU9EVUxFX1JFRkVSRU5DRSB8fCB0eXBlLmdldE1vZHVsZUlkICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICBpZiAoZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICByZXR1cm4gZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb25OYW1lICE9PSBcIlwiID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IFwiQ29udGV4dFwiO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBlcnJvcihcIlJlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIkZyYWdtZW50XCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlByb2ZpbGVyXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIFwiU3RyaWN0TW9kZVwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gXCJTdXNwZW5zZUxpc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArIFwiLkNvbnN1bWVyXCI7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsIFwiRm9yd2FyZFJlZlwiKTtcbiAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuICAgICAgICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCI7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRToge1xuICAgICAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuICAgICAgdmFyIGRpc2FibGVkRGVwdGggPSAwO1xuICAgICAgdmFyIHByZXZMb2c7XG4gICAgICB2YXIgcHJldkluZm87XG4gICAgICB2YXIgcHJldldhcm47XG4gICAgICB2YXIgcHJldkVycm9yO1xuICAgICAgdmFyIHByZXZHcm91cDtcbiAgICAgIHZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG4gICAgICB2YXIgcHJldkdyb3VwRW5kO1xuICAgICAgZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuICAgICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICAgICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgICAge1xuICAgICAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgICAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICAgICAgICBlcnJvcihcImRpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgUmVhY3RDdXJyZW50RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudERpc3BhdGNoZXI7XG4gICAgICB2YXIgcHJlZml4O1xuICAgICAgZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lckZuKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAocHJlZml4ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIHZhciBtYXRjaCA9IHguc3RhY2sudHJpbSgpLm1hdGNoKC9cXG4oICooYXQgKT8pLyk7XG4gICAgICAgICAgICAgIHByZWZpeCA9IG1hdGNoICYmIG1hdGNoWzFdIHx8IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBcIlxcblwiICsgcHJlZml4ICsgbmFtZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHJlZW50cnkgPSBmYWxzZTtcbiAgICAgIHZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuICAgICAge1xuICAgICAgICB2YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09IFwiZnVuY3Rpb25cIiA/IFdlYWtNYXAgOiBNYXA7XG4gICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAge1xuICAgICAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgICAgICBpZiAoZnJhbWUgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udHJvbDtcbiAgICAgICAgcmVlbnRyeSA9IHRydWU7XG4gICAgICAgIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7XG4gICAgICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdm9pZCAwO1xuICAgICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgICB7XG4gICAgICAgICAgcHJldmlvdXNEaXNwYXRjaGVyID0gUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50O1xuICAgICAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgZGlzYWJsZUxvZ3MoKTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoXCJcXG5cIik7XG4gICAgICAgICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgIHZhciBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIHZhciBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgIGMtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICAgICAgICBjLS07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9IFwiXFxuXCIgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKFwiIGF0IG5ldyBcIiwgXCIgYXQgXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoXCI8YW5vbnltb3VzPlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHJlZW50cnkgPSBmYWxzZTtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQgPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICAgICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogXCJcIjtcbiAgICAgICAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogXCJcIjtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gICAgICAgIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuICAgICAgICBpZiAodHlwZSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKFwiU3VzcGVuc2VcIik7XG4gICAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICAgICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZS50eXBlLCBzb3VyY2UsIG93bmVyRm4pO1xuICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6IHtcbiAgICAgICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGluaXQocGF5bG9hZCksIHNvdXJjZSwgb3duZXJGbik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gICAgICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG4gICAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgICBmdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUoc3RhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGhhcyA9IEZ1bmN0aW9uLmNhbGwuYmluZChoYXNPd25Qcm9wZXJ0eSk7XG4gICAgICAgICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgXCJSZWFjdCBjbGFzc1wiKSArIFwiOiBcIiArIGxvY2F0aW9uICsgXCIgdHlwZSBgXCIgKyB0eXBlU3BlY05hbWUgKyBcImAgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYFwiICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgXCJgLlRoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLlwiKTtcbiAgICAgICAgICAgICAgICAgIGVyci5uYW1lID0gXCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFwiU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRURcIik7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIGVycm9yKFwiJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuIFlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyIGNyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLlwiLCBjb21wb25lbnROYW1lIHx8IFwiUmVhY3QgY2xhc3NcIiwgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuICAgICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvciQxLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBlcnJvcihcIkZhaWxlZCAlcyB0eXBlOiAlc1wiLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheTtcbiAgICAgIGZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICAgICAgICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICAgICAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCBcIk9iamVjdFwiO1xuICAgICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICAgICAgICB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGVycm9yKFwiVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLiBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsIHR5cGVOYW1lKHZhbHVlKSk7XG4gICAgICAgICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xuICAgICAgdmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICAgICAgICBrZXk6IHRydWUsXG4gICAgICAgIHJlZjogdHJ1ZSxcbiAgICAgICAgX19zZWxmOiB0cnVlLFxuICAgICAgICBfX3NvdXJjZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHZhciBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICAgIHZhciBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bjtcbiAgICAgIHZhciBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzO1xuICAgICAge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJyZWZcIikpIHtcbiAgICAgICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJyZWZcIikuZ2V0O1xuICAgICAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdm9pZCAwO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gXCJzdHJpbmdcIiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5zdGF0ZU5vZGUgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiBTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuIExlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZXJyb3IoXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgICAgICAgICAgZXJyb3IoXCIlczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKVwiLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJyZWZcIiwge1xuICAgICAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICAgICAgICB2YXIgZWxlbWVudCA9IHtcbiAgICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICAgIHR5cGUsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHJlZixcbiAgICAgICAgICBwcm9wcyxcbiAgICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICAgIH07XG4gICAgICAgIHtcbiAgICAgICAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgXCJ2YWxpZGF0ZWRcIiwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgXCJfc2VsZlwiLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICB2YWx1ZTogc2VsZlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCBcIl9zb3VyY2VcIiwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICAgICAgdmFsdWU6IHNvdXJjZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByb3BOYW1lO1xuICAgICAgICAgIHZhciBwcm9wcyA9IHt9O1xuICAgICAgICAgIHZhciBrZXkgPSBudWxsO1xuICAgICAgICAgIHZhciByZWYgPSBudWxsO1xuICAgICAgICAgIGlmIChtYXliZUtleSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gXCJcIiArIG1heWJlS2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAga2V5ID0gXCJcIiArIGNvbmZpZy5rZXk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAgICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgICAgICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gXCJmdW5jdGlvblwiID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCIgOiB0eXBlO1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbiAgICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgICAgZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd247XG4gICAgICB7XG4gICAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSBcIm9iamVjdFwiICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudCkge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFwiXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYFwiICsgbmFtZSArIFwiYC5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHNvdXJjZSAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgXCJcIik7XG4gICAgICAgICAgICB2YXIgbGluZU51bWJlciA9IHNvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICAgICAgcmV0dXJuIFwiXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0IFwiICsgZmlsZU5hbWUgKyBcIjpcIiArIGxpbmVOdW1iZXIgKyBcIi5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgICBpZiAoIWluZm8pIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09IFwic3RyaW5nXCIgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgICAgICAgICBpZiAocGFyZW50TmFtZSkge1xuICAgICAgICAgICAgICBpbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIHBhcmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB2YWxpZGF0ZUV4cGxpY2l0S2V5KGVsZW1lbnQsIHBhcmVudFR5cGUpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gICAgICAgICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuICAgICAgICAgIHZhciBjaGlsZE93bmVyID0gXCJcIjtcbiAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAgICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KTtcbiAgICAgICAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLiVzJXMgU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgY3VycmVudENvbXBvbmVudEVycm9ySW5mbywgY2hpbGRPd25lcik7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBub2RlICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSkge1xuICAgICAgICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG4gICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiB0eXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcm9wVHlwZXM7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09IFwib2JqZWN0XCIgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSkge1xuICAgICAgICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsIFwicHJvcFwiLCBuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB2b2lkIDAgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICAgICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICAgICAgICB2YXIgX25hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgICAgICBlcnJvcihcIkNvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50P1wiLCBfbmFtZSB8fCBcIlVua25vd25cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09IFwiZnVuY3Rpb25cIiAmJiAhdHlwZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgICAgICAgIGVycm9yKFwiZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzIGRlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC5cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpO1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5ICE9PSBcImNoaWxkcmVuXCIgJiYga2V5ICE9PSBcImtleVwiKSB7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuICAgICAgICAgICAgICBlcnJvcihcIkludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuIFJlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuXCIsIGtleSk7XG4gICAgICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcbiAgICAgICAgICAgIGVycm9yKFwiSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC5cIik7XG4gICAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpO1xuICAgICAgICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IFwiXCI7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdm9pZCAwIHx8IHR5cGVvZiB0eXBlID09PSBcIm9iamVjdFwiICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gXCIgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0eXBlU3RyaW5nO1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IFwibnVsbFwiO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICAgIHR5cGVTdHJpbmcgPSBcImFycmF5XCI7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHZvaWQgMCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8IFwiVW5rbm93blwiKSArIFwiIC8+XCI7XG4gICAgICAgICAgICAgIGluZm8gPSBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXJyb3IoXCJSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXNcIiwgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBlbGVtZW50ID0ganN4REVWKHR5cGUsIHByb3BzLCBrZXksIHNvdXJjZSwgc2VsZik7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW4sIHR5cGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb25TdGF0aWModHlwZSwgcHJvcHMsIGtleSkge1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWModHlwZSwgcHJvcHMsIGtleSkge1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGpzeDIgPSBqc3hXaXRoVmFsaWRhdGlvbkR5bmFtaWM7XG4gICAgICB2YXIganN4cyA9IGpzeFdpdGhWYWxpZGF0aW9uU3RhdGljO1xuICAgICAgcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50LkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICAgIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudC5qc3ggPSBqc3gyO1xuICAgICAgcmVhY3RKc3hSdW50aW1lX2RldmVsb3BtZW50LmpzeHMgPSBqc3hzO1xuICAgIH0pKCk7XG4gIH1cbiAgcmV0dXJuIHJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudDtcbn1cbihmdW5jdGlvbihtb2R1bGUpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcInByb2R1Y3Rpb25cIikge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZVJlYWN0SnN4UnVudGltZV9wcm9kdWN0aW9uX21pbigpO1xuICB9IGVsc2Uge1xuICAgIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZVJlYWN0SnN4UnVudGltZV9kZXZlbG9wbWVudCgpO1xuICB9XG59KShqc3hSdW50aW1lKTtcbmNvbnN0IGpzeCA9IGpzeFJ1bnRpbWUuZXhwb3J0cy5qc3g7XG5mdW5jdGlvbiBpc0NsaWVudFNpZGUoKSB7XG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiO1xufVxuZnVuY3Rpb24gaXNTZXJ2ZXJTaWRlKCkge1xuICByZXR1cm4gIWlzQ2xpZW50U2lkZSgpO1xufVxuY29uc3QgVG9uQ29ubmVjdFVJQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG5sZXQgdG9uQ29ubmVjdFVJID0gbnVsbDtcbmNvbnN0IFRvbkNvbm5lY3RVSVByb3ZpZGVyID0gKF9hKSA9PiB7XG4gIHZhciBfYiA9IF9hLCB7XG4gICAgY2hpbGRyZW5cbiAgfSA9IF9iLCBvcHRpb25zID0gX19vYmpSZXN0KF9iLCBbXG4gICAgXCJjaGlsZHJlblwiXG4gIF0pO1xuICBpZiAoaXNDbGllbnRTaWRlKCkgJiYgIXRvbkNvbm5lY3RVSSkge1xuICAgIHRvbkNvbm5lY3RVSSA9IG5ldyBUb25Db25uZWN0VUkob3B0aW9ucyk7XG4gIH1cbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBqc3goVG9uQ29ubmVjdFVJQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogdG9uQ29ubmVjdFVJLCBjaGlsZHJlbiB9KTtcbn07XG5jb25zdCBUb25Db25uZWN0VUlQcm92aWRlciQxID0gbWVtbyhUb25Db25uZWN0VUlQcm92aWRlcik7XG5jbGFzcyBUb25Db25uZWN0VUlSZWFjdEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdFVJRXJyb3Ige1xuICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgc3VwZXIoLi4uYXJncyk7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFRvbkNvbm5lY3RVSVJlYWN0RXJyb3IucHJvdG90eXBlKTtcbiAgfVxufVxuY2xhc3MgVG9uQ29ubmVjdFByb3ZpZGVyTm90U2V0RXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0VUlSZWFjdEVycm9yIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUb25Db25uZWN0UHJvdmlkZXJOb3RTZXRFcnJvci5wcm90b3R5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBjaGVja1Byb3ZpZGVyKHByb3ZpZGVyKSB7XG4gIGlmICghcHJvdmlkZXIpIHtcbiAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFByb3ZpZGVyTm90U2V0RXJyb3IoXG4gICAgICBcIllvdSBzaG91bGQgYWRkIDxUb25Db25uZWN0VUlQcm92aWRlcj4gb24gdGhlIHRvcCBvZiB0aGUgYXBwIHRvIHVzZSBUb25Db25uZWN0XCJcbiAgICApO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gdXNlVG9uQ29ubmVjdFVJKCkge1xuICBjb25zdCB0b25Db25uZWN0VUkyID0gdXNlQ29udGV4dChUb25Db25uZWN0VUlDb250ZXh0KTtcbiAgY29uc3Qgc2V0T3B0aW9ucyA9IHVzZUNhbGxiYWNrKFxuICAgIChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAodG9uQ29ubmVjdFVJMikge1xuICAgICAgICB0b25Db25uZWN0VUkyLnVpT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfSxcbiAgICBbdG9uQ29ubmVjdFVJMl1cbiAgKTtcbiAgaWYgKGlzU2VydmVyU2lkZSgpKSB7XG4gICAgcmV0dXJuIFtudWxsLCAoKSA9PiB7XG4gICAgfV07XG4gIH1cbiAgY2hlY2tQcm92aWRlcih0b25Db25uZWN0VUkyKTtcbiAgcmV0dXJuIFt0b25Db25uZWN0VUkyLCBzZXRPcHRpb25zXTtcbn1cbmNvbnN0IGJ1dHRvblJvb3RJZCA9IFwidG9uLWNvbm5lY3QtYnV0dG9uXCI7XG5jb25zdCBUb25Db25uZWN0QnV0dG9uID0gKHsgY2xhc3NOYW1lLCBzdHlsZSB9KSA9PiB7XG4gIGNvbnN0IFtfLCBzZXRPcHRpb25zXSA9IHVzZVRvbkNvbm5lY3RVSSgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHNldE9wdGlvbnMoeyBidXR0b25Sb290SWQgfSk7XG4gICAgcmV0dXJuICgpID0+IHNldE9wdGlvbnMoeyBidXR0b25Sb290SWQ6IG51bGwgfSk7XG4gIH0sIFtzZXRPcHRpb25zXSk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8ganN4KFxuICAgIFwiZGl2XCIsXG4gICAge1xuICAgICAgaWQ6IGJ1dHRvblJvb3RJZCxcbiAgICAgIGNsYXNzTmFtZSxcbiAgICAgIHN0eWxlOiBfX3NwcmVhZFZhbHVlcyh7IHdpZHRoOiBcImZpdC1jb250ZW50XCIgfSwgc3R5bGUpXG4gICAgfVxuICApO1xufTtcbmNvbnN0IFRvbkNvbm5lY3RCdXR0b24kMSA9IG1lbW8oVG9uQ29ubmVjdEJ1dHRvbik7XG5mdW5jdGlvbiB1c2VUb25XYWxsZXQoKSB7XG4gIGNvbnN0IFt0b25Db25uZWN0VUkyXSA9IHVzZVRvbkNvbm5lY3RVSSgpO1xuICBjb25zdCBbd2FsbGV0LCBzZXRXYWxsZXRdID0gdXNlU3RhdGUoXG4gICAgKHRvbkNvbm5lY3RVSTIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvbkNvbm5lY3RVSTIud2FsbGV0KSB8fCBudWxsXG4gICk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKHRvbkNvbm5lY3RVSTIpIHtcbiAgICAgIHJldHVybiB0b25Db25uZWN0VUkyLm9uU3RhdHVzQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICBzZXRXYWxsZXQodmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCBbdG9uQ29ubmVjdFVJMl0pO1xuICByZXR1cm4gd2FsbGV0O1xufVxuZnVuY3Rpb24gdXNlVG9uQWRkcmVzcyh1c2VyRnJpZW5kbHkgPSB0cnVlKSB7XG4gIGNvbnN0IHdhbGxldCA9IHVzZVRvbldhbGxldCgpO1xuICBpZiAod2FsbGV0KSB7XG4gICAgcmV0dXJuIHVzZXJGcmllbmRseSA/IHRvVXNlckZyaWVuZGx5QWRkcmVzcyh3YWxsZXQuYWNjb3VudC5hZGRyZXNzLCB3YWxsZXQuYWNjb3VudC5jaGFpbiA9PT0gQ0hBSU4uVEVTVE5FVCkgOiB3YWxsZXQuYWNjb3VudC5hZGRyZXNzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiB1c2VJc0Nvbm5lY3Rpb25SZXN0b3JlZCgpIHtcbiAgY29uc3QgW3Jlc3RvcmVkLCBzZXRSZXN0b3JlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFt0b25Db25uZWN0VUkyXSA9IHVzZVRvbkNvbm5lY3RVSSgpO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0b25Db25uZWN0VUkyKSB7XG4gICAgICB0b25Db25uZWN0VUkyLmNvbm5lY3Rpb25SZXN0b3JlZC50aGVuKCgpID0+IHNldFJlc3RvcmVkKHRydWUpKTtcbiAgICB9XG4gIH0sIFt0b25Db25uZWN0VUkyXSk7XG4gIHJldHVybiByZXN0b3JlZDtcbn1cbmV4cG9ydCB7XG4gIFRvbkNvbm5lY3RCdXR0b24kMSBhcyBUb25Db25uZWN0QnV0dG9uLFxuICBUb25Db25uZWN0UHJvdmlkZXJOb3RTZXRFcnJvcixcbiAgVG9uQ29ubmVjdFVJQ29udGV4dCxcbiAgVG9uQ29ubmVjdFVJUHJvdmlkZXIkMSBhcyBUb25Db25uZWN0VUlQcm92aWRlcixcbiAgVG9uQ29ubmVjdFVJUmVhY3RFcnJvcixcbiAgdXNlSXNDb25uZWN0aW9uUmVzdG9yZWQsXG4gIHVzZVRvbkFkZHJlc3MsXG4gIHVzZVRvbkNvbm5lY3RVSSxcbiAgdXNlVG9uV2FsbGV0XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@tonconnect/ui-react/lib/index.js\n");

/***/ }),

/***/ "./node_modules/@tonconnect/ui/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@tonconnect/ui/lib/index.js ***!
  \**************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   THEME: () => (/* binding */ THEME),\n/* harmony export */   TonConnectUI: () => (/* binding */ TonConnectUI),\n/* harmony export */   TonConnectUIError: () => (/* binding */ TonConnectUIError)\n/* harmony export */ });\n/* harmony import */ var _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tonconnect/sdk */ \"./node_modules/@tonconnect/ui/node_modules/@tonconnect/sdk/lib/esm/index.mjs\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! deepmerge */ \"deepmerge\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ua-parser-js */ \"ua-parser-js\");\n/* harmony import */ var ua_parser_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(ua_parser_js__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! classnames */ \"classnames\");\n/* harmony import */ var classnames__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(classnames__WEBPACK_IMPORTED_MODULE_3__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__]);\n_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__) if([\"default\",\"THEME\",\"TonConnectUI\",\"TonConnectUIError\"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a2, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a2, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a2, prop, b[prop]);\n    }\n  return a2;\n};\nvar __spreadProps = (a2, b) => __defProps(a2, __getOwnPropDescs(b));\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e2) {\n        reject(e2);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\n\n\n\n\n\nconst sharedConfig = {};\nfunction setHydrateContext(context) {\n  sharedConfig.context = context;\n}\nconst equalFn = (a2, b) => a2 === b;\nconst $PROXY = Symbol(\"solid-proxy\");\nconst $TRACK = Symbol(\"solid-track\");\nconst signalOptions = {\n  equals: equalFn\n};\nlet runEffects = runQueue;\nconst STALE = 1;\nconst PENDING = 2;\nconst UNOWNED = {\n  owned: null,\n  cleanups: null,\n  context: null,\n  owner: null\n};\nconst NO_INIT = {};\nvar Owner = null;\nlet Transition$1 = null;\nlet Listener = null;\nlet Updates = null;\nlet Effects = null;\nlet ExecCount = 0;\nfunction createRoot(fn, detachedOwner) {\n  const listener = Listener, owner = Owner, unowned = fn.length === 0, root = unowned ? UNOWNED : {\n    owned: null,\n    cleanups: null,\n    context: null,\n    owner: detachedOwner === void 0 ? owner : detachedOwner\n  }, updateFn = unowned ? fn : () => fn(() => untrack(() => cleanNode(root)));\n  Owner = root;\n  Listener = null;\n  try {\n    return runUpdates(updateFn, true);\n  } finally {\n    Listener = listener;\n    Owner = owner;\n  }\n}\nfunction createSignal(value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const s2 = {\n    value,\n    observers: null,\n    observerSlots: null,\n    comparator: options.equals || void 0\n  };\n  const setter = (value2) => {\n    if (typeof value2 === \"function\") {\n      value2 = value2(s2.value);\n    }\n    return writeSignal(s2, value2);\n  };\n  return [readSignal.bind(s2), setter];\n}\nfunction createComputed(fn, value, options) {\n  const c2 = createComputation(fn, value, true, STALE);\n  updateComputation(c2);\n}\nfunction createRenderEffect(fn, value, options) {\n  const c2 = createComputation(fn, value, false, STALE);\n  updateComputation(c2);\n}\nfunction createEffect(fn, value, options) {\n  runEffects = runUserEffects;\n  const c2 = createComputation(fn, value, false, STALE);\n  c2.user = true;\n  Effects ? Effects.push(c2) : updateComputation(c2);\n}\nfunction createMemo(fn, value, options) {\n  options = options ? Object.assign({}, signalOptions, options) : signalOptions;\n  const c2 = createComputation(fn, value, true, 0);\n  c2.observers = null;\n  c2.observerSlots = null;\n  c2.comparator = options.equals || void 0;\n  updateComputation(c2);\n  return readSignal.bind(c2);\n}\nfunction createResource(pSource, pFetcher, pOptions) {\n  let source;\n  let fetcher;\n  let options;\n  if (arguments.length === 2 && typeof pFetcher === \"object\" || arguments.length === 1) {\n    source = true;\n    fetcher = pSource;\n    options = pFetcher || {};\n  } else {\n    source = pSource;\n    fetcher = pFetcher;\n    options = pOptions || {};\n  }\n  let pr = null, initP = NO_INIT, id = null, scheduled = false, resolved = \"initialValue\" in options, dynamic = typeof source === \"function\" && createMemo(source);\n  const contexts = /* @__PURE__ */ new Set(), [value, setValue] = (options.storage || createSignal)(options.initialValue), [error, setError] = createSignal(void 0), [track, trigger] = createSignal(void 0, {\n    equals: false\n  }), [state, setState] = createSignal(resolved ? \"ready\" : \"unresolved\");\n  if (sharedConfig.context) {\n    id = `${sharedConfig.context.id}${sharedConfig.context.count++}`;\n    let v;\n    if (options.ssrLoadFrom === \"initial\")\n      initP = options.initialValue;\n    else if (sharedConfig.load && (v = sharedConfig.load(id)))\n      initP = v[0];\n  }\n  function loadEnd(p2, v, error2, key) {\n    if (pr === p2) {\n      pr = null;\n      resolved = true;\n      if ((p2 === initP || v === initP) && options.onHydrated)\n        queueMicrotask(() => options.onHydrated(key, {\n          value: v\n        }));\n      initP = NO_INIT;\n      completeLoad(v, error2);\n    }\n    return v;\n  }\n  function completeLoad(v, err) {\n    runUpdates(() => {\n      if (err === void 0)\n        setValue(() => v);\n      setState(err !== void 0 ? \"errored\" : \"ready\");\n      setError(err);\n      for (const c2 of contexts.keys())\n        c2.decrement();\n      contexts.clear();\n    }, false);\n  }\n  function read() {\n    const c2 = SuspenseContext, v = value(), err = error();\n    if (err !== void 0 && !pr)\n      throw err;\n    if (Listener && !Listener.user && c2) {\n      createComputed(() => {\n        track();\n        if (pr) {\n          if (c2.resolved)\n            ;\n          else if (!contexts.has(c2)) {\n            c2.increment();\n            contexts.add(c2);\n          }\n        }\n      });\n    }\n    return v;\n  }\n  function load(refetching = true) {\n    if (refetching !== false && scheduled)\n      return;\n    scheduled = false;\n    const lookup2 = dynamic ? dynamic() : source;\n    if (lookup2 == null || lookup2 === false) {\n      loadEnd(pr, untrack(value));\n      return;\n    }\n    const p2 = initP !== NO_INIT ? initP : untrack(() => fetcher(lookup2, {\n      value: value(),\n      refetching\n    }));\n    if (typeof p2 !== \"object\" || !(p2 && \"then\" in p2)) {\n      loadEnd(pr, p2, void 0, lookup2);\n      return p2;\n    }\n    pr = p2;\n    scheduled = true;\n    queueMicrotask(() => scheduled = false);\n    runUpdates(() => {\n      setState(resolved ? \"refreshing\" : \"pending\");\n      trigger();\n    }, false);\n    return p2.then((v) => loadEnd(p2, v, void 0, lookup2), (e2) => loadEnd(p2, void 0, castError(e2), lookup2));\n  }\n  Object.defineProperties(read, {\n    state: {\n      get: () => state()\n    },\n    error: {\n      get: () => error()\n    },\n    loading: {\n      get() {\n        const s2 = state();\n        return s2 === \"pending\" || s2 === \"refreshing\";\n      }\n    },\n    latest: {\n      get() {\n        if (!resolved)\n          return read();\n        const err = error();\n        if (err && !pr)\n          throw err;\n        return value();\n      }\n    }\n  });\n  if (dynamic)\n    createComputed(() => load(false));\n  else\n    load(false);\n  return [read, {\n    refetch: load,\n    mutate: setValue\n  }];\n}\nfunction batch(fn) {\n  return runUpdates(fn, false);\n}\nfunction untrack(fn) {\n  if (Listener === null)\n    return fn();\n  const listener = Listener;\n  Listener = null;\n  try {\n    return fn();\n  } finally {\n    Listener = listener;\n  }\n}\nfunction on(deps, fn, options) {\n  const isArray = Array.isArray(deps);\n  let prevInput;\n  let defer = options && options.defer;\n  return (prevValue) => {\n    let input;\n    if (isArray) {\n      input = Array(deps.length);\n      for (let i2 = 0; i2 < deps.length; i2++)\n        input[i2] = deps[i2]();\n    } else\n      input = deps();\n    if (defer) {\n      defer = false;\n      return void 0;\n    }\n    const result = untrack(() => fn(input, prevInput, prevValue));\n    prevInput = input;\n    return result;\n  };\n}\nfunction onMount(fn) {\n  createEffect(() => untrack(fn));\n}\nfunction onCleanup(fn) {\n  if (Owner === null)\n    ;\n  else if (Owner.cleanups === null)\n    Owner.cleanups = [fn];\n  else\n    Owner.cleanups.push(fn);\n  return fn;\n}\nfunction getListener() {\n  return Listener;\n}\nfunction getOwner() {\n  return Owner;\n}\nfunction createContext(defaultValue, options) {\n  const id = Symbol(\"context\");\n  return {\n    id,\n    Provider: createProvider(id),\n    defaultValue\n  };\n}\nfunction useContext(context) {\n  let ctx;\n  return (ctx = lookup(Owner, context.id)) !== void 0 ? ctx : context.defaultValue;\n}\nfunction children(fn) {\n  const children2 = createMemo(fn);\n  const memo = createMemo(() => resolveChildren(children2()));\n  memo.toArray = () => {\n    const c2 = memo();\n    return Array.isArray(c2) ? c2 : c2 != null ? [c2] : [];\n  };\n  return memo;\n}\nlet SuspenseContext;\nfunction readSignal() {\n  const runningTransition = Transition$1;\n  if (this.sources && (this.state || runningTransition)) {\n    if (this.state === STALE || runningTransition)\n      updateComputation(this);\n    else {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(this), false);\n      Updates = updates;\n    }\n  }\n  if (Listener) {\n    const sSlot = this.observers ? this.observers.length : 0;\n    if (!Listener.sources) {\n      Listener.sources = [this];\n      Listener.sourceSlots = [sSlot];\n    } else {\n      Listener.sources.push(this);\n      Listener.sourceSlots.push(sSlot);\n    }\n    if (!this.observers) {\n      this.observers = [Listener];\n      this.observerSlots = [Listener.sources.length - 1];\n    } else {\n      this.observers.push(Listener);\n      this.observerSlots.push(Listener.sources.length - 1);\n    }\n  }\n  return this.value;\n}\nfunction writeSignal(node, value, isComp) {\n  let current = node.value;\n  if (!node.comparator || !node.comparator(current, value)) {\n    node.value = value;\n    if (node.observers && node.observers.length) {\n      runUpdates(() => {\n        for (let i2 = 0; i2 < node.observers.length; i2 += 1) {\n          const o2 = node.observers[i2];\n          const TransitionRunning = Transition$1 && Transition$1.running;\n          if (TransitionRunning && Transition$1.disposed.has(o2))\n            ;\n          if (TransitionRunning && !o2.tState || !TransitionRunning && !o2.state) {\n            if (o2.pure)\n              Updates.push(o2);\n            else\n              Effects.push(o2);\n            if (o2.observers)\n              markDownstream(o2);\n          }\n          if (TransitionRunning)\n            ;\n          else\n            o2.state = STALE;\n        }\n        if (Updates.length > 1e6) {\n          Updates = [];\n          if (false)\n            {}\n          throw new Error();\n        }\n      }, false);\n    }\n  }\n  return value;\n}\nfunction updateComputation(node) {\n  if (!node.fn)\n    return;\n  cleanNode(node);\n  const owner = Owner, listener = Listener, time = ExecCount;\n  Listener = Owner = node;\n  runComputation(node, node.value, time);\n  Listener = listener;\n  Owner = owner;\n}\nfunction runComputation(node, value, time) {\n  let nextValue;\n  try {\n    nextValue = node.fn(value);\n  } catch (err) {\n    if (node.pure) {\n      {\n        node.state = STALE;\n        node.owned && node.owned.forEach(cleanNode);\n        node.owned = null;\n      }\n    }\n    handleError(err);\n  }\n  if (!node.updatedAt || node.updatedAt <= time) {\n    if (node.updatedAt != null && \"observers\" in node) {\n      writeSignal(node, nextValue);\n    } else\n      node.value = nextValue;\n    node.updatedAt = time;\n  }\n}\nfunction createComputation(fn, init, pure, state = STALE, options) {\n  const c2 = {\n    fn,\n    state,\n    updatedAt: null,\n    owned: null,\n    sources: null,\n    sourceSlots: null,\n    cleanups: null,\n    value: init,\n    owner: Owner,\n    context: null,\n    pure\n  };\n  if (Owner === null)\n    ;\n  else if (Owner !== UNOWNED) {\n    {\n      if (!Owner.owned)\n        Owner.owned = [c2];\n      else\n        Owner.owned.push(c2);\n    }\n  }\n  return c2;\n}\nfunction runTop(node) {\n  const runningTransition = Transition$1;\n  if (node.state === 0 || runningTransition)\n    return;\n  if (node.state === PENDING || runningTransition)\n    return lookUpstream(node);\n  if (node.suspense && untrack(node.suspense.inFallback))\n    return node.suspense.effects.push(node);\n  const ancestors = [node];\n  while ((node = node.owner) && (!node.updatedAt || node.updatedAt < ExecCount)) {\n    if (node.state || runningTransition)\n      ancestors.push(node);\n  }\n  for (let i2 = ancestors.length - 1; i2 >= 0; i2--) {\n    node = ancestors[i2];\n    if (node.state === STALE || runningTransition) {\n      updateComputation(node);\n    } else if (node.state === PENDING || runningTransition) {\n      const updates = Updates;\n      Updates = null;\n      runUpdates(() => lookUpstream(node, ancestors[0]), false);\n      Updates = updates;\n    }\n  }\n}\nfunction runUpdates(fn, init) {\n  if (Updates)\n    return fn();\n  let wait = false;\n  if (!init)\n    Updates = [];\n  if (Effects)\n    wait = true;\n  else\n    Effects = [];\n  ExecCount++;\n  try {\n    const res = fn();\n    completeUpdates(wait);\n    return res;\n  } catch (err) {\n    if (!wait)\n      Effects = null;\n    Updates = null;\n    handleError(err);\n  }\n}\nfunction completeUpdates(wait) {\n  if (Updates) {\n    runQueue(Updates);\n    Updates = null;\n  }\n  if (wait)\n    return;\n  const e2 = Effects;\n  Effects = null;\n  if (e2.length)\n    runUpdates(() => runEffects(e2), false);\n}\nfunction runQueue(queue) {\n  for (let i2 = 0; i2 < queue.length; i2++)\n    runTop(queue[i2]);\n}\nfunction runUserEffects(queue) {\n  let i2, userLength = 0;\n  for (i2 = 0; i2 < queue.length; i2++) {\n    const e2 = queue[i2];\n    if (!e2.user)\n      runTop(e2);\n    else\n      queue[userLength++] = e2;\n  }\n  if (sharedConfig.context)\n    setHydrateContext();\n  for (i2 = 0; i2 < userLength; i2++)\n    runTop(queue[i2]);\n}\nfunction lookUpstream(node, ignore) {\n  const runningTransition = Transition$1;\n  node.state = 0;\n  for (let i2 = 0; i2 < node.sources.length; i2 += 1) {\n    const source = node.sources[i2];\n    if (source.sources) {\n      if (source.state === STALE || runningTransition) {\n        if (source !== ignore)\n          runTop(source);\n      } else if (source.state === PENDING || runningTransition)\n        lookUpstream(source, ignore);\n    }\n  }\n}\nfunction markDownstream(node) {\n  const runningTransition = Transition$1;\n  for (let i2 = 0; i2 < node.observers.length; i2 += 1) {\n    const o2 = node.observers[i2];\n    if (!o2.state || runningTransition) {\n      o2.state = PENDING;\n      if (o2.pure)\n        Updates.push(o2);\n      else\n        Effects.push(o2);\n      o2.observers && markDownstream(o2);\n    }\n  }\n}\nfunction cleanNode(node) {\n  let i2;\n  if (node.sources) {\n    while (node.sources.length) {\n      const source = node.sources.pop(), index = node.sourceSlots.pop(), obs = source.observers;\n      if (obs && obs.length) {\n        const n2 = obs.pop(), s2 = source.observerSlots.pop();\n        if (index < obs.length) {\n          n2.sourceSlots[s2] = index;\n          obs[index] = n2;\n          source.observerSlots[index] = s2;\n        }\n      }\n    }\n  }\n  if (node.owned) {\n    for (i2 = 0; i2 < node.owned.length; i2++)\n      cleanNode(node.owned[i2]);\n    node.owned = null;\n  }\n  if (node.cleanups) {\n    for (i2 = 0; i2 < node.cleanups.length; i2++)\n      node.cleanups[i2]();\n    node.cleanups = null;\n  }\n  node.state = 0;\n  node.context = null;\n}\nfunction castError(err) {\n  if (err instanceof Error || typeof err === \"string\")\n    return err;\n  return new Error(\"Unknown error\");\n}\nfunction handleError(err) {\n  err = castError(err);\n  throw err;\n}\nfunction lookup(owner, key) {\n  return owner ? owner.context && owner.context[key] !== void 0 ? owner.context[key] : lookup(owner.owner, key) : void 0;\n}\nfunction resolveChildren(children2) {\n  if (typeof children2 === \"function\" && !children2.length)\n    return resolveChildren(children2());\n  if (Array.isArray(children2)) {\n    const results = [];\n    for (let i2 = 0; i2 < children2.length; i2++) {\n      const result = resolveChildren(children2[i2]);\n      Array.isArray(result) ? results.push.apply(results, result) : results.push(result);\n    }\n    return results;\n  }\n  return children2;\n}\nfunction createProvider(id, options) {\n  return function provider(props) {\n    let res;\n    createRenderEffect(() => res = untrack(() => {\n      Owner.context = {\n        [id]: props.value\n      };\n      return children(() => props.children);\n    }), void 0);\n    return res;\n  };\n}\nconst FALLBACK = Symbol(\"fallback\");\nfunction dispose(d) {\n  for (let i2 = 0; i2 < d.length; i2++)\n    d[i2]();\n}\nfunction mapArray(list, mapFn, options = {}) {\n  let items = [], mapped = [], disposers = [], len = 0, indexes = mapFn.length > 1 ? [] : null;\n  onCleanup(() => dispose(disposers));\n  return () => {\n    let newItems = list() || [], i2, j;\n    newItems[$TRACK];\n    return untrack(() => {\n      let newLen = newItems.length, newIndices, newIndicesNext, temp, tempdisposers, tempIndexes, start, end, newEnd, item;\n      if (newLen === 0) {\n        if (len !== 0) {\n          dispose(disposers);\n          disposers = [];\n          items = [];\n          mapped = [];\n          len = 0;\n          indexes && (indexes = []);\n        }\n        if (options.fallback) {\n          items = [FALLBACK];\n          mapped[0] = createRoot((disposer) => {\n            disposers[0] = disposer;\n            return options.fallback();\n          });\n          len = 1;\n        }\n      } else if (len === 0) {\n        mapped = new Array(newLen);\n        for (j = 0; j < newLen; j++) {\n          items[j] = newItems[j];\n          mapped[j] = createRoot(mapper);\n        }\n        len = newLen;\n      } else {\n        temp = new Array(newLen);\n        tempdisposers = new Array(newLen);\n        indexes && (tempIndexes = new Array(newLen));\n        for (start = 0, end = Math.min(len, newLen); start < end && items[start] === newItems[start]; start++)\n          ;\n        for (end = len - 1, newEnd = newLen - 1; end >= start && newEnd >= start && items[end] === newItems[newEnd]; end--, newEnd--) {\n          temp[newEnd] = mapped[end];\n          tempdisposers[newEnd] = disposers[end];\n          indexes && (tempIndexes[newEnd] = indexes[end]);\n        }\n        newIndices = /* @__PURE__ */ new Map();\n        newIndicesNext = new Array(newEnd + 1);\n        for (j = newEnd; j >= start; j--) {\n          item = newItems[j];\n          i2 = newIndices.get(item);\n          newIndicesNext[j] = i2 === void 0 ? -1 : i2;\n          newIndices.set(item, j);\n        }\n        for (i2 = start; i2 <= end; i2++) {\n          item = items[i2];\n          j = newIndices.get(item);\n          if (j !== void 0 && j !== -1) {\n            temp[j] = mapped[i2];\n            tempdisposers[j] = disposers[i2];\n            indexes && (tempIndexes[j] = indexes[i2]);\n            j = newIndicesNext[j];\n            newIndices.set(item, j);\n          } else\n            disposers[i2]();\n        }\n        for (j = start; j < newLen; j++) {\n          if (j in temp) {\n            mapped[j] = temp[j];\n            disposers[j] = tempdisposers[j];\n            if (indexes) {\n              indexes[j] = tempIndexes[j];\n              indexes[j](j);\n            }\n          } else\n            mapped[j] = createRoot(mapper);\n        }\n        mapped = mapped.slice(0, len = newLen);\n        items = newItems.slice(0);\n      }\n      return mapped;\n    });\n    function mapper(disposer) {\n      disposers[j] = disposer;\n      if (indexes) {\n        const [s2, set] = createSignal(j);\n        indexes[j] = set;\n        return mapFn(newItems[j], s2);\n      }\n      return mapFn(newItems[j]);\n    }\n  };\n}\nfunction createComponent(Comp, props) {\n  return untrack(() => Comp(props || {}));\n}\nfunction trueFn() {\n  return true;\n}\nconst propTraps = {\n  get(_, property, receiver) {\n    if (property === $PROXY)\n      return receiver;\n    return _.get(property);\n  },\n  has(_, property) {\n    if (property === $PROXY)\n      return true;\n    return _.has(property);\n  },\n  set: trueFn,\n  deleteProperty: trueFn,\n  getOwnPropertyDescriptor(_, property) {\n    return {\n      configurable: true,\n      enumerable: true,\n      get() {\n        return _.get(property);\n      },\n      set: trueFn,\n      deleteProperty: trueFn\n    };\n  },\n  ownKeys(_) {\n    return _.keys();\n  }\n};\nfunction resolveSource(s2) {\n  return !(s2 = typeof s2 === \"function\" ? s2() : s2) ? {} : s2;\n}\nfunction mergeProps(...sources) {\n  let proxy = false;\n  for (let i2 = 0; i2 < sources.length; i2++) {\n    const s2 = sources[i2];\n    proxy = proxy || !!s2 && $PROXY in s2;\n    sources[i2] = typeof s2 === \"function\" ? (proxy = true, createMemo(s2)) : s2;\n  }\n  if (proxy) {\n    return new Proxy({\n      get(property) {\n        for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n          const v = resolveSource(sources[i2])[property];\n          if (v !== void 0)\n            return v;\n        }\n      },\n      has(property) {\n        for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n          if (property in resolveSource(sources[i2]))\n            return true;\n        }\n        return false;\n      },\n      keys() {\n        const keys = [];\n        for (let i2 = 0; i2 < sources.length; i2++)\n          keys.push(...Object.keys(resolveSource(sources[i2])));\n        return [...new Set(keys)];\n      }\n    }, propTraps);\n  }\n  const target = {};\n  for (let i2 = sources.length - 1; i2 >= 0; i2--) {\n    if (sources[i2]) {\n      const descriptors = Object.getOwnPropertyDescriptors(sources[i2]);\n      for (const key in descriptors) {\n        if (key in target)\n          continue;\n        Object.defineProperty(target, key, {\n          enumerable: true,\n          get() {\n            for (let i3 = sources.length - 1; i3 >= 0; i3--) {\n              const v = (sources[i3] || {})[key];\n              if (v !== void 0)\n                return v;\n            }\n          }\n        });\n      }\n    }\n  }\n  return target;\n}\nfunction splitProps(props, ...keys) {\n  const blocked = new Set(keys.flat());\n  if ($PROXY in props) {\n    const res = keys.map((k) => {\n      return new Proxy({\n        get(property) {\n          return k.includes(property) ? props[property] : void 0;\n        },\n        has(property) {\n          return k.includes(property) && property in props;\n        },\n        keys() {\n          return k.filter((property) => property in props);\n        }\n      }, propTraps);\n    });\n    res.push(new Proxy({\n      get(property) {\n        return blocked.has(property) ? void 0 : props[property];\n      },\n      has(property) {\n        return blocked.has(property) ? false : property in props;\n      },\n      keys() {\n        return Object.keys(props).filter((k) => !blocked.has(k));\n      }\n    }, propTraps));\n    return res;\n  }\n  const descriptors = Object.getOwnPropertyDescriptors(props);\n  keys.push(Object.keys(descriptors).filter((k) => !blocked.has(k)));\n  return keys.map((k) => {\n    const clone = {};\n    for (let i2 = 0; i2 < k.length; i2++) {\n      const key = k[i2];\n      if (!(key in props))\n        continue;\n      Object.defineProperty(clone, key, descriptors[key] ? descriptors[key] : {\n        get() {\n          return props[key];\n        },\n        set() {\n          return true;\n        },\n        enumerable: true\n      });\n    }\n    return clone;\n  });\n}\nfunction For(props) {\n  const fallback = \"fallback\" in props && {\n    fallback: () => props.fallback\n  };\n  return createMemo(mapArray(() => props.each, props.children, fallback || void 0));\n}\nfunction Show(props) {\n  let strictEqual = false;\n  const keyed = props.keyed;\n  const condition = createMemo(() => props.when, void 0, {\n    equals: (a2, b) => strictEqual ? a2 === b : !a2 === !b\n  });\n  return createMemo(() => {\n    const c2 = condition();\n    if (c2) {\n      const child = props.children;\n      const fn = typeof child === \"function\" && child.length > 0;\n      strictEqual = keyed || fn;\n      return fn ? untrack(() => child(c2)) : child;\n    }\n    return props.fallback;\n  }, void 0, void 0);\n}\nfunction Switch(props) {\n  let strictEqual = false;\n  let keyed = false;\n  const equals = (a2, b) => a2[0] === b[0] && (strictEqual ? a2[1] === b[1] : !a2[1] === !b[1]) && a2[2] === b[2];\n  const conditions = children(() => props.children), evalConditions = createMemo(() => {\n    let conds = conditions();\n    if (!Array.isArray(conds))\n      conds = [conds];\n    for (let i2 = 0; i2 < conds.length; i2++) {\n      const c2 = conds[i2].when;\n      if (c2) {\n        keyed = !!conds[i2].keyed;\n        return [i2, c2, conds[i2]];\n      }\n    }\n    return [-1];\n  }, void 0, {\n    equals\n  });\n  return createMemo(() => {\n    const [index, when, cond] = evalConditions();\n    if (index < 0)\n      return props.fallback;\n    const c2 = cond.children;\n    const fn = typeof c2 === \"function\" && c2.length > 0;\n    strictEqual = keyed || fn;\n    return fn ? untrack(() => c2(when)) : c2;\n  }, void 0, void 0);\n}\nfunction Match(props) {\n  return props;\n}\nconst booleans = [\"allowfullscreen\", \"async\", \"autofocus\", \"autoplay\", \"checked\", \"controls\", \"default\", \"disabled\", \"formnovalidate\", \"hidden\", \"indeterminate\", \"ismap\", \"loop\", \"multiple\", \"muted\", \"nomodule\", \"novalidate\", \"open\", \"playsinline\", \"readonly\", \"required\", \"reversed\", \"seamless\", \"selected\"];\nconst Properties = /* @__PURE__ */ new Set([\"className\", \"value\", \"readOnly\", \"formNoValidate\", \"isMap\", \"noModule\", \"playsInline\", ...booleans]);\nconst ChildProperties = /* @__PURE__ */ new Set([\"innerHTML\", \"textContent\", \"innerText\", \"children\"]);\nconst Aliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  className: \"class\",\n  htmlFor: \"for\"\n});\nconst PropAliases = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {\n  class: \"className\",\n  formnovalidate: \"formNoValidate\",\n  ismap: \"isMap\",\n  nomodule: \"noModule\",\n  playsinline: \"playsInline\",\n  readonly: \"readOnly\"\n});\nconst DelegatedEvents = /* @__PURE__ */ new Set([\"beforeinput\", \"click\", \"dblclick\", \"contextmenu\", \"focusin\", \"focusout\", \"input\", \"keydown\", \"keyup\", \"mousedown\", \"mousemove\", \"mouseout\", \"mouseover\", \"mouseup\", \"pointerdown\", \"pointermove\", \"pointerout\", \"pointerover\", \"pointerup\", \"touchend\", \"touchmove\", \"touchstart\"]);\nconst SVGElements = /* @__PURE__ */ new Set([\n  \"altGlyph\",\n  \"altGlyphDef\",\n  \"altGlyphItem\",\n  \"animate\",\n  \"animateColor\",\n  \"animateMotion\",\n  \"animateTransform\",\n  \"circle\",\n  \"clipPath\",\n  \"color-profile\",\n  \"cursor\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"feBlend\",\n  \"feColorMatrix\",\n  \"feComponentTransfer\",\n  \"feComposite\",\n  \"feConvolveMatrix\",\n  \"feDiffuseLighting\",\n  \"feDisplacementMap\",\n  \"feDistantLight\",\n  \"feFlood\",\n  \"feFuncA\",\n  \"feFuncB\",\n  \"feFuncG\",\n  \"feFuncR\",\n  \"feGaussianBlur\",\n  \"feImage\",\n  \"feMerge\",\n  \"feMergeNode\",\n  \"feMorphology\",\n  \"feOffset\",\n  \"fePointLight\",\n  \"feSpecularLighting\",\n  \"feSpotLight\",\n  \"feTile\",\n  \"feTurbulence\",\n  \"filter\",\n  \"font\",\n  \"font-face\",\n  \"font-face-format\",\n  \"font-face-name\",\n  \"font-face-src\",\n  \"font-face-uri\",\n  \"foreignObject\",\n  \"g\",\n  \"glyph\",\n  \"glyphRef\",\n  \"hkern\",\n  \"image\",\n  \"line\",\n  \"linearGradient\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"missing-glyph\",\n  \"mpath\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"radialGradient\",\n  \"rect\",\n  \"set\",\n  \"stop\",\n  \"svg\",\n  \"switch\",\n  \"symbol\",\n  \"text\",\n  \"textPath\",\n  \"tref\",\n  \"tspan\",\n  \"use\",\n  \"view\",\n  \"vkern\"\n]);\nconst SVGNamespace = {\n  xlink: \"http://www.w3.org/1999/xlink\",\n  xml: \"http://www.w3.org/XML/1998/namespace\"\n};\nfunction reconcileArrays(parentNode, a2, b) {\n  let bLength = b.length, aEnd = a2.length, bEnd = bLength, aStart = 0, bStart = 0, after = a2[aEnd - 1].nextSibling, map = null;\n  while (aStart < aEnd || bStart < bEnd) {\n    if (a2[aStart] === b[bStart]) {\n      aStart++;\n      bStart++;\n      continue;\n    }\n    while (a2[aEnd - 1] === b[bEnd - 1]) {\n      aEnd--;\n      bEnd--;\n    }\n    if (aEnd === aStart) {\n      const node = bEnd < bLength ? bStart ? b[bStart - 1].nextSibling : b[bEnd - bStart] : after;\n      while (bStart < bEnd)\n        parentNode.insertBefore(b[bStart++], node);\n    } else if (bEnd === bStart) {\n      while (aStart < aEnd) {\n        if (!map || !map.has(a2[aStart]))\n          a2[aStart].remove();\n        aStart++;\n      }\n    } else if (a2[aStart] === b[bEnd - 1] && b[bStart] === a2[aEnd - 1]) {\n      const node = a2[--aEnd].nextSibling;\n      parentNode.insertBefore(b[bStart++], a2[aStart++].nextSibling);\n      parentNode.insertBefore(b[--bEnd], node);\n      a2[aEnd] = b[bEnd];\n    } else {\n      if (!map) {\n        map = /* @__PURE__ */ new Map();\n        let i2 = bStart;\n        while (i2 < bEnd)\n          map.set(b[i2], i2++);\n      }\n      const index = map.get(a2[aStart]);\n      if (index != null) {\n        if (bStart < index && index < bEnd) {\n          let i2 = aStart, sequence = 1, t2;\n          while (++i2 < aEnd && i2 < bEnd) {\n            if ((t2 = map.get(a2[i2])) == null || t2 !== index + sequence)\n              break;\n            sequence++;\n          }\n          if (sequence > index - bStart) {\n            const node = a2[aStart];\n            while (bStart < index)\n              parentNode.insertBefore(b[bStart++], node);\n          } else\n            parentNode.replaceChild(b[bStart++], a2[aStart++]);\n        } else\n          aStart++;\n      } else\n        a2[aStart++].remove();\n    }\n  }\n}\nconst $$EVENTS = \"_$DX_DELEGATE\";\nfunction render(code, element, init, options = {}) {\n  let disposer;\n  createRoot((dispose2) => {\n    disposer = dispose2;\n    element === document ? code() : insert(element, code(), element.firstChild ? null : void 0, init);\n  }, options.owner);\n  return () => {\n    disposer();\n    element.textContent = \"\";\n  };\n}\nfunction template$1(html, check, isSVG) {\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  const t2 = document.createElement(\"template\");\n  t2.innerHTML = html;\n  let node = t2.content.firstChild;\n  if (isSVG)\n    node = node.firstChild;\n  return node;\n}\nfunction delegateEvents(eventNames, document2 = window.document) {\n  const e2 = document2[$$EVENTS] || (document2[$$EVENTS] = /* @__PURE__ */ new Set());\n  for (let i2 = 0, l2 = eventNames.length; i2 < l2; i2++) {\n    const name = eventNames[i2];\n    if (!e2.has(name)) {\n      e2.add(name);\n      document2.addEventListener(name, eventHandler);\n    }\n  }\n}\nfunction setAttribute(node, name, value) {\n  if (value == null)\n    node.removeAttribute(name);\n  else\n    node.setAttribute(name, value);\n}\nfunction setAttributeNS(node, namespace, name, value) {\n  if (value == null)\n    node.removeAttributeNS(namespace, name);\n  else\n    node.setAttributeNS(namespace, name, value);\n}\nfunction className(node, value) {\n  if (value == null)\n    node.removeAttribute(\"class\");\n  else\n    node.className = value;\n}\nfunction addEventListener(node, name, handler, delegate) {\n  if (delegate) {\n    if (Array.isArray(handler)) {\n      node[`$$${name}`] = handler[0];\n      node[`$$${name}Data`] = handler[1];\n    } else\n      node[`$$${name}`] = handler;\n  } else if (Array.isArray(handler)) {\n    const handlerFn = handler[0];\n    node.addEventListener(name, handler[0] = (e2) => handlerFn.call(node, handler[1], e2));\n  } else\n    node.addEventListener(name, handler);\n}\nfunction classList(node, value, prev = {}) {\n  const classKeys = Object.keys(value || {}), prevKeys = Object.keys(prev);\n  let i2, len;\n  for (i2 = 0, len = prevKeys.length; i2 < len; i2++) {\n    const key = prevKeys[i2];\n    if (!key || key === \"undefined\" || value[key])\n      continue;\n    toggleClassKey(node, key, false);\n    delete prev[key];\n  }\n  for (i2 = 0, len = classKeys.length; i2 < len; i2++) {\n    const key = classKeys[i2], classValue = !!value[key];\n    if (!key || key === \"undefined\" || prev[key] === classValue || !classValue)\n      continue;\n    toggleClassKey(node, key, true);\n    prev[key] = classValue;\n  }\n  return prev;\n}\nfunction style(node, value, prev) {\n  if (!value)\n    return prev ? setAttribute(node, \"style\") : value;\n  const nodeStyle = node.style;\n  if (typeof value === \"string\")\n    return nodeStyle.cssText = value;\n  typeof prev === \"string\" && (nodeStyle.cssText = prev = void 0);\n  prev || (prev = {});\n  value || (value = {});\n  let v, s2;\n  for (s2 in prev) {\n    value[s2] == null && nodeStyle.removeProperty(s2);\n    delete prev[s2];\n  }\n  for (s2 in value) {\n    v = value[s2];\n    if (v !== prev[s2]) {\n      nodeStyle.setProperty(s2, v);\n      prev[s2] = v;\n    }\n  }\n  return prev;\n}\nfunction spread(node, props = {}, isSVG, skipChildren) {\n  const prevProps = {};\n  if (!skipChildren) {\n    createRenderEffect(() => prevProps.children = insertExpression(node, props.children, prevProps.children));\n  }\n  createRenderEffect(() => props.ref && props.ref(node));\n  createRenderEffect(() => assign(node, props, isSVG, true, prevProps, true));\n  return prevProps;\n}\nfunction use(fn, element, arg) {\n  return untrack(() => fn(element, arg));\n}\nfunction insert(parent, accessor, marker, initial) {\n  if (marker !== void 0 && !initial)\n    initial = [];\n  if (typeof accessor !== \"function\")\n    return insertExpression(parent, accessor, initial, marker);\n  createRenderEffect((current) => insertExpression(parent, accessor(), current, marker), initial);\n}\nfunction assign(node, props, isSVG, skipChildren, prevProps = {}, skipRef = false) {\n  props || (props = {});\n  for (const prop in prevProps) {\n    if (!(prop in props)) {\n      if (prop === \"children\")\n        continue;\n      prevProps[prop] = assignProp(node, prop, null, prevProps[prop], isSVG, skipRef);\n    }\n  }\n  for (const prop in props) {\n    if (prop === \"children\") {\n      if (!skipChildren)\n        insertExpression(node, props.children);\n      continue;\n    }\n    const value = props[prop];\n    prevProps[prop] = assignProp(node, prop, value, prevProps[prop], isSVG, skipRef);\n  }\n}\nfunction getNextElement(template2) {\n  let node, key;\n  if (!sharedConfig.context || !(node = sharedConfig.registry.get(key = getHydrationKey()))) {\n    return template2.cloneNode(true);\n  }\n  if (sharedConfig.completed)\n    sharedConfig.completed.add(node);\n  sharedConfig.registry.delete(key);\n  return node;\n}\nfunction toPropertyName(name) {\n  return name.toLowerCase().replace(/-([a-z])/g, (_, w) => w.toUpperCase());\n}\nfunction toggleClassKey(node, key, value) {\n  const classNames = key.trim().split(/\\s+/);\n  for (let i2 = 0, nameLen = classNames.length; i2 < nameLen; i2++)\n    node.classList.toggle(classNames[i2], value);\n}\nfunction assignProp(node, prop, value, prev, isSVG, skipRef) {\n  let isCE, isProp, isChildProp;\n  if (prop === \"style\")\n    return style(node, value, prev);\n  if (prop === \"classList\")\n    return classList(node, value, prev);\n  if (value === prev)\n    return prev;\n  if (prop === \"ref\") {\n    if (!skipRef)\n      value(node);\n  } else if (prop.slice(0, 3) === \"on:\") {\n    const e2 = prop.slice(3);\n    prev && node.removeEventListener(e2, prev);\n    value && node.addEventListener(e2, value);\n  } else if (prop.slice(0, 10) === \"oncapture:\") {\n    const e2 = prop.slice(10);\n    prev && node.removeEventListener(e2, prev, true);\n    value && node.addEventListener(e2, value, true);\n  } else if (prop.slice(0, 2) === \"on\") {\n    const name = prop.slice(2).toLowerCase();\n    const delegate = DelegatedEvents.has(name);\n    if (!delegate && prev) {\n      const h2 = Array.isArray(prev) ? prev[0] : prev;\n      node.removeEventListener(name, h2);\n    }\n    if (delegate || value) {\n      addEventListener(node, name, value, delegate);\n      delegate && delegateEvents([name]);\n    }\n  } else if ((isChildProp = ChildProperties.has(prop)) || !isSVG && (PropAliases[prop] || (isProp = Properties.has(prop))) || (isCE = node.nodeName.includes(\"-\"))) {\n    if (prop === \"class\" || prop === \"className\")\n      className(node, value);\n    else if (isCE && !isProp && !isChildProp)\n      node[toPropertyName(prop)] = value;\n    else\n      node[PropAliases[prop] || prop] = value;\n  } else {\n    const ns = isSVG && prop.indexOf(\":\") > -1 && SVGNamespace[prop.split(\":\")[0]];\n    if (ns)\n      setAttributeNS(node, ns, prop, value);\n    else\n      setAttribute(node, Aliases[prop] || prop, value);\n  }\n  return value;\n}\nfunction eventHandler(e2) {\n  const key = `$$${e2.type}`;\n  let node = e2.composedPath && e2.composedPath()[0] || e2.target;\n  if (e2.target !== node) {\n    Object.defineProperty(e2, \"target\", {\n      configurable: true,\n      value: node\n    });\n  }\n  Object.defineProperty(e2, \"currentTarget\", {\n    configurable: true,\n    get() {\n      return node || document;\n    }\n  });\n  if (sharedConfig.registry && !sharedConfig.done) {\n    sharedConfig.done = true;\n    document.querySelectorAll(\"[id^=pl-]\").forEach((elem) => {\n      while (elem && elem.nodeType !== 8 && elem.nodeValue !== \"pl-\" + e2) {\n        let x = elem.nextSibling;\n        elem.remove();\n        elem = x;\n      }\n      elem && elem.remove();\n    });\n  }\n  while (node) {\n    const handler = node[key];\n    if (handler && !node.disabled) {\n      const data = node[`${key}Data`];\n      data !== void 0 ? handler.call(node, data, e2) : handler.call(node, e2);\n      if (e2.cancelBubble)\n        return;\n    }\n    node = node._$host || node.parentNode || node.host;\n  }\n}\nfunction insertExpression(parent, value, current, marker, unwrapArray) {\n  if (sharedConfig.context && !current)\n    current = [...parent.childNodes];\n  while (typeof current === \"function\")\n    current = current();\n  if (value === current)\n    return current;\n  const t2 = typeof value, multi = marker !== void 0;\n  parent = multi && current[0] && current[0].parentNode || parent;\n  if (t2 === \"string\" || t2 === \"number\") {\n    if (sharedConfig.context)\n      return current;\n    if (t2 === \"number\")\n      value = value.toString();\n    if (multi) {\n      let node = current[0];\n      if (node && node.nodeType === 3) {\n        node.data = value;\n      } else\n        node = document.createTextNode(value);\n      current = cleanChildren(parent, current, marker, node);\n    } else {\n      if (current !== \"\" && typeof current === \"string\") {\n        current = parent.firstChild.data = value;\n      } else\n        current = parent.textContent = value;\n    }\n  } else if (value == null || t2 === \"boolean\") {\n    if (sharedConfig.context)\n      return current;\n    current = cleanChildren(parent, current, marker);\n  } else if (t2 === \"function\") {\n    createRenderEffect(() => {\n      let v = value();\n      while (typeof v === \"function\")\n        v = v();\n      current = insertExpression(parent, v, current, marker);\n    });\n    return () => current;\n  } else if (Array.isArray(value)) {\n    const array = [];\n    const currentArray = current && Array.isArray(current);\n    if (normalizeIncomingArray(array, value, current, unwrapArray)) {\n      createRenderEffect(() => current = insertExpression(parent, array, current, marker, true));\n      return () => current;\n    }\n    if (sharedConfig.context) {\n      if (!array.length)\n        return current;\n      for (let i2 = 0; i2 < array.length; i2++) {\n        if (array[i2].parentNode)\n          return current = array;\n      }\n    }\n    if (array.length === 0) {\n      current = cleanChildren(parent, current, marker);\n      if (multi)\n        return current;\n    } else if (currentArray) {\n      if (current.length === 0) {\n        appendNodes(parent, array, marker);\n      } else\n        reconcileArrays(parent, current, array);\n    } else {\n      current && cleanChildren(parent);\n      appendNodes(parent, array);\n    }\n    current = array;\n  } else if (value instanceof Node) {\n    if (sharedConfig.context && value.parentNode)\n      return current = multi ? [value] : value;\n    if (Array.isArray(current)) {\n      if (multi)\n        return current = cleanChildren(parent, current, marker, value);\n      cleanChildren(parent, current, null, value);\n    } else if (current == null || current === \"\" || !parent.firstChild) {\n      parent.appendChild(value);\n    } else\n      parent.replaceChild(value, parent.firstChild);\n    current = value;\n  } else\n    ;\n  return current;\n}\nfunction normalizeIncomingArray(normalized, array, current, unwrap2) {\n  let dynamic = false;\n  for (let i2 = 0, len = array.length; i2 < len; i2++) {\n    let item = array[i2], prev = current && current[i2];\n    if (item instanceof Node) {\n      normalized.push(item);\n    } else if (item == null || item === true || item === false)\n      ;\n    else if (Array.isArray(item)) {\n      dynamic = normalizeIncomingArray(normalized, item, prev) || dynamic;\n    } else if (typeof item === \"function\") {\n      if (unwrap2) {\n        while (typeof item === \"function\")\n          item = item();\n        dynamic = normalizeIncomingArray(normalized, Array.isArray(item) ? item : [item], Array.isArray(prev) ? prev : [prev]) || dynamic;\n      } else {\n        normalized.push(item);\n        dynamic = true;\n      }\n    } else {\n      const value = String(item);\n      if (prev && prev.nodeType === 3 && prev.data === value) {\n        normalized.push(prev);\n      } else\n        normalized.push(document.createTextNode(value));\n    }\n  }\n  return dynamic;\n}\nfunction appendNodes(parent, array, marker = null) {\n  for (let i2 = 0, len = array.length; i2 < len; i2++)\n    parent.insertBefore(array[i2], marker);\n}\nfunction cleanChildren(parent, current, marker, replacement) {\n  if (marker === void 0)\n    return parent.textContent = \"\";\n  const node = replacement || document.createTextNode(\"\");\n  if (current.length) {\n    let inserted = false;\n    for (let i2 = current.length - 1; i2 >= 0; i2--) {\n      const el = current[i2];\n      if (node !== el) {\n        const isParent = el.parentNode === parent;\n        if (!inserted && !i2)\n          isParent ? parent.replaceChild(node, el) : parent.insertBefore(node, marker);\n        else\n          isParent && el.remove();\n      } else\n        inserted = true;\n    }\n  } else\n    parent.insertBefore(node, marker);\n  return [node];\n}\nfunction getHydrationKey() {\n  const hydrate = sharedConfig.context;\n  return `${hydrate.id}${hydrate.count++}`;\n}\nconst SVG_NAMESPACE = \"http://www.w3.org/2000/svg\";\nfunction createElement(tagName, isSVG = false) {\n  return isSVG ? document.createElementNS(SVG_NAMESPACE, tagName) : document.createElement(tagName);\n}\nfunction Portal(props) {\n  const {\n    useShadow\n  } = props, marker = document.createTextNode(\"\"), mount = props.mount || document.body;\n  function renderPortal() {\n    if (sharedConfig.context) {\n      const [s2, set] = createSignal(false);\n      queueMicrotask(() => set(true));\n      return () => s2() && props.children;\n    } else\n      return () => props.children;\n  }\n  if (mount instanceof HTMLHeadElement) {\n    const [clean, setClean] = createSignal(false);\n    const cleanup = () => setClean(true);\n    createRoot((dispose2) => insert(mount, () => !clean() ? renderPortal()() : dispose2(), null));\n    onCleanup(() => {\n      if (sharedConfig.context)\n        queueMicrotask(cleanup);\n      else\n        cleanup();\n    });\n  } else {\n    const container = createElement(props.isSVG ? \"g\" : \"div\", props.isSVG), renderRoot = useShadow && container.attachShadow ? container.attachShadow({\n      mode: \"open\"\n    }) : container;\n    Object.defineProperty(container, \"_$host\", {\n      get() {\n        return marker.parentNode;\n      },\n      configurable: true\n    });\n    insert(renderRoot, renderPortal());\n    mount.appendChild(container);\n    props.ref && props.ref(container);\n    onCleanup(() => mount.removeChild(container));\n  }\n  return marker;\n}\nfunction Dynamic(props) {\n  const [p2, others] = splitProps(props, [\"component\"]);\n  const cached = createMemo(() => p2.component);\n  return createMemo(() => {\n    const component = cached();\n    switch (typeof component) {\n      case \"function\":\n        return untrack(() => component(others));\n      case \"string\":\n        const isSvg = SVGElements.has(component);\n        const el = sharedConfig.context ? getNextElement() : createElement(component, isSvg);\n        spread(el, others, isSvg);\n        return el;\n    }\n  });\n}\nconst [walletsModalOpen, setWalletsModalOpen] = createSignal(false);\nconst [lastSelectedWalletInfo, setLastSelectedWalletInfo] = createSignal(null);\nconst [action, setAction] = createSignal(null);\nlet e = { data: \"\" }, t = (t2) => \"object\" == typeof window ? ((t2 ? t2.querySelector(\"#_goober\") : window._goober) || Object.assign((t2 || document.head).appendChild(document.createElement(\"style\")), { innerHTML: \" \", id: \"_goober\" })).firstChild : t2 || e, l = /(?:([\\u0080-\\uFFFF\\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\\s*)/g, a = /\\/\\*[^]*?\\*\\/|  +/g, n = /\\n+/g, o = (e2, t2) => {\n  let r = \"\", l2 = \"\", a2 = \"\";\n  for (let n2 in e2) {\n    let c2 = e2[n2];\n    \"@\" == n2[0] ? \"i\" == n2[1] ? r = n2 + \" \" + c2 + \";\" : l2 += \"f\" == n2[1] ? o(c2, n2) : n2 + \"{\" + o(c2, \"k\" == n2[1] ? \"\" : t2) + \"}\" : \"object\" == typeof c2 ? l2 += o(c2, t2 ? t2.replace(/([^,])+/g, (e3) => n2.replace(/(^:.*)|([^,])+/g, (t3) => /&/.test(t3) ? t3.replace(/&/g, e3) : e3 ? e3 + \" \" + t3 : t3)) : n2) : null != c2 && (n2 = /^--/.test(n2) ? n2 : n2.replace(/[A-Z]/g, \"-$&\").toLowerCase(), a2 += o.p ? o.p(n2, c2) : n2 + \":\" + c2 + \";\");\n  }\n  return r + (t2 && a2 ? t2 + \"{\" + a2 + \"}\" : a2) + l2;\n}, c = {}, s = (e2) => {\n  if (\"object\" == typeof e2) {\n    let t2 = \"\";\n    for (let r in e2)\n      t2 += r + s(e2[r]);\n    return t2;\n  }\n  return e2;\n}, i = (e2, t2, r, i2, p2) => {\n  let u2 = s(e2), d = c[u2] || (c[u2] = ((e3) => {\n    let t3 = 0, r2 = 11;\n    for (; t3 < e3.length; )\n      r2 = 101 * r2 + e3.charCodeAt(t3++) >>> 0;\n    return \"go\" + r2;\n  })(u2));\n  if (!c[d]) {\n    let t3 = u2 !== e2 ? e2 : ((e3) => {\n      let t4, r2, o2 = [{}];\n      for (; t4 = l.exec(e3.replace(a, \"\")); )\n        t4[4] ? o2.shift() : t4[3] ? (r2 = t4[3].replace(n, \" \").trim(), o2.unshift(o2[0][r2] = o2[0][r2] || {})) : o2[0][t4[1]] = t4[2].replace(n, \" \").trim();\n      return o2[0];\n    })(e2);\n    c[d] = o(p2 ? { [\"@keyframes \" + d]: t3 } : t3, r ? \"\" : \".\" + d);\n  }\n  let f = r && c.g ? c.g : null;\n  return r && (c.g = c[d]), ((e3, t3, r2, l2) => {\n    l2 ? t3.data = t3.data.replace(l2, e3) : -1 === t3.data.indexOf(e3) && (t3.data = r2 ? e3 + t3.data : t3.data + e3);\n  })(c[d], t2, i2, f), d;\n}, p = (e2, t2, r) => e2.reduce((e3, l2, a2) => {\n  let n2 = t2[a2];\n  if (n2 && n2.call) {\n    let e4 = n2(r), t3 = e4 && e4.props && e4.props.className || /^go/.test(e4) && e4;\n    n2 = t3 ? \".\" + t3 : e4 && \"object\" == typeof e4 ? e4.props ? \"\" : o(e4, \"\") : false === e4 ? \"\" : e4;\n  }\n  return e3 + l2 + (null == n2 ? \"\" : n2);\n}, \"\");\nfunction u(e2) {\n  let r = this || {}, l2 = e2.call ? e2(r.p) : e2;\n  return i(l2.unshift ? l2.raw ? p(l2, [].slice.call(arguments, 1), r.p) : l2.reduce((e3, t2) => Object.assign(e3, t2 && t2.call ? t2(r.p) : t2), {}) : l2, t(r.target), r.g, r.o, r.k);\n}\nu.bind({ g: 1 });\nlet h = u.bind({ k: 1 });\nconst ThemeContext = createContext();\nfunction ThemeProvider(props) {\n  return createComponent(ThemeContext.Provider, {\n    value: props.theme,\n    get children() {\n      return props.children;\n    }\n  });\n}\nfunction useTheme() {\n  return useContext(ThemeContext);\n}\nfunction makeStyled(tag) {\n  let _ctx = this || {};\n  return (...args) => {\n    const Styled = (props) => {\n      const theme = useContext(ThemeContext);\n      const withTheme = mergeProps(props, { theme });\n      const clone = mergeProps(withTheme, {\n        get class() {\n          const pClass = withTheme.class, append = \"class\" in withTheme && /^go[0-9]+/.test(pClass);\n          let className2 = u.apply(\n            { target: _ctx.target, o: append, p: withTheme, g: _ctx.g },\n            args\n          );\n          return [pClass, className2].filter(Boolean).join(\" \");\n        }\n      });\n      const [local, newProps] = splitProps(clone, [\"as\", \"theme\"]);\n      const htmlProps = newProps;\n      const createTag = local.as || tag;\n      let el;\n      if (typeof createTag === \"function\") {\n        el = createTag(htmlProps);\n      } else {\n        {\n          if (_ctx.g == 1) {\n            el = document.createElement(createTag);\n            spread(el, htmlProps);\n          } else {\n            el = Dynamic(mergeProps({ component: createTag }, htmlProps));\n          }\n        }\n      }\n      return el;\n    };\n    Styled.class = (props) => {\n      return untrack(() => {\n        return u.apply({ target: _ctx.target, p: props, g: _ctx.g }, args);\n      });\n    };\n    return Styled;\n  };\n}\nconst styled = new Proxy(makeStyled, {\n  get(target, tag) {\n    return target(tag);\n  }\n});\nfunction createGlobalStyles() {\n  const fn = makeStyled.call({ g: 1 }, \"div\").apply(null, arguments);\n  return function GlobalStyles2(props) {\n    fn(props);\n    return null;\n  };\n}\nconst common$1 = {\n  close: \"Close\",\n  openWallet: \"Open wallet\",\n  get: \"GET\",\n  learnMore: \"Learn more\",\n  openExtension: \"Open Extension\",\n  copyLink: \"Copy Link\",\n  copied: \"Copied!\",\n  yourWallet: \"your wallet\"\n};\nconst button$1 = {\n  connectWallet: \"Connect Wallet\",\n  dropdown: {\n    copy: \"Copy address\",\n    copied: \"Address copied!\",\n    disconnect: \"Disconnect\"\n  }\n};\nconst notifications$1 = {\n  confirm: {\n    header: \"Open {{ name }} to\\xA0confirm the\\xA0transaction.\"\n  },\n  transactionSent: {\n    header: \"Transaction sent\",\n    text: \"Your transaction\\xA0will be\\xA0processed in\\xA0a\\xA0few seconds.\"\n  },\n  transactionCanceled: {\n    header: \"Transaction canceled\",\n    text: \"There will be no changes to your account.\"\n  }\n};\nconst walletModal$1 = {\n  loading: \"Loading wallets\",\n  qrCode: \"QR Code\",\n  wallets: \"Wallets\",\n  universalQRModal: {\n    scanQR: \"Scan the\\xA0code below with a camera in your TON wallet.\",\n    openWallet: \"Open Wallet\",\n    openInstalledWallet: \"Open Wallet\",\n    dontHave: \"Explore TON wallets\"\n  },\n  desktopSelectWalletModal: {\n    selectWallet: \"Select a\\xA0wallet to\\xA0connect.\"\n  },\n  mobileSelectWalletModal: {\n    connectWallet: \"Connect a\\xA0Wallet\",\n    selectWallet: \"$walletModal.desktopSelectWalletModal.selectWallet\",\n    installedWallet: \"Installed Wallet\"\n  },\n  qrCodeModal: {\n    connectWith: \"Connect with\\xA0{{ name }}\",\n    scan: \"Scan the\\xA0code below.\",\n    openWallet: \"Open {{ name }}\",\n    openExtension: \"Open Extension\",\n    dontHave: \"Don't have {{ name }}?\"\n  }\n};\nconst actionModal$1 = {\n  confirmTransaction: {\n    header: \"Confirm the\\xA0transaction in\\xA0{{ name }}\",\n    text: \"It will only take a\\xA0moment.\"\n  },\n  transactionSent: \"$notifications.transactionSent\",\n  transactionCanceled: \"$notifications.transactionCanceled\"\n};\nconst en = {\n  common: common$1,\n  button: button$1,\n  notifications: notifications$1,\n  walletModal: walletModal$1,\n  actionModal: actionModal$1\n};\nconst common = {\n  close: \"\\u0417\\u0430\\u043A\\u0440\\u044B\\u0442\\u044C\",\n  openWallet: \"\\u041E\\u0442\\u043A\\u0440\\u044B\\u0442\\u044C \\u043A\\u043E\\u0448\\u0435\\u043B\\u0435\\u043A\",\n  get: \"\\u0421\\u043A\\u0430\\u0447\\u0430\\u0442\\u044C\",\n  learnMore: \"\\u041F\\u043E\\u0434\\u0440\\u043E\\u0431\\u043D\\u0435\\u0435\",\n  openExtension: \"\\u0420\\u0430\\u0441\\u0448\\u0438\\u0440\\u0435\\u043D\\u0438\\u0435\",\n  copyLink: \"\\u041A\\u043E\\u043F\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C \\u0441\\u0441\\u044B\\u043B\\u043A\\u0443\",\n  copied: \"\\u0421\\u043A\\u043E\\u043F\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D\\u043E!\",\n  yourWallet: \"\\u0432\\u0430\\u0448\\u0435\\u043C \\u043A\\u043E\\u0448\\u0435\\u043B\\u044C\\u043A\\u0435\"\n};\nconst button = {\n  connectWallet: \"\\u041F\\u043E\\u0434\\u043A\\u043B\\u044E\\u0447\\u0438\\u0442\\u044C \\u043A\\u043E\\u0448\\u0435\\u043B\\u0451\\u043A\",\n  dropdown: {\n    copy: \"\\u0421\\u043A\\u043E\\u043F\\u0438\\u0440\\u043E\\u0432\\u0430\\u0442\\u044C \\u0430\\u0434\\u0440\\u0435\\u0441\",\n    copied: \"\\u0410\\u0434\\u0440\\u0435\\u0441 \\u0441\\u043A\\u043E\\u043F\\u0438\\u0440\\u043E\\u0432\\u0430\\u043D!\",\n    disconnect: \"\\u041E\\u0442\\u043A\\u043B\\u044E\\u0447\\u0438\\u0442\\u044C \\u043A\\u043E\\u0448\\u0435\\u043B\\u0451\\u043A\"\n  }\n};\nconst notifications = {\n  confirm: {\n    header: \"\\u041E\\u0442\\u043A\\u0440\\u043E\\u0439\\u0442\\u0435 {{ name }}, \\u0447\\u0442\\u043E\\u0431\\u044B \\u043F\\u043E\\u0434\\u0442\\u0432\\u0435\\u0440\\u0434\\u0438\\u0442\\u044C \\u0442\\u0440\\u0430\\u043D\\u0437\\u0430\\u043A\\u0446\\u0438\\u044E.\"\n  },\n  transactionSent: {\n    header: \"\\u0422\\u0440\\u0430\\u043D\\u0437\\u0430\\u043A\\u0446\\u0438\\u044F \\u043E\\u0442\\u043F\\u0440\\u0430\\u0432\\u043B\\u0435\\u043D\\u0430\",\n    text: \"\\u0412\\u0430\\u0448\\u0430 \\u0442\\u0440\\u0430\\u043D\\u0437\\u0430\\u043A\\u0446\\u0438\\u044F\\xA0\\u0431\\u0443\\u0434\\u0435\\u0442 \\u043E\\u0431\\u0440\\u0430\\u0431\\u043E\\u0442\\u0430\\u043D\\u0430 \\u0447\\u0435\\u0440\\u0435\\u0437\\xA0\\u043D\\u0435\\u0441\\u043A\\u043E\\u043B\\u044C\\u043A\\u043E \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434.\"\n  },\n  transactionCanceled: {\n    header: \"\\u0422\\u0440\\u0430\\u043D\\u0437\\u0430\\u043A\\u0446\\u0438\\u044F \\u043E\\u0442\\u043C\\u0435\\u043D\\u0435\\u043D\\u0430\",\n    text: \"\\u0421\\u043E\\u0441\\u0442\\u043E\\u044F\\u043D\\u0438\\u0435 \\u0432\\u0430\\u0448\\u0435\\u0433\\u043E \\u0441\\u0447\\u0451\\u0442\\u0430 \\u043D\\u0435 \\u0438\\u0437\\u043C\\u0435\\u043D\\u0438\\u0442\\u0441\\u044F.\"\n  }\n};\nconst walletModal = {\n  loading: \"\\u0421\\u043F\\u0438\\u0441\\u043E\\u043A \\u043A\\u043E\\u0448\\u0435\\u043B\\u044C\\u043A\\u043E\\u0432 \\u0437\\u0430\\u0433\\u0440\\u0443\\u0436\\u0430\\u0435\\u0442\\u0441\\u044F\",\n  qrCode: \"QR-\\u043A\\u043E\\u0434\",\n  wallets: \"\\u041A\\u043E\\u0448\\u0435\\u043B\\u044C\\u043A\\u0438\",\n  universalQRModal: {\n    scanQR: \"\\u041E\\u0442\\u0441\\u043A\\u0430\\u043D\\u0438\\u0440\\u0443\\u0439\\u0442\\u0435 \\u043A\\u043E\\u0434 \\u043D\\u0438\\u0436\\u0435 \\u0441\\xA0\\u043F\\u043E\\u043C\\u043E\\u0449\\u044C\\u044E \\u043A\\u0430\\u043C\\u0435\\u0440\\u044B \\u0432 \\u0432\\u0430\\u0448\\u0435\\u043C TON-\\u043A\\u043E\\u0448\\u0435\\u043B\\u044C\\u043A\\u0435.\",\n    openWallet: \"\\u041E\\u0442\\u043A\\u0440\\u044B\\u0442\\u044C \\u043A\\u043E\\u0448\\u0435\\u043B\\u0451\\u043A\",\n    openInstalledWallet: \"\\u041E\\u0442\\u043A\\u0440\\u044B\\u0442\\u044C \\u043A\\u043E\\u0448\\u0435\\u043B\\u0451\\u043A\",\n    dontHave: \"\\u041F\\u043E\\u0434\\u0440\\u043E\\u0431\\u043D\\u0435\\u0435 \\u043E\\xA0TON\\xA0\\u043A\\u043E\\u0448\\u0435\\u043B\\u044C\\u043A\\u0430\\u0445\"\n  },\n  desktopSelectWalletModal: {\n    selectWallet: \"\\u0412\\u044B\\u0431\\u0435\\u0440\\u0438\\u0442\\u0435 \\u043A\\u043E\\u0448\\u0435\\u043B\\u0451\\u043A \\u0434\\u043B\\u044F\\xA0\\u043F\\u043E\\u0434\\u043A\\u043B\\u044E\\u0447\\u0435\\u043D\\u0438\\u044F.\"\n  },\n  mobileSelectWalletModal: {\n    connectWallet: \"\\u041F\\u043E\\u0434\\u043A\\u043B\\u044E\\u0447\\u0438\\u0442\\u0435 \\u043A\\u043E\\u0448\\u0435\\u043B\\u0451\\u043A\",\n    selectWallet: \"$walletModal.desktopSelectWalletModal.selectWallet\",\n    installedWallet: \"\\u041E\\u0442\\u043A\\u0440\\u044B\\u0442\\u044C \\u043A\\u043E\\u0448\\u0435\\u043B\\u0451\\u043A\"\n  },\n  qrCodeModal: {\n    connectWith: \"\\u041F\\u043E\\u0434\\u043A\\u043B\\u044E\\u0447\\u0438\\u0442\\u044C\\u0441\\u044F \\u0447\\u0435\\u0440\\u0435\\u0437\\xA0{{ name }}\",\n    scan: \"\\u041E\\u0442\\u0441\\u043A\\u0430\\u043D\\u0438\\u0440\\u0443\\u0439\\u0442\\u0435 \\u043A\\u043E\\u0434 \\u043D\\u0438\\u0436\\u0435.\",\n    openWallet: \"\\u041E\\u0442\\u043A\\u0440\\u044B\\u0442\\u044C {{ name }}\",\n    openExtension: \"\\u0420\\u0430\\u0441\\u0448\\u0438\\u0440\\u0435\\u043D\\u0438\\u0435\",\n    dontHave: \"\\u0423 \\u0432\\u0430\\u0441 \\u043D\\u0435\\u0442 {{ name }}?\"\n  }\n};\nconst actionModal = {\n  confirmTransaction: {\n    header: \"\\u041F\\u043E\\u0434\\u0442\\u0432\\u0435\\u0440\\u0434\\u0438\\u0442\\u0435 \\u0434\\u0435\\u0439\\u0441\\u0442\\u0432\\u0438\\u0435 \\u0432\\xA0{{ name }}\",\n    text: \"\\u042D\\u0442\\u043E \\u0437\\u0430\\u0439\\u043C\\u0435\\u0442 \\u043F\\u0430\\u0440\\u0443 \\u0441\\u0435\\u043A\\u0443\\u043D\\u0434.\"\n  },\n  transactionSent: \"$notifications.transactionSent\",\n  transactionCanceled: \"$notifications.transactionCanceled\"\n};\nconst ru = {\n  common,\n  button,\n  notifications,\n  walletModal,\n  actionModal\n};\nconst i18nDictionary = {\n  en: parseDictionary(en),\n  ru: parseDictionary(ru)\n};\nfunction parseDictionary(dictionary) {\n  const refSymbol = \"$\";\n  const iterate = (subDictionary) => {\n    Object.entries(subDictionary).forEach(([key, value]) => {\n      if (typeof value === \"object\" && value) {\n        return iterate(value);\n      }\n      if (typeof value === \"string\") {\n        if (value[0] === refSymbol) {\n          const path = value.slice(1).split(\".\");\n          let obj = dictionary;\n          path.forEach((item) => {\n            if (item in obj) {\n              obj = obj[item];\n            } else {\n              throw new Error(\n                `Cannot parse translations: there is no property ${item} in translation`\n              );\n            }\n          });\n          subDictionary[key] = obj;\n        }\n        if (value.slice(0, 2) === `\\\\${refSymbol}`) {\n          subDictionary[key] = value.slice(1);\n        }\n      }\n    });\n  };\n  iterate(dictionary);\n  return dictionary;\n}\nconst ConnectorContext = createContext();\nconst $RAW = Symbol(\"store-raw\"), $NODE = Symbol(\"store-node\"), $NAME = Symbol(\"store-name\");\nfunction wrap$1(value, name) {\n  let p2 = value[$PROXY];\n  if (!p2) {\n    Object.defineProperty(value, $PROXY, {\n      value: p2 = new Proxy(value, proxyTraps$1)\n    });\n    if (!Array.isArray(value)) {\n      const keys = Object.keys(value), desc = Object.getOwnPropertyDescriptors(value);\n      for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {\n        const prop = keys[i2];\n        if (desc[prop].get) {\n          Object.defineProperty(value, prop, {\n            enumerable: desc[prop].enumerable,\n            get: desc[prop].get.bind(p2)\n          });\n        }\n      }\n    }\n  }\n  return p2;\n}\nfunction isWrappable(obj) {\n  let proto;\n  return obj != null && typeof obj === \"object\" && (obj[$PROXY] || !(proto = Object.getPrototypeOf(obj)) || proto === Object.prototype || Array.isArray(obj));\n}\nfunction unwrap(item, set = /* @__PURE__ */ new Set()) {\n  let result, unwrapped, v, prop;\n  if (result = item != null && item[$RAW])\n    return result;\n  if (!isWrappable(item) || set.has(item))\n    return item;\n  if (Array.isArray(item)) {\n    if (Object.isFrozen(item))\n      item = item.slice(0);\n    else\n      set.add(item);\n    for (let i2 = 0, l2 = item.length; i2 < l2; i2++) {\n      v = item[i2];\n      if ((unwrapped = unwrap(v, set)) !== v)\n        item[i2] = unwrapped;\n    }\n  } else {\n    if (Object.isFrozen(item))\n      item = Object.assign({}, item);\n    else\n      set.add(item);\n    const keys = Object.keys(item), desc = Object.getOwnPropertyDescriptors(item);\n    for (let i2 = 0, l2 = keys.length; i2 < l2; i2++) {\n      prop = keys[i2];\n      if (desc[prop].get)\n        continue;\n      v = item[prop];\n      if ((unwrapped = unwrap(v, set)) !== v)\n        item[prop] = unwrapped;\n    }\n  }\n  return item;\n}\nfunction getDataNodes(target) {\n  let nodes = target[$NODE];\n  if (!nodes)\n    Object.defineProperty(target, $NODE, {\n      value: nodes = {}\n    });\n  return nodes;\n}\nfunction getDataNode(nodes, property, value) {\n  return nodes[property] || (nodes[property] = createDataNode(value));\n}\nfunction proxyDescriptor$1(target, property) {\n  const desc = Reflect.getOwnPropertyDescriptor(target, property);\n  if (!desc || desc.get || !desc.configurable || property === $PROXY || property === $NODE || property === $NAME)\n    return desc;\n  delete desc.value;\n  delete desc.writable;\n  desc.get = () => target[$PROXY][property];\n  return desc;\n}\nfunction trackSelf(target) {\n  if (getListener()) {\n    const nodes = getDataNodes(target);\n    (nodes._ || (nodes._ = createDataNode()))();\n  }\n}\nfunction ownKeys(target) {\n  trackSelf(target);\n  return Reflect.ownKeys(target);\n}\nfunction createDataNode(value) {\n  const [s2, set] = createSignal(value, {\n    equals: false,\n    internal: true\n  });\n  s2.$ = set;\n  return s2;\n}\nconst proxyTraps$1 = {\n  get(target, property, receiver) {\n    if (property === $RAW)\n      return target;\n    if (property === $PROXY)\n      return receiver;\n    if (property === $TRACK) {\n      trackSelf(target);\n      return receiver;\n    }\n    const nodes = getDataNodes(target);\n    const tracked = nodes.hasOwnProperty(property);\n    let value = tracked ? nodes[property]() : target[property];\n    if (property === $NODE || property === \"__proto__\")\n      return value;\n    if (!tracked) {\n      const desc = Object.getOwnPropertyDescriptor(target, property);\n      if (getListener() && (typeof value !== \"function\" || target.hasOwnProperty(property)) && !(desc && desc.get))\n        value = getDataNode(nodes, property, value)();\n    }\n    return isWrappable(value) ? wrap$1(value) : value;\n  },\n  has(target, property) {\n    if (property === $RAW || property === $PROXY || property === $TRACK || property === $NODE || property === \"__proto__\")\n      return true;\n    this.get(target, property, target);\n    return property in target;\n  },\n  set() {\n    return true;\n  },\n  deleteProperty() {\n    return true;\n  },\n  ownKeys,\n  getOwnPropertyDescriptor: proxyDescriptor$1\n};\nfunction setProperty(state, property, value, deleting = false) {\n  if (!deleting && state[property] === value)\n    return;\n  const prev = state[property], len = state.length;\n  if (value === void 0)\n    delete state[property];\n  else\n    state[property] = value;\n  let nodes = getDataNodes(state), node;\n  if (node = getDataNode(nodes, property, prev))\n    node.$(() => value);\n  if (Array.isArray(state) && state.length !== len)\n    (node = getDataNode(nodes, \"length\", len)) && node.$(state.length);\n  (node = nodes._) && node.$();\n}\nfunction mergeStoreNode(state, value) {\n  const keys = Object.keys(value);\n  for (let i2 = 0; i2 < keys.length; i2 += 1) {\n    const key = keys[i2];\n    setProperty(state, key, value[key]);\n  }\n}\nfunction updateArray(current, next) {\n  if (typeof next === \"function\")\n    next = next(current);\n  next = unwrap(next);\n  if (Array.isArray(next)) {\n    if (current === next)\n      return;\n    let i2 = 0, len = next.length;\n    for (; i2 < len; i2++) {\n      const value = next[i2];\n      if (current[i2] !== value)\n        setProperty(current, i2, value);\n    }\n    setProperty(current, \"length\", len);\n  } else\n    mergeStoreNode(current, next);\n}\nfunction updatePath(current, path, traversed = []) {\n  let part, prev = current;\n  if (path.length > 1) {\n    part = path.shift();\n    const partType = typeof part, isArray = Array.isArray(current);\n    if (Array.isArray(part)) {\n      for (let i2 = 0; i2 < part.length; i2++) {\n        updatePath(current, [part[i2]].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"function\") {\n      for (let i2 = 0; i2 < current.length; i2++) {\n        if (part(current[i2], i2))\n          updatePath(current, [i2].concat(path), traversed);\n      }\n      return;\n    } else if (isArray && partType === \"object\") {\n      const {\n        from = 0,\n        to = current.length - 1,\n        by = 1\n      } = part;\n      for (let i2 = from; i2 <= to; i2 += by) {\n        updatePath(current, [i2].concat(path), traversed);\n      }\n      return;\n    } else if (path.length > 1) {\n      updatePath(current[part], path, [part].concat(traversed));\n      return;\n    }\n    prev = current[part];\n    traversed = [part].concat(traversed);\n  }\n  let value = path[0];\n  if (typeof value === \"function\") {\n    value = value(prev, traversed);\n    if (value === prev)\n      return;\n  }\n  if (part === void 0 && value == void 0)\n    return;\n  value = unwrap(value);\n  if (part === void 0 || isWrappable(prev) && isWrappable(value) && !Array.isArray(value)) {\n    mergeStoreNode(prev, value);\n  } else\n    setProperty(current, part, value);\n}\nfunction createStore(...[store, options]) {\n  const unwrappedStore = unwrap(store || {});\n  const isArray = Array.isArray(unwrappedStore);\n  const wrappedStore = wrap$1(unwrappedStore);\n  function setStore(...args) {\n    batch(() => {\n      isArray && args.length === 1 ? updateArray(unwrappedStore, args[0]) : updatePath(unwrappedStore, args);\n    });\n  }\n  return [wrappedStore, setStore];\n}\nvar THEME = /* @__PURE__ */ ((THEME2) => {\n  THEME2[\"DARK\"] = \"DARK\";\n  THEME2[\"LIGHT\"] = \"LIGHT\";\n  return THEME2;\n})(THEME || {});\nconst defaultLightColorsSet = {\n  constant: {\n    black: \"#000000\",\n    white: \"#FFFFFF\"\n  },\n  connectButton: {\n    background: \"#31A6F5\",\n    foreground: \"#FFFFFF\"\n  },\n  accent: \"#31A6F5\",\n  icon: {\n    primary: \"#0F0F0F\",\n    secondary: \"#7A8999\",\n    tertiary: \"#C1CAD2\",\n    success: \"#29CC6A\",\n    error: \"#F5A73B\"\n  },\n  background: {\n    primary: \"#FFFFFF\",\n    secondary: \"#F1F3F5\",\n    segment: \"#FFFFFF\"\n  },\n  text: {\n    primary: \"#0F0F0F\",\n    secondary: \"#6A7785\"\n  }\n};\nconst defaultDarkColorsSet = {\n  constant: {\n    black: \"#000000\",\n    white: \"#FFFFFF\"\n  },\n  connectButton: {\n    background: \"#31A6F5\",\n    foreground: \"#FFFFFF\"\n  },\n  accent: \"#E5E5EA\",\n  icon: {\n    primary: \"#E5E5EA\",\n    secondary: \"#909099\",\n    tertiary: \"#434347\",\n    success: \"#29CC6A\",\n    error: \"#F5A73B\"\n  },\n  background: {\n    primary: \"#121214\",\n    secondary: \"#18181A\",\n    segment: \"#262629\"\n  },\n  text: {\n    primary: \"#E5E5EA\",\n    secondary: \"#7D7D85\"\n  }\n};\n/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\nfunction isObject(o2) {\n  return Object.prototype.toString.call(o2) === \"[object Object]\";\n}\nfunction isPlainObject(o2) {\n  var ctor, prot;\n  if (isObject(o2) === false)\n    return false;\n  ctor = o2.constructor;\n  if (ctor === void 0)\n    return true;\n  prot = ctor.prototype;\n  if (isObject(prot) === false)\n    return false;\n  if (prot.hasOwnProperty(\"isPrototypeOf\") === false) {\n    return false;\n  }\n  return true;\n}\nfunction mergeOptions(options, defaultOptions) {\n  if (!options) {\n    return defaultOptions;\n  }\n  const overwriteMerge = (_, sourceArray, __) => sourceArray;\n  return deepmerge__WEBPACK_IMPORTED_MODULE_1___default()(defaultOptions, options, {\n    arrayMerge: overwriteMerge,\n    isMergeableObject: isPlainObject\n  });\n}\nconst [themeState, setThemeState] = createStore({\n  theme: THEME.LIGHT,\n  colors: defaultLightColorsSet,\n  borderRadius: \"m\"\n});\nconst themeColorsMappingDefault = {\n  [THEME.LIGHT]: defaultLightColorsSet,\n  [THEME.DARK]: defaultDarkColorsSet\n};\nconst themeCustomColors = {\n  [THEME.LIGHT]: void 0,\n  [THEME.DARK]: void 0\n};\nfunction setTheme(theme, colorsSet) {\n  if (colorsSet) {\n    themeCustomColors[THEME.DARK] = mergeOptions(\n      colorsSet[THEME.DARK],\n      themeCustomColors[THEME.DARK]\n    );\n    themeCustomColors[THEME.LIGHT] = mergeOptions(\n      colorsSet[THEME.LIGHT],\n      themeCustomColors[THEME.LIGHT]\n    );\n  }\n  setThemeState({\n    theme,\n    colors: mergeOptions(themeCustomColors[theme], themeColorsMappingDefault[theme])\n  });\n}\nfunction setBorderRadius(borderRadius) {\n  setThemeState({ borderRadius });\n}\nfunction setColors(colorsSet) {\n  themeCustomColors[THEME.DARK] = mergeOptions(\n    colorsSet[THEME.DARK],\n    themeCustomColors[THEME.DARK]\n  );\n  themeCustomColors[THEME.LIGHT] = mergeOptions(\n    colorsSet[THEME.LIGHT],\n    themeCustomColors[THEME.LIGHT]\n  );\n  setThemeState((state) => ({\n    colors: mergeOptions(\n      themeCustomColors[state.theme],\n      themeColorsMappingDefault[state.theme]\n    )\n  }));\n}\nconst globalStylesTag = \"tc-root\";\nconst disableScrollClass = \"tc-disable-scroll\";\nconst usingMouseClass = \"tc-using-mouse\";\nconst GlobalStyles = () => {\n  document.body.addEventListener(\"mousedown\", () => document.body.classList.add(usingMouseClass));\n  document.body.addEventListener(\"keydown\", (event) => {\n    if (event.key === \"Tab\") {\n      document.body.classList.remove(usingMouseClass);\n    }\n  });\n  const Styles = createGlobalStyles`\n    ${globalStylesTag} * {\n        margin: 0;\n        padding: 0;\n        box-sizing: border-box;\n        \n        font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', Arial, Tahoma, Verdana, sans-serif;\n        -webkit-font-smoothing: antialiased;\n        -moz-osx-font-smoothing: grayscale;        \n        -webkit-tap-highlight-color: transparent;\n    }\n    \n    ${globalStylesTag} img {\n      -webkit-user-select: none;\n      -webkit-touch-callout: none;\n    }   \n \n    ${globalStylesTag} *:focus {\n        outline: #08f auto 2px;\n    }\n    \n    ${globalStylesTag} li {\n        list-style: none;\n    }\n    \n    ${globalStylesTag} button {\n        outline: none;\n    }\n    \n    body.${disableScrollClass} {\n        position: fixed; \n        overflow-y: scroll;\n        right: 0;\n        left: 0;\n    }\n    \n    body.${usingMouseClass} ${globalStylesTag} *:focus {\n        outline: none;\n    }\n`;\n  return createComponent(Styles, {});\n};\nconst ImagePlaceholder = styled.div`\n    background-color: ${(props) => props.theme.colors.background.secondary};\n`;\nconst Image = (props) => {\n  let imgRef;\n  const [image, setImage] = createSignal(null);\n  createEffect(() => {\n    const img = new window.Image();\n    img.src = props.src;\n    img.alt = props.alt || \"\";\n    img.setAttribute(\"draggable\", \"false\");\n    if (props.class) {\n      img.classList.add(props.class);\n    }\n    if (img.complete) {\n      return setImage(img);\n    }\n    img.addEventListener(\"load\", () => setImage(img));\n    return () => img.removeEventListener(\"load\", () => setImage(img));\n  });\n  return [createComponent(Show, {\n    get when() {\n      return image();\n    },\n    get children() {\n      return image();\n    }\n  }), createComponent(Show, {\n    get when() {\n      return !image();\n    },\n    get children() {\n      return createComponent(ImagePlaceholder, {\n        get [\"class\"]() {\n          return props.class;\n        },\n        ref(r$) {\n          const _ref$ = imgRef;\n          typeof _ref$ === \"function\" ? _ref$(r$) : imgRef = r$;\n        }\n      });\n    }\n  })];\n};\nfunction hexToRgb(hex) {\n  if (hex[0] === \"#\") {\n    hex = hex.slice(1);\n  }\n  const bigint = parseInt(hex, 16);\n  const r = bigint >> 16 & 255;\n  const g = bigint >> 8 & 255;\n  const b = bigint & 255;\n  return [r, g, b].join(\",\");\n}\nfunction rgba(color, opacity) {\n  if (color[0] === \"#\") {\n    color = hexToRgb(color);\n  }\n  return `rgba(${color}, ${opacity})`;\n}\nfunction toPx(value) {\n  return value.toString() + \"px\";\n}\nclass TonConnectUIError extends _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError {\n  constructor(...args) {\n    super(...args);\n    Object.setPrototypeOf(this, TonConnectUIError.prototype);\n  }\n}\nfunction openLink(href, target = \"_self\") {\n  return window.open(href, target, \"noreferrer noopener\");\n}\nfunction openLinkBlank(href) {\n  openLink(href, \"_blank\");\n}\nfunction getSystemTheme() {\n  if (window.matchMedia && window.matchMedia(\"(prefers-color-scheme: light)\").matches) {\n    return THEME.LIGHT;\n  }\n  return THEME.DARK;\n}\nfunction subscribeToThemeChange(callback) {\n  const handler = (event) => callback(event.matches ? THEME.DARK : THEME.LIGHT);\n  window.matchMedia(\"(prefers-color-scheme: dark)\").addEventListener(\"change\", handler);\n  return () => window.matchMedia(\"(prefers-color-scheme: dark)\").removeEventListener(\"change\", handler);\n}\nfunction addQueryParameter(url, key, value) {\n  const parsed = new URL(url);\n  parsed.searchParams.append(key, value);\n  return parsed.toString();\n}\nfunction addReturnStrategy(url, returnStrategy) {\n  return addQueryParameter(url, \"ret\", returnStrategy);\n}\nfunction disableScroll() {\n  if (document.documentElement.scrollHeight === document.documentElement.clientHeight) {\n    return;\n  }\n  document.body.style.top = toPx(-document.documentElement.scrollTop);\n  document.body.classList.add(disableScrollClass);\n}\nfunction enableScroll() {\n  document.body.classList.remove(disableScrollClass);\n  document.documentElement.scrollTo({ top: -parseFloat(getComputedStyle(document.body).top) });\n  document.body.style.top = \"auto\";\n}\nfunction fixMobileSafariActiveTransition() {\n  if (!document.body.hasAttribute(\"ontouchstart\")) {\n    document.body.setAttribute(\"ontouchstart\", \"\");\n  }\n}\nfunction defineStylesRoot() {\n  customElements.define(globalStylesTag, class TcRootElement extends HTMLDivElement {\n  }, {\n    extends: \"div\"\n  });\n}\nfunction preloadImages(images) {\n  images.forEach((img) => {\n    const node = new window.Image();\n    node.src = img;\n  });\n}\nfunction checkLocalStorageExists() {\n  if (typeof localStorage === \"undefined\") {\n    throw new TonConnectUIError(\n      \"window.localStorage is undefined. localStorage is required for TonConnectUI\"\n    );\n  }\n}\nfunction getWindow$1() {\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  return void 0;\n}\nfunction isMobileUserAgent() {\n  let check = false;\n  (function(a2) {\n    if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(\n      a2\n    ) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(\n      a2.slice(0, 4)\n    ))\n      check = true;\n  })(navigator.userAgent || navigator.vendor || window.opera);\n  return check;\n}\nfunction getUserAgent() {\n  var _a, _b;\n  const results = new (ua_parser_js__WEBPACK_IMPORTED_MODULE_2___default())().getResult();\n  const osName = (_a = results.os.name) == null ? void 0 : _a.toLowerCase();\n  let os;\n  switch (true) {\n    case osName === \"ios\":\n      os = \"ios\";\n      break;\n    case osName === \"android\":\n      os = \"android\";\n      break;\n    case osName === \"mac os\":\n      os = \"macos\";\n      break;\n    case osName === \"linux\":\n      os = \"linux\";\n      break;\n    case (osName == null ? void 0 : osName.includes(\"windows\")):\n      os = \"windows\";\n      break;\n  }\n  const browserName = (_b = results.browser.name) == null ? void 0 : _b.toLowerCase();\n  let browser;\n  switch (true) {\n    case browserName === \"chrome\":\n      browser = \"chrome\";\n      break;\n    case browserName === \"firefox\":\n      browser = \"firefox\";\n      break;\n    case (browserName == null ? void 0 : browserName.includes(\"safari\")):\n      browser = \"safari\";\n      break;\n  }\n  return {\n    os,\n    browser\n  };\n}\nconst maxWidth = {\n  mobile: 440,\n  tablet: 1020\n};\nfunction isDevice(device) {\n  const window2 = getWindow$1();\n  if (!window2) {\n    return device === \"desktop\";\n  }\n  const width = window2.innerWidth;\n  switch (device) {\n    case \"desktop\":\n      return width > maxWidth.tablet;\n    case \"tablet\":\n      return width > maxWidth.mobile;\n    default:\n    case \"mobile\":\n      return width <= maxWidth.mobile;\n  }\n}\nfunction media(device) {\n  switch (device) {\n    case \"mobile\":\n      return `@media (max-width: ${maxWidth.mobile}px)`;\n    case \"tablet\":\n      return `@media (max-width: ${maxWidth.tablet}px) (min-width: ${maxWidth.mobile}px)`;\n    default:\n    case \"desktop\":\n      return `@media (min-width: ${maxWidth.tablet}px)`;\n  }\n}\nconst mediaTouch = \"@media (hover: none)\";\nconst mediaNotTouch = \"@media not all and (hover: none)\";\nconst borders$5 = {\n  m: \"100vh\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst scaleValues = {\n  s: 0.02,\n  m: 0.04\n};\nconst ButtonStyled$3 = styled.button`\n    background-color: ${(props) => props.appearance === \"flat\" ? \"transparent\" : rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.theme.colors.accent};\n\n    padding: ${(props) => props.appearance === \"flat\" ? \"0\" : \"9px 16px\"};\n    border: none;\n    border-radius: ${(props) => borders$5[props.theme.borderRadius]};\n    cursor: ${(props) => props.disabled ? \"not-allowed\" : \"pointer\"};\n\n    font-size: 14px;\n    font-weight: 590;\n    line-height: 18px;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 + scaleValues[props.scale]})`};\n        }\n    }\n\n    &:active {\n        transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 - scaleValues[props.scale]})`};\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: ${(props) => props.disabled ? \"unset\" : `scale(${1 - scaleValues[props.scale] * 2})`};\n        }\n    }\n`;\nfunction useDataAttributes(props) {\n  const keys = untrack(() => Object.keys(props).filter((key) => key.startsWith(\"data-\")));\n  const [dataAttrs] = splitProps(props, keys);\n  return dataAttrs;\n}\nconst Button = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  return createComponent(ButtonStyled$3, mergeProps({\n    get appearance() {\n      return props.appearance || \"primary\";\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: (e2) => {\n      var _a;\n      return (_a = props.onClick) == null ? void 0 : _a.call(props, e2);\n    },\n    onMouseEnter: (e2) => {\n      var _a;\n      return (_a = props.onMouseEnter) == null ? void 0 : _a.call(props, e2);\n    },\n    onMouseLeave: (e2) => {\n      var _a;\n      return (_a = props.onMouseLeave) == null ? void 0 : _a.call(props, e2);\n    },\n    ref(r$) {\n      const _ref$ = props.ref;\n      typeof _ref$ === \"function\" ? _ref$(r$) : props.ref = r$;\n    },\n    get disabled() {\n      return props.disabled;\n    },\n    get scale() {\n      return props.scale || \"m\";\n    },\n    \"data-tc-button\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return props.children;\n    }\n  }));\n};\nfunction nextFrame(fn) {\n  requestAnimationFrame(() => {\n    requestAnimationFrame(fn);\n  });\n}\nconst Transition = (props) => {\n  let el;\n  let first = true;\n  const [s1, set1] = createSignal();\n  const [s2, set2] = createSignal();\n  const resolved = children(() => props.children);\n  const {\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onBeforeExit,\n    onExit,\n    onAfterExit\n  } = props;\n  const classnames = createMemo(() => {\n    const name = props.name || \"s\";\n    return {\n      enterActiveClass: props.enterActiveClass || name + \"-enter-active\",\n      enterClass: props.enterClass || name + \"-enter\",\n      enterToClass: props.enterToClass || name + \"-enter-to\",\n      exitActiveClass: props.exitActiveClass || name + \"-exit-active\",\n      exitClass: props.exitClass || name + \"-exit\",\n      exitToClass: props.exitToClass || name + \"-exit-to\"\n    };\n  });\n  function enterTransition(el2, prev) {\n    if (!first || props.appear) {\n      let endTransition = function(e2) {\n        if (el2 && (!e2 || e2.target === el2)) {\n          el2.removeEventListener(\"transitionend\", endTransition);\n          el2.removeEventListener(\"animationend\", endTransition);\n          el2.classList.remove(...enterActiveClasses);\n          el2.classList.remove(...enterToClasses);\n          batch(() => {\n            s1() !== el2 && set1(el2);\n            s2() === el2 && set2(void 0);\n          });\n          onAfterEnter && onAfterEnter(el2);\n          if (props.mode === \"inout\")\n            exitTransition(el2, prev);\n        }\n      };\n      const enterClasses = classnames().enterClass.split(\" \");\n      const enterActiveClasses = classnames().enterActiveClass.split(\" \");\n      const enterToClasses = classnames().enterToClass.split(\" \");\n      onBeforeEnter && onBeforeEnter(el2);\n      el2.classList.add(...enterClasses);\n      el2.classList.add(...enterActiveClasses);\n      nextFrame(() => {\n        el2.classList.remove(...enterClasses);\n        el2.classList.add(...enterToClasses);\n        onEnter && onEnter(el2, () => endTransition());\n        if (!onEnter || onEnter.length < 2) {\n          el2.addEventListener(\"transitionend\", endTransition);\n          el2.addEventListener(\"animationend\", endTransition);\n        }\n      });\n    }\n    prev && !props.mode ? set2(el2) : set1(el2);\n  }\n  function exitTransition(el2, prev) {\n    const exitClasses = classnames().exitClass.split(\" \");\n    const exitActiveClasses = classnames().exitActiveClass.split(\" \");\n    const exitToClasses = classnames().exitToClass.split(\" \");\n    if (!prev.parentNode)\n      return endTransition();\n    onBeforeExit && onBeforeExit(prev);\n    prev.classList.add(...exitClasses);\n    prev.classList.add(...exitActiveClasses);\n    nextFrame(() => {\n      prev.classList.remove(...exitClasses);\n      prev.classList.add(...exitToClasses);\n    });\n    onExit && onExit(prev, () => endTransition());\n    if (!onExit || onExit.length < 2) {\n      prev.addEventListener(\"transitionend\", endTransition);\n      prev.addEventListener(\"animationend\", endTransition);\n    }\n    function endTransition(e2) {\n      if (!e2 || e2.target === prev) {\n        prev.removeEventListener(\"transitionend\", endTransition);\n        prev.removeEventListener(\"animationend\", endTransition);\n        prev.classList.remove(...exitActiveClasses);\n        prev.classList.remove(...exitToClasses);\n        s1() === prev && set1(void 0);\n        onAfterExit && onAfterExit(prev);\n        if (props.mode === \"outin\")\n          enterTransition(el2, prev);\n      }\n    }\n  }\n  createComputed((prev) => {\n    el = resolved();\n    while (typeof el === \"function\")\n      el = el();\n    return untrack(() => {\n      if (el && el !== prev) {\n        if (props.mode !== \"outin\")\n          enterTransition(el, prev);\n        else if (first)\n          set1(el);\n      }\n      if (prev && prev !== el && props.mode !== \"inout\")\n        exitTransition(el, prev);\n      first = false;\n      return el;\n    });\n  });\n  return [s1, s2];\n};\nfunction getRect(element) {\n  const {\n    top,\n    bottom,\n    left,\n    right,\n    width,\n    height\n  } = element.getBoundingClientRect();\n  const parentRect = element.parentNode.getBoundingClientRect();\n  return {\n    top: top - parentRect.top,\n    bottom,\n    left: left - parentRect.left,\n    right,\n    width,\n    height\n  };\n}\nconst TransitionGroup = (props) => {\n  const resolved = children(() => props.children);\n  const classnames = createMemo(() => {\n    const name = props.name || \"s\";\n    return {\n      enterActiveClass: props.enterActiveClass || name + \"-enter-active\",\n      enterClass: props.enterClass || name + \"-enter\",\n      enterToClass: props.enterToClass || name + \"-enter-to\",\n      exitActiveClass: props.exitActiveClass || name + \"-exit-active\",\n      exitClass: props.exitClass || name + \"-exit\",\n      exitToClass: props.exitToClass || name + \"-exit-to\",\n      moveClass: props.moveClass || name + \"-move\"\n    };\n  });\n  const {\n    onBeforeEnter,\n    onEnter,\n    onAfterEnter,\n    onBeforeExit,\n    onExit,\n    onAfterExit\n  } = props;\n  const [combined, setCombined] = createSignal();\n  let p2 = [];\n  let first = true;\n  createComputed(() => {\n    const c2 = resolved();\n    const comb = [...c2];\n    const next = new Set(c2);\n    const prev = new Set(p2);\n    const enterClasses = classnames().enterClass.split(\" \");\n    const enterActiveClasses = classnames().enterActiveClass.split(\" \");\n    const enterToClasses = classnames().enterToClass.split(\" \");\n    const exitClasses = classnames().exitClass.split(\" \");\n    const exitActiveClasses = classnames().exitActiveClass.split(\" \");\n    const exitToClasses = classnames().exitToClass.split(\" \");\n    for (let i2 = 0; i2 < c2.length; i2++) {\n      const el = c2[i2];\n      if (!first && !prev.has(el)) {\n        let endTransition = function(e2) {\n          if (el && (!e2 || e2.target === el)) {\n            el.removeEventListener(\"transitionend\", endTransition);\n            el.removeEventListener(\"animationend\", endTransition);\n            el.classList.remove(...enterActiveClasses);\n            el.classList.remove(...enterToClasses);\n            onAfterEnter && onAfterEnter(el);\n          }\n        };\n        onBeforeEnter && onBeforeEnter(el);\n        el.classList.add(...enterClasses);\n        el.classList.add(...enterActiveClasses);\n        nextFrame(() => {\n          el.classList.remove(...enterClasses);\n          el.classList.add(...enterToClasses);\n          onEnter && onEnter(el, () => endTransition());\n          if (!onEnter || onEnter.length < 2) {\n            el.addEventListener(\"transitionend\", endTransition);\n            el.addEventListener(\"animationend\", endTransition);\n          }\n        });\n      }\n    }\n    for (let i2 = 0; i2 < p2.length; i2++) {\n      const old = p2[i2];\n      if (!next.has(old) && old.parentNode) {\n        let endTransition = function(e2) {\n          if (!e2 || e2.target === old) {\n            old.removeEventListener(\"transitionend\", endTransition);\n            old.removeEventListener(\"animationend\", endTransition);\n            old.classList.remove(...exitActiveClasses);\n            old.classList.remove(...exitToClasses);\n            onAfterExit && onAfterExit(old);\n            p2 = p2.filter((i3) => i3 !== old);\n            setCombined(p2);\n          }\n        };\n        comb.splice(i2, 0, old);\n        onBeforeExit && onBeforeExit(old);\n        old.classList.add(...exitClasses);\n        old.classList.add(...exitActiveClasses);\n        nextFrame(() => {\n          old.classList.remove(...exitClasses);\n          old.classList.add(...exitToClasses);\n        });\n        onExit && onExit(old, () => endTransition());\n        if (!onExit || onExit.length < 2) {\n          old.addEventListener(\"transitionend\", endTransition);\n          old.addEventListener(\"animationend\", endTransition);\n        }\n      }\n    }\n    p2 = comb;\n    setCombined(comb);\n  });\n  createEffect((nodes) => {\n    const c2 = combined();\n    c2.forEach((child) => {\n      let n2;\n      if (!(n2 = nodes.get(child))) {\n        nodes.set(child, n2 = {\n          pos: getRect(child),\n          new: !first\n        });\n      } else if (n2.new) {\n        n2.new = false;\n        n2.newPos = getRect(child);\n      }\n      if (n2.new) {\n        child.addEventListener(\"transitionend\", () => {\n          n2.new = false;\n          child.parentNode && (n2.newPos = getRect(child));\n        }, {\n          once: true\n        });\n      }\n      n2.newPos && (n2.pos = n2.newPos);\n      n2.newPos = getRect(child);\n    });\n    if (first) {\n      first = false;\n      return nodes;\n    }\n    c2.forEach((child) => {\n      const c3 = nodes.get(child);\n      const oldPos = c3.pos;\n      const newPos = c3.newPos;\n      const dx = oldPos.left - newPos.left;\n      const dy = oldPos.top - newPos.top;\n      if (dx || dy) {\n        c3.moved = true;\n        const s2 = child.style;\n        s2.transform = `translate(${dx}px,${dy}px)`;\n        s2.transitionDuration = \"0s\";\n      }\n    });\n    document.body.offsetHeight;\n    c2.forEach((child) => {\n      const c3 = nodes.get(child);\n      if (c3.moved) {\n        let endTransition = function(e2) {\n          if (e2 && e2.target !== child || !child.parentNode)\n            return;\n          if (!e2 || /transform$/.test(e2.propertyName)) {\n            child.removeEventListener(\"transitionend\", endTransition);\n            child.classList.remove(...moveClasses);\n          }\n        };\n        c3.moved = false;\n        const s2 = child.style;\n        const moveClasses = classnames().moveClass.split(\" \");\n        child.classList.add(...moveClasses);\n        s2.transform = s2.transitionDuration = \"\";\n        child.addEventListener(\"transitionend\", endTransition);\n      }\n    });\n    return nodes;\n  }, /* @__PURE__ */ new Map());\n  return combined;\n};\nfunction clickOutside$1(el, accessor) {\n  const onClick = (e2) => {\n    var _a;\n    return !el.contains(e2.target) && ((_a = accessor()) == null ? void 0 : _a());\n  };\n  document.body.addEventListener(\"click\", onClick);\n  onCleanup(() => document.body.removeEventListener(\"click\", onClick));\n}\nfunction escPressed(_, accessor) {\n  const onKeyPress = (e2) => {\n    var _a, _b;\n    if (e2.key === \"Escape\") {\n      (_a = document.activeElement) == null ? void 0 : _a.blur();\n      (_b = accessor()) == null ? void 0 : _b();\n    }\n  };\n  document.body.addEventListener(\"keydown\", onKeyPress);\n  onCleanup(() => document.body.removeEventListener(\"keydown\", onKeyPress));\n}\nconst _tmpl$$g = /* @__PURE__ */ template$1(`<svg><path d=\"M9.1 3.40012L5.5 8.0001L9.1 12.6001\" stroke-width=\"1.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>`, 4, true);\nconst rotationDegrees = {\n  left: 0,\n  top: 90,\n  right: 180,\n  bottom: 270\n};\nconst ArrowIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  const direction = () => props.direction || \"left\";\n  const Svg = styled(\"svg\")`\n        transform: rotate(${(props2) => rotationDegrees[props2.svgDirection]}deg);\n        transition: transform 0.1s ease-in-out;\n    `;\n  return createComponent(Svg, {\n    width: \"16\",\n    height: \"16\",\n    viewBox: \"0 0 16 16\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    get svgDirection() {\n      return direction();\n    },\n    get children() {\n      const _el$ = _tmpl$$g.cloneNode(true);\n      createRenderEffect(() => setAttribute(_el$, \"stroke\", fill()));\n      return _el$;\n    }\n  });\n};\nconst _tmpl$$f = /* @__PURE__ */ template$1(`<svg width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3.90003 3.89991L8.00002 7.9999M8.00002 7.9999L12.1 12.0999M8.00002 7.9999L12.1 3.8999M8.00002 7.9999L3.90002 12.0999\" stroke-width=\"1.8\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>`);\nconst CloseIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    const _el$ = _tmpl$$f.cloneNode(true), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"stroke\", fill()));\n    return _el$;\n  })();\n};\nconst IconButtonStyled = styled.button`\n    padding: 0;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    width: 32px;\n    height: 32px;\n    border-radius: 50%;\n    background-color: ${(props) => props.theme.colors.background.secondary};\n    border: none;\n    cursor: pointer;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst IconButton = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  const icon = () => props.icon || \"close\";\n  return createComponent(IconButtonStyled, mergeProps({\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: () => props.onClick(),\n    \"data-tc-icon-button\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return !!props.children;\n        },\n        get children() {\n          return props.children;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !props.children;\n        },\n        get children() {\n          return createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return icon() === \"close\";\n                },\n                get children() {\n                  return createComponent(CloseIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return icon() === \"arrow\";\n                },\n                get children() {\n                  return createComponent(ArrowIcon, {\n                    get fill() {\n                      return props.fill;\n                    }\n                  });\n                }\n              })];\n            }\n          });\n        }\n      })];\n    }\n  }));\n};\nconst ModalBackgroundStyled = styled.div`\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    position: fixed;\n    z-index: 1000;\n    left: 0;\n    top: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.4);\n\n    ${media(\"mobile\")} {\n        align-items: flex-end;\n    }\n\n    @media (min-width: ${maxWidth.mobile.toString()}px) and (max-height: 600px) {\n        padding: 48px 0;\n        align-items: flex-start;\n        overflow: scroll;\n    }\n`;\nconst ModalWrapperClass = u`\n    position: relative;\n    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08), 0 16px 64px rgba(0, 0, 0, 0.16);\n    min-height: 100px;\n    width: 440px;\n    padding: 44px 56px 24px;\n\n    ${media(\"mobile\")} {\n        width: 100%;\n    }\n`;\nconst CloseButtonStyled = styled(IconButton)`\n    position: absolute;\n    right: 16px;\n    top: 16px;\n`;\nconst _tmpl$$e = /* @__PURE__ */ template$1(`<div></div>`);\nconst clickOutside = clickOutside$1;\nconst keyPressed = escPressed;\nconst borders$4 = {\n  m: \"24px\",\n  s: \"16px\",\n  none: \"0\"\n};\nconst Modal = (props) => {\n  const theme = useTheme();\n  const dataAttrs = useDataAttributes(props);\n  createEffect(() => {\n    if (props.opened) {\n      disableScroll();\n    } else {\n      enableScroll();\n    }\n  });\n  return createComponent(Transition, {\n    onBeforeEnter: (el) => {\n      const duration = isDevice(\"mobile\") ? 200 : 100;\n      el.animate([{\n        opacity: 0\n      }, {\n        opacity: 1\n      }], {\n        duration\n      });\n      if (isDevice(\"mobile\")) {\n        el.firstElementChild.animate([{\n          transform: \"translateY(390px)\"\n        }, {\n          transform: \"translateY(0)\"\n        }], {\n          duration\n        });\n      }\n    },\n    onExit: (el, done) => {\n      const duration = isDevice(\"mobile\") ? 200 : 100;\n      const backgroundAnimation = el.animate([{\n        opacity: 1\n      }, {\n        opacity: 0\n      }], {\n        duration\n      });\n      if (isDevice(\"mobile\")) {\n        const contentAnimation = el.firstElementChild.animate([{\n          transform: \"translateY(0)\"\n        }, {\n          transform: \"translateY(390px)\"\n        }], {\n          duration\n        });\n        Promise.all([backgroundAnimation.finished, contentAnimation.finished]).then(done);\n      } else {\n        backgroundAnimation.finished.then(done);\n      }\n    },\n    get children() {\n      return createComponent(Show, {\n        get when() {\n          return props.opened;\n        },\n        get children() {\n          return createComponent(ModalBackgroundStyled, mergeProps({\n            \"data-tc-modal\": \"true\"\n          }, dataAttrs, {\n            get children() {\n              const _el$ = _tmpl$$e.cloneNode(true);\n              use(keyPressed, _el$, () => () => props.onClose());\n              use(clickOutside, _el$, () => () => props.onClose());\n              insert(_el$, createComponent(CloseButtonStyled, {\n                icon: \"close\",\n                onClick: () => props.onClose()\n              }), null);\n              insert(_el$, () => props.children, null);\n              createRenderEffect(() => className(_el$, classnames__WEBPACK_IMPORTED_MODULE_3___default()(ModalWrapperClass, props.class, u`\n                                background-color: ${theme.colors.background.primary};\n                                border-radius: ${borders$4[theme.borderRadius]};\n\n                                ${media(\"mobile\")} {\n                                    border-radius: ${borders$4[theme.borderRadius]}\n                                        ${borders$4[theme.borderRadius]} 0 0;\n                                }\n                            `)));\n              return _el$;\n            }\n          }));\n        }\n      });\n    }\n  });\n};\nconst wrapperBorderRadius = {\n  m: \"22px\",\n  s: \"12px\",\n  none: \"0\"\n};\nconst sliderBorderRadius = {\n  m: \"18px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst TabBarStyled$1 = styled.div`\n    display: grid;\n    grid-template: 1fr / 1fr 1fr;\n    width: fit-content;\n    justify-items: center;\n    gap: 4px;\n\n    position: relative;\n    padding: 4px;\n    border-radius: ${(props) => wrapperBorderRadius[props.theme.borderRadius]};\n\n    background-color: ${(props) => props.theme.colors.background.secondary};\n`;\nconst SliderStyled = styled.div`\n    position: absolute;\n    top: 4px;\n    left: 4px;\n\n    height: calc(100% - 8px);\n    width: calc(50% - 4px);\n\n    border-radius: ${(props) => sliderBorderRadius[props.theme.borderRadius]};\n    background-color: ${(props) => props.theme.colors.background.segment};\n\n    transform: ${(props) => props.right ? \"translateX(100%)\" : \"translateX(0)\"};\n\n    transition: transform 0.13s ease-in-out;\n`;\nconst InputStyled = styled.input`\n    display: none;\n`;\nconst LabelStyled = styled.label`\n    padding: 9px 12px;\n    z-index: 1;\n\n    cursor: ${(props) => props.isActive ? \"default\" : \"pointer\"};\n\n    transition: transform 0.13s ease-in-out;\n\n    &:hover {\n        transform: ${(props) => props.isActive ? \"none\" : \"scale(1.025)\"};\n    }\n\n    > * {\n        ${(props) => !props.isActive ? `color: ${props.theme.colors.text.secondary};` : \"\"}\n    }\n`;\nconst TabBar = (props) => {\n  const groupName = \"tabBar\" + Math.floor(Math.random() * 1e4);\n  return createComponent(TabBarStyled$1, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-tab-bar\": \"true\",\n    get children() {\n      return [createComponent(SliderStyled, {\n        get right() {\n          return props.selectedTabIndex === 1;\n        }\n      }), createComponent(LabelStyled, {\n        get isActive() {\n          return props.selectedTabIndex === 0;\n        },\n        get children() {\n          return [createComponent(InputStyled, {\n            type: \"radio\",\n            name: groupName,\n            get checked() {\n              return props.selectedTabIndex === 0;\n            },\n            onInput: () => {\n              var _a;\n              return (_a = props.onSelectedTabIndexChange) == null ? void 0 : _a.call(props, 0);\n            }\n          }), createMemo(() => props.tab1)];\n        }\n      }), createComponent(LabelStyled, {\n        get isActive() {\n          return props.selectedTabIndex === 1;\n        },\n        get children() {\n          return [createComponent(InputStyled, {\n            type: \"radio\",\n            get checked() {\n              return props.selectedTabIndex === 1;\n            },\n            name: groupName,\n            onInput: () => {\n              var _a;\n              return (_a = props.onSelectedTabIndexChange) == null ? void 0 : _a.call(props, 1);\n            }\n          }), createMemo(() => props.tab2)];\n        }\n      })];\n    }\n  });\n};\nconst borders$3 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst qrNormalSize = 256;\nconst imgSizeDefault = 60;\nconst picSizeDefault = 48;\nconst qrPaddingTop = 24;\nconst QrCodeBackground = styled.div`\n    display: flex;\n    align-items: center;\n    position: relative;\n    background-color: ${(props) => props.theme.colors.background.secondary};\n    border-radius: ${(props) => borders$3[props.theme.borderRadius]};\n    padding: ${toPx(qrPaddingTop)} 0;\n    height: ${toPx(qrNormalSize + qrPaddingTop * 2)};\n    width: 100%;\n\n    overflow: hidden;\n`;\nconst QrCodeWrapper = styled.div`\n    position: relative;\n\n    width: fit-content;\n    margin: 0 auto;\n\n    > div:first-child {\n        display: flex;\n        align-items: center;\n        justify-content: center;\n    }\n\n    rect {\n        fill: transparent;\n    }\n\n    path {\n        fill: ${(props) => props.theme.colors.text.primary};\n    }\n`;\nconst ImageBackground = styled.div`\n    position: absolute;\n    width: ${toPx(imgSizeDefault)};\n    height: ${toPx(imgSizeDefault)};\n    background: ${(props) => props.theme.colors.background.secondary};\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n`;\nconst ImageStyled$2 = styled(Image)`\n    width: ${(props) => toPx(props.size)};\n    height: ${(props) => toPx(props.size)};\n    border-radius: 12px;\n`;\nconst CopyButtonStyled = styled(Button)`\n    filter: drop-shadow(0px 2px 8px rgba(0, 0, 0, 0.08));\n    position: absolute;\n    bottom: 14px;\n    left: 50%;\n\n    transform: translate(-50%, 0);\n\n    background-color: ${(props) => props.theme.colors.background.segment};\n    color: ${(props) => props.theme.colors.text.primary};\n\n    &:hover {\n        transform: translate(-50%, 0) scale(1.04);\n    }\n\n    &:active {\n        transform: translate(-50%, 0) scale(0.96);\n    }\n`;\nvar qrcode$1 = { exports: {} };\n(function(module, exports) {\n  var qrcode2 = function() {\n    var qrcode3 = function(typeNumber, errorCorrectionLevel) {\n      var PAD0 = 236;\n      var PAD1 = 17;\n      var _typeNumber = typeNumber;\n      var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];\n      var _modules = null;\n      var _moduleCount = 0;\n      var _dataCache = null;\n      var _dataList = [];\n      var _this = {};\n      var makeImpl = function(test, maskPattern) {\n        _moduleCount = _typeNumber * 4 + 17;\n        _modules = function(moduleCount) {\n          var modules = new Array(moduleCount);\n          for (var row = 0; row < moduleCount; row += 1) {\n            modules[row] = new Array(moduleCount);\n            for (var col = 0; col < moduleCount; col += 1) {\n              modules[row][col] = null;\n            }\n          }\n          return modules;\n        }(_moduleCount);\n        setupPositionProbePattern(0, 0);\n        setupPositionProbePattern(_moduleCount - 7, 0);\n        setupPositionProbePattern(0, _moduleCount - 7);\n        setupPositionAdjustPattern();\n        setupTimingPattern();\n        setupTypeInfo(test, maskPattern);\n        if (_typeNumber >= 7) {\n          setupTypeNumber(test);\n        }\n        if (_dataCache == null) {\n          _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);\n        }\n        mapData(_dataCache, maskPattern);\n      };\n      var setupPositionProbePattern = function(row, col) {\n        for (var r = -1; r <= 7; r += 1) {\n          if (row + r <= -1 || _moduleCount <= row + r)\n            continue;\n          for (var c2 = -1; c2 <= 7; c2 += 1) {\n            if (col + c2 <= -1 || _moduleCount <= col + c2)\n              continue;\n            if (0 <= r && r <= 6 && (c2 == 0 || c2 == 6) || 0 <= c2 && c2 <= 6 && (r == 0 || r == 6) || 2 <= r && r <= 4 && 2 <= c2 && c2 <= 4) {\n              _modules[row + r][col + c2] = true;\n            } else {\n              _modules[row + r][col + c2] = false;\n            }\n          }\n        }\n      };\n      var getBestMaskPattern = function() {\n        var minLostPoint = 0;\n        var pattern = 0;\n        for (var i2 = 0; i2 < 8; i2 += 1) {\n          makeImpl(true, i2);\n          var lostPoint = QRUtil.getLostPoint(_this);\n          if (i2 == 0 || minLostPoint > lostPoint) {\n            minLostPoint = lostPoint;\n            pattern = i2;\n          }\n        }\n        return pattern;\n      };\n      var setupTimingPattern = function() {\n        for (var r = 8; r < _moduleCount - 8; r += 1) {\n          if (_modules[r][6] != null) {\n            continue;\n          }\n          _modules[r][6] = r % 2 == 0;\n        }\n        for (var c2 = 8; c2 < _moduleCount - 8; c2 += 1) {\n          if (_modules[6][c2] != null) {\n            continue;\n          }\n          _modules[6][c2] = c2 % 2 == 0;\n        }\n      };\n      var setupPositionAdjustPattern = function() {\n        var pos = QRUtil.getPatternPosition(_typeNumber);\n        for (var i2 = 0; i2 < pos.length; i2 += 1) {\n          for (var j = 0; j < pos.length; j += 1) {\n            var row = pos[i2];\n            var col = pos[j];\n            if (_modules[row][col] != null) {\n              continue;\n            }\n            for (var r = -2; r <= 2; r += 1) {\n              for (var c2 = -2; c2 <= 2; c2 += 1) {\n                if (r == -2 || r == 2 || c2 == -2 || c2 == 2 || r == 0 && c2 == 0) {\n                  _modules[row + r][col + c2] = true;\n                } else {\n                  _modules[row + r][col + c2] = false;\n                }\n              }\n            }\n          }\n        }\n      };\n      var setupTypeNumber = function(test) {\n        var bits = QRUtil.getBCHTypeNumber(_typeNumber);\n        for (var i2 = 0; i2 < 18; i2 += 1) {\n          var mod = !test && (bits >> i2 & 1) == 1;\n          _modules[Math.floor(i2 / 3)][i2 % 3 + _moduleCount - 8 - 3] = mod;\n        }\n        for (var i2 = 0; i2 < 18; i2 += 1) {\n          var mod = !test && (bits >> i2 & 1) == 1;\n          _modules[i2 % 3 + _moduleCount - 8 - 3][Math.floor(i2 / 3)] = mod;\n        }\n      };\n      var setupTypeInfo = function(test, maskPattern) {\n        var data = _errorCorrectionLevel << 3 | maskPattern;\n        var bits = QRUtil.getBCHTypeInfo(data);\n        for (var i2 = 0; i2 < 15; i2 += 1) {\n          var mod = !test && (bits >> i2 & 1) == 1;\n          if (i2 < 6) {\n            _modules[i2][8] = mod;\n          } else if (i2 < 8) {\n            _modules[i2 + 1][8] = mod;\n          } else {\n            _modules[_moduleCount - 15 + i2][8] = mod;\n          }\n        }\n        for (var i2 = 0; i2 < 15; i2 += 1) {\n          var mod = !test && (bits >> i2 & 1) == 1;\n          if (i2 < 8) {\n            _modules[8][_moduleCount - i2 - 1] = mod;\n          } else if (i2 < 9) {\n            _modules[8][15 - i2 - 1 + 1] = mod;\n          } else {\n            _modules[8][15 - i2 - 1] = mod;\n          }\n        }\n        _modules[_moduleCount - 8][8] = !test;\n      };\n      var mapData = function(data, maskPattern) {\n        var inc = -1;\n        var row = _moduleCount - 1;\n        var bitIndex = 7;\n        var byteIndex = 0;\n        var maskFunc = QRUtil.getMaskFunction(maskPattern);\n        for (var col = _moduleCount - 1; col > 0; col -= 2) {\n          if (col == 6)\n            col -= 1;\n          while (true) {\n            for (var c2 = 0; c2 < 2; c2 += 1) {\n              if (_modules[row][col - c2] == null) {\n                var dark = false;\n                if (byteIndex < data.length) {\n                  dark = (data[byteIndex] >>> bitIndex & 1) == 1;\n                }\n                var mask = maskFunc(row, col - c2);\n                if (mask) {\n                  dark = !dark;\n                }\n                _modules[row][col - c2] = dark;\n                bitIndex -= 1;\n                if (bitIndex == -1) {\n                  byteIndex += 1;\n                  bitIndex = 7;\n                }\n              }\n            }\n            row += inc;\n            if (row < 0 || _moduleCount <= row) {\n              row -= inc;\n              inc = -inc;\n              break;\n            }\n          }\n        }\n      };\n      var createBytes = function(buffer, rsBlocks) {\n        var offset = 0;\n        var maxDcCount = 0;\n        var maxEcCount = 0;\n        var dcdata = new Array(rsBlocks.length);\n        var ecdata = new Array(rsBlocks.length);\n        for (var r = 0; r < rsBlocks.length; r += 1) {\n          var dcCount = rsBlocks[r].dataCount;\n          var ecCount = rsBlocks[r].totalCount - dcCount;\n          maxDcCount = Math.max(maxDcCount, dcCount);\n          maxEcCount = Math.max(maxEcCount, ecCount);\n          dcdata[r] = new Array(dcCount);\n          for (var i2 = 0; i2 < dcdata[r].length; i2 += 1) {\n            dcdata[r][i2] = 255 & buffer.getBuffer()[i2 + offset];\n          }\n          offset += dcCount;\n          var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);\n          var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);\n          var modPoly = rawPoly.mod(rsPoly);\n          ecdata[r] = new Array(rsPoly.getLength() - 1);\n          for (var i2 = 0; i2 < ecdata[r].length; i2 += 1) {\n            var modIndex = i2 + modPoly.getLength() - ecdata[r].length;\n            ecdata[r][i2] = modIndex >= 0 ? modPoly.getAt(modIndex) : 0;\n          }\n        }\n        var totalCodeCount = 0;\n        for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {\n          totalCodeCount += rsBlocks[i2].totalCount;\n        }\n        var data = new Array(totalCodeCount);\n        var index = 0;\n        for (var i2 = 0; i2 < maxDcCount; i2 += 1) {\n          for (var r = 0; r < rsBlocks.length; r += 1) {\n            if (i2 < dcdata[r].length) {\n              data[index] = dcdata[r][i2];\n              index += 1;\n            }\n          }\n        }\n        for (var i2 = 0; i2 < maxEcCount; i2 += 1) {\n          for (var r = 0; r < rsBlocks.length; r += 1) {\n            if (i2 < ecdata[r].length) {\n              data[index] = ecdata[r][i2];\n              index += 1;\n            }\n          }\n        }\n        return data;\n      };\n      var createData = function(typeNumber2, errorCorrectionLevel2, dataList) {\n        var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, errorCorrectionLevel2);\n        var buffer = qrBitBuffer();\n        for (var i2 = 0; i2 < dataList.length; i2 += 1) {\n          var data = dataList[i2];\n          buffer.put(data.getMode(), 4);\n          buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));\n          data.write(buffer);\n        }\n        var totalDataCount = 0;\n        for (var i2 = 0; i2 < rsBlocks.length; i2 += 1) {\n          totalDataCount += rsBlocks[i2].dataCount;\n        }\n        if (buffer.getLengthInBits() > totalDataCount * 8) {\n          throw \"code length overflow. (\" + buffer.getLengthInBits() + \">\" + totalDataCount * 8 + \")\";\n        }\n        if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {\n          buffer.put(0, 4);\n        }\n        while (buffer.getLengthInBits() % 8 != 0) {\n          buffer.putBit(false);\n        }\n        while (true) {\n          if (buffer.getLengthInBits() >= totalDataCount * 8) {\n            break;\n          }\n          buffer.put(PAD0, 8);\n          if (buffer.getLengthInBits() >= totalDataCount * 8) {\n            break;\n          }\n          buffer.put(PAD1, 8);\n        }\n        return createBytes(buffer, rsBlocks);\n      };\n      _this.addData = function(data, mode) {\n        mode = mode || \"Byte\";\n        var newData = null;\n        switch (mode) {\n          case \"Numeric\":\n            newData = qrNumber(data);\n            break;\n          case \"Alphanumeric\":\n            newData = qrAlphaNum(data);\n            break;\n          case \"Byte\":\n            newData = qr8BitByte(data);\n            break;\n          case \"Kanji\":\n            newData = qrKanji(data);\n            break;\n          default:\n            throw \"mode:\" + mode;\n        }\n        _dataList.push(newData);\n        _dataCache = null;\n      };\n      _this.isDark = function(row, col) {\n        if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {\n          throw row + \",\" + col;\n        }\n        return _modules[row][col];\n      };\n      _this.getModuleCount = function() {\n        return _moduleCount;\n      };\n      _this.make = function() {\n        if (_typeNumber < 1) {\n          var typeNumber2 = 1;\n          for (; typeNumber2 < 40; typeNumber2++) {\n            var rsBlocks = QRRSBlock.getRSBlocks(typeNumber2, _errorCorrectionLevel);\n            var buffer = qrBitBuffer();\n            for (var i2 = 0; i2 < _dataList.length; i2++) {\n              var data = _dataList[i2];\n              buffer.put(data.getMode(), 4);\n              buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber2));\n              data.write(buffer);\n            }\n            var totalDataCount = 0;\n            for (var i2 = 0; i2 < rsBlocks.length; i2++) {\n              totalDataCount += rsBlocks[i2].dataCount;\n            }\n            if (buffer.getLengthInBits() <= totalDataCount * 8) {\n              break;\n            }\n          }\n          _typeNumber = typeNumber2;\n        }\n        makeImpl(false, getBestMaskPattern());\n      };\n      _this.createTableTag = function(cellSize, margin) {\n        cellSize = cellSize || 2;\n        margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n        var qrHtml = \"\";\n        qrHtml += '<table style=\"';\n        qrHtml += \" border-width: 0px; border-style: none;\";\n        qrHtml += \" border-collapse: collapse;\";\n        qrHtml += \" padding: 0px; margin: \" + margin + \"px;\";\n        qrHtml += '\">';\n        qrHtml += \"<tbody>\";\n        for (var r = 0; r < _this.getModuleCount(); r += 1) {\n          qrHtml += \"<tr>\";\n          for (var c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {\n            qrHtml += '<td style=\"';\n            qrHtml += \" border-width: 0px; border-style: none;\";\n            qrHtml += \" border-collapse: collapse;\";\n            qrHtml += \" padding: 0px; margin: 0px;\";\n            qrHtml += \" width: \" + cellSize + \"px;\";\n            qrHtml += \" height: \" + cellSize + \"px;\";\n            qrHtml += \" background-color: \";\n            qrHtml += _this.isDark(r, c2) ? \"#000000\" : \"#ffffff\";\n            qrHtml += \";\";\n            qrHtml += '\"/>';\n          }\n          qrHtml += \"</tr>\";\n        }\n        qrHtml += \"</tbody>\";\n        qrHtml += \"</table>\";\n        return qrHtml;\n      };\n      _this.createSvgTag = function(cellSize, margin, alt, title) {\n        var opts = {};\n        if (typeof arguments[0] == \"object\") {\n          opts = arguments[0];\n          cellSize = opts.cellSize;\n          margin = opts.margin;\n          alt = opts.alt;\n          title = opts.title;\n        }\n        cellSize = cellSize || 2;\n        margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n        alt = typeof alt === \"string\" ? { text: alt } : alt || {};\n        alt.text = alt.text || null;\n        alt.id = alt.text ? alt.id || \"qrcode-description\" : null;\n        title = typeof title === \"string\" ? { text: title } : title || {};\n        title.text = title.text || null;\n        title.id = title.text ? title.id || \"qrcode-title\" : null;\n        var size = _this.getModuleCount() * cellSize + margin * 2;\n        var c2, mc, r, mr, qrSvg = \"\", rect;\n        rect = \"l\" + cellSize + \",0 0,\" + cellSize + \" -\" + cellSize + \",0 0,-\" + cellSize + \"z \";\n        qrSvg += '<svg version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\"';\n        qrSvg += !opts.scalable ? ' width=\"' + size + 'px\" height=\"' + size + 'px\"' : \"\";\n        qrSvg += ' viewBox=\"0 0 ' + size + \" \" + size + '\" ';\n        qrSvg += ' preserveAspectRatio=\"xMinYMin meet\"';\n        qrSvg += title.text || alt.text ? ' role=\"img\" aria-labelledby=\"' + escapeXml([title.id, alt.id].join(\" \").trim()) + '\"' : \"\";\n        qrSvg += \">\";\n        qrSvg += title.text ? '<title id=\"' + escapeXml(title.id) + '\">' + escapeXml(title.text) + \"</title>\" : \"\";\n        qrSvg += alt.text ? '<description id=\"' + escapeXml(alt.id) + '\">' + escapeXml(alt.text) + \"</description>\" : \"\";\n        qrSvg += '<rect width=\"100%\" height=\"100%\" fill=\"white\" cx=\"0\" cy=\"0\"/>';\n        qrSvg += '<path d=\"';\n        for (r = 0; r < _this.getModuleCount(); r += 1) {\n          mr = r * cellSize + margin;\n          for (c2 = 0; c2 < _this.getModuleCount(); c2 += 1) {\n            if (_this.isDark(r, c2)) {\n              mc = c2 * cellSize + margin;\n              qrSvg += \"M\" + mc + \",\" + mr + rect;\n            }\n          }\n        }\n        qrSvg += '\" stroke=\"transparent\" fill=\"black\"/>';\n        qrSvg += \"</svg>\";\n        return qrSvg;\n      };\n      _this.createDataURL = function(cellSize, margin) {\n        cellSize = cellSize || 2;\n        margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n        var size = _this.getModuleCount() * cellSize + margin * 2;\n        var min2 = margin;\n        var max2 = size - margin;\n        return createDataURL(size, size, function(x, y) {\n          if (min2 <= x && x < max2 && min2 <= y && y < max2) {\n            var c2 = Math.floor((x - min2) / cellSize);\n            var r = Math.floor((y - min2) / cellSize);\n            return _this.isDark(r, c2) ? 0 : 1;\n          } else {\n            return 1;\n          }\n        });\n      };\n      _this.createImgTag = function(cellSize, margin, alt) {\n        cellSize = cellSize || 2;\n        margin = typeof margin == \"undefined\" ? cellSize * 4 : margin;\n        var size = _this.getModuleCount() * cellSize + margin * 2;\n        var img = \"\";\n        img += \"<img\";\n        img += ' src=\"';\n        img += _this.createDataURL(cellSize, margin);\n        img += '\"';\n        img += ' width=\"';\n        img += size;\n        img += '\"';\n        img += ' height=\"';\n        img += size;\n        img += '\"';\n        if (alt) {\n          img += ' alt=\"';\n          img += escapeXml(alt);\n          img += '\"';\n        }\n        img += \"/>\";\n        return img;\n      };\n      var escapeXml = function(s2) {\n        var escaped = \"\";\n        for (var i2 = 0; i2 < s2.length; i2 += 1) {\n          var c2 = s2.charAt(i2);\n          switch (c2) {\n            case \"<\":\n              escaped += \"&lt;\";\n              break;\n            case \">\":\n              escaped += \"&gt;\";\n              break;\n            case \"&\":\n              escaped += \"&amp;\";\n              break;\n            case '\"':\n              escaped += \"&quot;\";\n              break;\n            default:\n              escaped += c2;\n              break;\n          }\n        }\n        return escaped;\n      };\n      var _createHalfASCII = function(margin) {\n        var cellSize = 1;\n        margin = typeof margin == \"undefined\" ? cellSize * 2 : margin;\n        var size = _this.getModuleCount() * cellSize + margin * 2;\n        var min2 = margin;\n        var max2 = size - margin;\n        var y, x, r1, r2, p2;\n        var blocks = {\n          \"\\u2588\\u2588\": \"\\u2588\",\n          \"\\u2588 \": \"\\u2580\",\n          \" \\u2588\": \"\\u2584\",\n          \"  \": \" \"\n        };\n        var blocksLastLineNoMargin = {\n          \"\\u2588\\u2588\": \"\\u2580\",\n          \"\\u2588 \": \"\\u2580\",\n          \" \\u2588\": \" \",\n          \"  \": \" \"\n        };\n        var ascii = \"\";\n        for (y = 0; y < size; y += 2) {\n          r1 = Math.floor((y - min2) / cellSize);\n          r2 = Math.floor((y + 1 - min2) / cellSize);\n          for (x = 0; x < size; x += 1) {\n            p2 = \"\\u2588\";\n            if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r1, Math.floor((x - min2) / cellSize))) {\n              p2 = \" \";\n            }\n            if (min2 <= x && x < max2 && min2 <= y + 1 && y + 1 < max2 && _this.isDark(r2, Math.floor((x - min2) / cellSize))) {\n              p2 += \" \";\n            } else {\n              p2 += \"\\u2588\";\n            }\n            ascii += margin < 1 && y + 1 >= max2 ? blocksLastLineNoMargin[p2] : blocks[p2];\n          }\n          ascii += \"\\n\";\n        }\n        if (size % 2 && margin > 0) {\n          return ascii.substring(0, ascii.length - size - 1) + Array(size + 1).join(\"\\u2580\");\n        }\n        return ascii.substring(0, ascii.length - 1);\n      };\n      _this.createASCII = function(cellSize, margin) {\n        cellSize = cellSize || 1;\n        if (cellSize < 2) {\n          return _createHalfASCII(margin);\n        }\n        cellSize -= 1;\n        margin = typeof margin == \"undefined\" ? cellSize * 2 : margin;\n        var size = _this.getModuleCount() * cellSize + margin * 2;\n        var min2 = margin;\n        var max2 = size - margin;\n        var y, x, r, p2;\n        var white = Array(cellSize + 1).join(\"\\u2588\\u2588\");\n        var black = Array(cellSize + 1).join(\"  \");\n        var ascii = \"\";\n        var line = \"\";\n        for (y = 0; y < size; y += 1) {\n          r = Math.floor((y - min2) / cellSize);\n          line = \"\";\n          for (x = 0; x < size; x += 1) {\n            p2 = 1;\n            if (min2 <= x && x < max2 && min2 <= y && y < max2 && _this.isDark(r, Math.floor((x - min2) / cellSize))) {\n              p2 = 0;\n            }\n            line += p2 ? white : black;\n          }\n          for (r = 0; r < cellSize; r += 1) {\n            ascii += line + \"\\n\";\n          }\n        }\n        return ascii.substring(0, ascii.length - 1);\n      };\n      _this.renderTo2dContext = function(context, cellSize) {\n        cellSize = cellSize || 2;\n        var length = _this.getModuleCount();\n        for (var row = 0; row < length; row++) {\n          for (var col = 0; col < length; col++) {\n            context.fillStyle = _this.isDark(row, col) ? \"black\" : \"white\";\n            context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);\n          }\n        }\n      };\n      return _this;\n    };\n    qrcode3.stringToBytesFuncs = {\n      \"default\": function(s2) {\n        var bytes = [];\n        for (var i2 = 0; i2 < s2.length; i2 += 1) {\n          var c2 = s2.charCodeAt(i2);\n          bytes.push(c2 & 255);\n        }\n        return bytes;\n      }\n    };\n    qrcode3.stringToBytes = qrcode3.stringToBytesFuncs[\"default\"];\n    qrcode3.createStringToBytes = function(unicodeData, numChars) {\n      var unicodeMap = function() {\n        var bin = base64DecodeInputStream(unicodeData);\n        var read = function() {\n          var b = bin.read();\n          if (b == -1)\n            throw \"eof\";\n          return b;\n        };\n        var count = 0;\n        var unicodeMap2 = {};\n        while (true) {\n          var b0 = bin.read();\n          if (b0 == -1)\n            break;\n          var b1 = read();\n          var b2 = read();\n          var b3 = read();\n          var k = String.fromCharCode(b0 << 8 | b1);\n          var v = b2 << 8 | b3;\n          unicodeMap2[k] = v;\n          count += 1;\n        }\n        if (count != numChars) {\n          throw count + \" != \" + numChars;\n        }\n        return unicodeMap2;\n      }();\n      var unknownChar = \"?\".charCodeAt(0);\n      return function(s2) {\n        var bytes = [];\n        for (var i2 = 0; i2 < s2.length; i2 += 1) {\n          var c2 = s2.charCodeAt(i2);\n          if (c2 < 128) {\n            bytes.push(c2);\n          } else {\n            var b = unicodeMap[s2.charAt(i2)];\n            if (typeof b == \"number\") {\n              if ((b & 255) == b) {\n                bytes.push(b);\n              } else {\n                bytes.push(b >>> 8);\n                bytes.push(b & 255);\n              }\n            } else {\n              bytes.push(unknownChar);\n            }\n          }\n        }\n        return bytes;\n      };\n    };\n    var QRMode = {\n      MODE_NUMBER: 1 << 0,\n      MODE_ALPHA_NUM: 1 << 1,\n      MODE_8BIT_BYTE: 1 << 2,\n      MODE_KANJI: 1 << 3\n    };\n    var QRErrorCorrectionLevel = {\n      L: 1,\n      M: 0,\n      Q: 3,\n      H: 2\n    };\n    var QRMaskPattern = {\n      PATTERN000: 0,\n      PATTERN001: 1,\n      PATTERN010: 2,\n      PATTERN011: 3,\n      PATTERN100: 4,\n      PATTERN101: 5,\n      PATTERN110: 6,\n      PATTERN111: 7\n    };\n    var QRUtil = function() {\n      var PATTERN_POSITION_TABLE = [\n        [],\n        [6, 18],\n        [6, 22],\n        [6, 26],\n        [6, 30],\n        [6, 34],\n        [6, 22, 38],\n        [6, 24, 42],\n        [6, 26, 46],\n        [6, 28, 50],\n        [6, 30, 54],\n        [6, 32, 58],\n        [6, 34, 62],\n        [6, 26, 46, 66],\n        [6, 26, 48, 70],\n        [6, 26, 50, 74],\n        [6, 30, 54, 78],\n        [6, 30, 56, 82],\n        [6, 30, 58, 86],\n        [6, 34, 62, 90],\n        [6, 28, 50, 72, 94],\n        [6, 26, 50, 74, 98],\n        [6, 30, 54, 78, 102],\n        [6, 28, 54, 80, 106],\n        [6, 32, 58, 84, 110],\n        [6, 30, 58, 86, 114],\n        [6, 34, 62, 90, 118],\n        [6, 26, 50, 74, 98, 122],\n        [6, 30, 54, 78, 102, 126],\n        [6, 26, 52, 78, 104, 130],\n        [6, 30, 56, 82, 108, 134],\n        [6, 34, 60, 86, 112, 138],\n        [6, 30, 58, 86, 114, 142],\n        [6, 34, 62, 90, 118, 146],\n        [6, 30, 54, 78, 102, 126, 150],\n        [6, 24, 50, 76, 102, 128, 154],\n        [6, 28, 54, 80, 106, 132, 158],\n        [6, 32, 58, 84, 110, 136, 162],\n        [6, 26, 54, 82, 110, 138, 166],\n        [6, 30, 58, 86, 114, 142, 170]\n      ];\n      var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;\n      var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;\n      var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;\n      var _this = {};\n      var getBCHDigit = function(data) {\n        var digit = 0;\n        while (data != 0) {\n          digit += 1;\n          data >>>= 1;\n        }\n        return digit;\n      };\n      _this.getBCHTypeInfo = function(data) {\n        var d = data << 10;\n        while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {\n          d ^= G15 << getBCHDigit(d) - getBCHDigit(G15);\n        }\n        return (data << 10 | d) ^ G15_MASK;\n      };\n      _this.getBCHTypeNumber = function(data) {\n        var d = data << 12;\n        while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {\n          d ^= G18 << getBCHDigit(d) - getBCHDigit(G18);\n        }\n        return data << 12 | d;\n      };\n      _this.getPatternPosition = function(typeNumber) {\n        return PATTERN_POSITION_TABLE[typeNumber - 1];\n      };\n      _this.getMaskFunction = function(maskPattern) {\n        switch (maskPattern) {\n          case QRMaskPattern.PATTERN000:\n            return function(i2, j) {\n              return (i2 + j) % 2 == 0;\n            };\n          case QRMaskPattern.PATTERN001:\n            return function(i2, j) {\n              return i2 % 2 == 0;\n            };\n          case QRMaskPattern.PATTERN010:\n            return function(i2, j) {\n              return j % 3 == 0;\n            };\n          case QRMaskPattern.PATTERN011:\n            return function(i2, j) {\n              return (i2 + j) % 3 == 0;\n            };\n          case QRMaskPattern.PATTERN100:\n            return function(i2, j) {\n              return (Math.floor(i2 / 2) + Math.floor(j / 3)) % 2 == 0;\n            };\n          case QRMaskPattern.PATTERN101:\n            return function(i2, j) {\n              return i2 * j % 2 + i2 * j % 3 == 0;\n            };\n          case QRMaskPattern.PATTERN110:\n            return function(i2, j) {\n              return (i2 * j % 2 + i2 * j % 3) % 2 == 0;\n            };\n          case QRMaskPattern.PATTERN111:\n            return function(i2, j) {\n              return (i2 * j % 3 + (i2 + j) % 2) % 2 == 0;\n            };\n          default:\n            throw \"bad maskPattern:\" + maskPattern;\n        }\n      };\n      _this.getErrorCorrectPolynomial = function(errorCorrectLength) {\n        var a2 = qrPolynomial([1], 0);\n        for (var i2 = 0; i2 < errorCorrectLength; i2 += 1) {\n          a2 = a2.multiply(qrPolynomial([1, QRMath.gexp(i2)], 0));\n        }\n        return a2;\n      };\n      _this.getLengthInBits = function(mode, type) {\n        if (1 <= type && type < 10) {\n          switch (mode) {\n            case QRMode.MODE_NUMBER:\n              return 10;\n            case QRMode.MODE_ALPHA_NUM:\n              return 9;\n            case QRMode.MODE_8BIT_BYTE:\n              return 8;\n            case QRMode.MODE_KANJI:\n              return 8;\n            default:\n              throw \"mode:\" + mode;\n          }\n        } else if (type < 27) {\n          switch (mode) {\n            case QRMode.MODE_NUMBER:\n              return 12;\n            case QRMode.MODE_ALPHA_NUM:\n              return 11;\n            case QRMode.MODE_8BIT_BYTE:\n              return 16;\n            case QRMode.MODE_KANJI:\n              return 10;\n            default:\n              throw \"mode:\" + mode;\n          }\n        } else if (type < 41) {\n          switch (mode) {\n            case QRMode.MODE_NUMBER:\n              return 14;\n            case QRMode.MODE_ALPHA_NUM:\n              return 13;\n            case QRMode.MODE_8BIT_BYTE:\n              return 16;\n            case QRMode.MODE_KANJI:\n              return 12;\n            default:\n              throw \"mode:\" + mode;\n          }\n        } else {\n          throw \"type:\" + type;\n        }\n      };\n      _this.getLostPoint = function(qrcode4) {\n        var moduleCount = qrcode4.getModuleCount();\n        var lostPoint = 0;\n        for (var row = 0; row < moduleCount; row += 1) {\n          for (var col = 0; col < moduleCount; col += 1) {\n            var sameCount = 0;\n            var dark = qrcode4.isDark(row, col);\n            for (var r = -1; r <= 1; r += 1) {\n              if (row + r < 0 || moduleCount <= row + r) {\n                continue;\n              }\n              for (var c2 = -1; c2 <= 1; c2 += 1) {\n                if (col + c2 < 0 || moduleCount <= col + c2) {\n                  continue;\n                }\n                if (r == 0 && c2 == 0) {\n                  continue;\n                }\n                if (dark == qrcode4.isDark(row + r, col + c2)) {\n                  sameCount += 1;\n                }\n              }\n            }\n            if (sameCount > 5) {\n              lostPoint += 3 + sameCount - 5;\n            }\n          }\n        }\n        for (var row = 0; row < moduleCount - 1; row += 1) {\n          for (var col = 0; col < moduleCount - 1; col += 1) {\n            var count = 0;\n            if (qrcode4.isDark(row, col))\n              count += 1;\n            if (qrcode4.isDark(row + 1, col))\n              count += 1;\n            if (qrcode4.isDark(row, col + 1))\n              count += 1;\n            if (qrcode4.isDark(row + 1, col + 1))\n              count += 1;\n            if (count == 0 || count == 4) {\n              lostPoint += 3;\n            }\n          }\n        }\n        for (var row = 0; row < moduleCount; row += 1) {\n          for (var col = 0; col < moduleCount - 6; col += 1) {\n            if (qrcode4.isDark(row, col) && !qrcode4.isDark(row, col + 1) && qrcode4.isDark(row, col + 2) && qrcode4.isDark(row, col + 3) && qrcode4.isDark(row, col + 4) && !qrcode4.isDark(row, col + 5) && qrcode4.isDark(row, col + 6)) {\n              lostPoint += 40;\n            }\n          }\n        }\n        for (var col = 0; col < moduleCount; col += 1) {\n          for (var row = 0; row < moduleCount - 6; row += 1) {\n            if (qrcode4.isDark(row, col) && !qrcode4.isDark(row + 1, col) && qrcode4.isDark(row + 2, col) && qrcode4.isDark(row + 3, col) && qrcode4.isDark(row + 4, col) && !qrcode4.isDark(row + 5, col) && qrcode4.isDark(row + 6, col)) {\n              lostPoint += 40;\n            }\n          }\n        }\n        var darkCount = 0;\n        for (var col = 0; col < moduleCount; col += 1) {\n          for (var row = 0; row < moduleCount; row += 1) {\n            if (qrcode4.isDark(row, col)) {\n              darkCount += 1;\n            }\n          }\n        }\n        var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;\n        lostPoint += ratio * 10;\n        return lostPoint;\n      };\n      return _this;\n    }();\n    var QRMath = function() {\n      var EXP_TABLE = new Array(256);\n      var LOG_TABLE = new Array(256);\n      for (var i2 = 0; i2 < 8; i2 += 1) {\n        EXP_TABLE[i2] = 1 << i2;\n      }\n      for (var i2 = 8; i2 < 256; i2 += 1) {\n        EXP_TABLE[i2] = EXP_TABLE[i2 - 4] ^ EXP_TABLE[i2 - 5] ^ EXP_TABLE[i2 - 6] ^ EXP_TABLE[i2 - 8];\n      }\n      for (var i2 = 0; i2 < 255; i2 += 1) {\n        LOG_TABLE[EXP_TABLE[i2]] = i2;\n      }\n      var _this = {};\n      _this.glog = function(n2) {\n        if (n2 < 1) {\n          throw \"glog(\" + n2 + \")\";\n        }\n        return LOG_TABLE[n2];\n      };\n      _this.gexp = function(n2) {\n        while (n2 < 0) {\n          n2 += 255;\n        }\n        while (n2 >= 256) {\n          n2 -= 255;\n        }\n        return EXP_TABLE[n2];\n      };\n      return _this;\n    }();\n    function qrPolynomial(num, shift) {\n      if (typeof num.length == \"undefined\") {\n        throw num.length + \"/\" + shift;\n      }\n      var _num = function() {\n        var offset = 0;\n        while (offset < num.length && num[offset] == 0) {\n          offset += 1;\n        }\n        var _num2 = new Array(num.length - offset + shift);\n        for (var i2 = 0; i2 < num.length - offset; i2 += 1) {\n          _num2[i2] = num[i2 + offset];\n        }\n        return _num2;\n      }();\n      var _this = {};\n      _this.getAt = function(index) {\n        return _num[index];\n      };\n      _this.getLength = function() {\n        return _num.length;\n      };\n      _this.multiply = function(e2) {\n        var num2 = new Array(_this.getLength() + e2.getLength() - 1);\n        for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {\n          for (var j = 0; j < e2.getLength(); j += 1) {\n            num2[i2 + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i2)) + QRMath.glog(e2.getAt(j)));\n          }\n        }\n        return qrPolynomial(num2, 0);\n      };\n      _this.mod = function(e2) {\n        if (_this.getLength() - e2.getLength() < 0) {\n          return _this;\n        }\n        var ratio = QRMath.glog(_this.getAt(0)) - QRMath.glog(e2.getAt(0));\n        var num2 = new Array(_this.getLength());\n        for (var i2 = 0; i2 < _this.getLength(); i2 += 1) {\n          num2[i2] = _this.getAt(i2);\n        }\n        for (var i2 = 0; i2 < e2.getLength(); i2 += 1) {\n          num2[i2] ^= QRMath.gexp(QRMath.glog(e2.getAt(i2)) + ratio);\n        }\n        return qrPolynomial(num2, 0).mod(e2);\n      };\n      return _this;\n    }\n    var QRRSBlock = function() {\n      var RS_BLOCK_TABLE = [\n        [1, 26, 19],\n        [1, 26, 16],\n        [1, 26, 13],\n        [1, 26, 9],\n        [1, 44, 34],\n        [1, 44, 28],\n        [1, 44, 22],\n        [1, 44, 16],\n        [1, 70, 55],\n        [1, 70, 44],\n        [2, 35, 17],\n        [2, 35, 13],\n        [1, 100, 80],\n        [2, 50, 32],\n        [2, 50, 24],\n        [4, 25, 9],\n        [1, 134, 108],\n        [2, 67, 43],\n        [2, 33, 15, 2, 34, 16],\n        [2, 33, 11, 2, 34, 12],\n        [2, 86, 68],\n        [4, 43, 27],\n        [4, 43, 19],\n        [4, 43, 15],\n        [2, 98, 78],\n        [4, 49, 31],\n        [2, 32, 14, 4, 33, 15],\n        [4, 39, 13, 1, 40, 14],\n        [2, 121, 97],\n        [2, 60, 38, 2, 61, 39],\n        [4, 40, 18, 2, 41, 19],\n        [4, 40, 14, 2, 41, 15],\n        [2, 146, 116],\n        [3, 58, 36, 2, 59, 37],\n        [4, 36, 16, 4, 37, 17],\n        [4, 36, 12, 4, 37, 13],\n        [2, 86, 68, 2, 87, 69],\n        [4, 69, 43, 1, 70, 44],\n        [6, 43, 19, 2, 44, 20],\n        [6, 43, 15, 2, 44, 16],\n        [4, 101, 81],\n        [1, 80, 50, 4, 81, 51],\n        [4, 50, 22, 4, 51, 23],\n        [3, 36, 12, 8, 37, 13],\n        [2, 116, 92, 2, 117, 93],\n        [6, 58, 36, 2, 59, 37],\n        [4, 46, 20, 6, 47, 21],\n        [7, 42, 14, 4, 43, 15],\n        [4, 133, 107],\n        [8, 59, 37, 1, 60, 38],\n        [8, 44, 20, 4, 45, 21],\n        [12, 33, 11, 4, 34, 12],\n        [3, 145, 115, 1, 146, 116],\n        [4, 64, 40, 5, 65, 41],\n        [11, 36, 16, 5, 37, 17],\n        [11, 36, 12, 5, 37, 13],\n        [5, 109, 87, 1, 110, 88],\n        [5, 65, 41, 5, 66, 42],\n        [5, 54, 24, 7, 55, 25],\n        [11, 36, 12, 7, 37, 13],\n        [5, 122, 98, 1, 123, 99],\n        [7, 73, 45, 3, 74, 46],\n        [15, 43, 19, 2, 44, 20],\n        [3, 45, 15, 13, 46, 16],\n        [1, 135, 107, 5, 136, 108],\n        [10, 74, 46, 1, 75, 47],\n        [1, 50, 22, 15, 51, 23],\n        [2, 42, 14, 17, 43, 15],\n        [5, 150, 120, 1, 151, 121],\n        [9, 69, 43, 4, 70, 44],\n        [17, 50, 22, 1, 51, 23],\n        [2, 42, 14, 19, 43, 15],\n        [3, 141, 113, 4, 142, 114],\n        [3, 70, 44, 11, 71, 45],\n        [17, 47, 21, 4, 48, 22],\n        [9, 39, 13, 16, 40, 14],\n        [3, 135, 107, 5, 136, 108],\n        [3, 67, 41, 13, 68, 42],\n        [15, 54, 24, 5, 55, 25],\n        [15, 43, 15, 10, 44, 16],\n        [4, 144, 116, 4, 145, 117],\n        [17, 68, 42],\n        [17, 50, 22, 6, 51, 23],\n        [19, 46, 16, 6, 47, 17],\n        [2, 139, 111, 7, 140, 112],\n        [17, 74, 46],\n        [7, 54, 24, 16, 55, 25],\n        [34, 37, 13],\n        [4, 151, 121, 5, 152, 122],\n        [4, 75, 47, 14, 76, 48],\n        [11, 54, 24, 14, 55, 25],\n        [16, 45, 15, 14, 46, 16],\n        [6, 147, 117, 4, 148, 118],\n        [6, 73, 45, 14, 74, 46],\n        [11, 54, 24, 16, 55, 25],\n        [30, 46, 16, 2, 47, 17],\n        [8, 132, 106, 4, 133, 107],\n        [8, 75, 47, 13, 76, 48],\n        [7, 54, 24, 22, 55, 25],\n        [22, 45, 15, 13, 46, 16],\n        [10, 142, 114, 2, 143, 115],\n        [19, 74, 46, 4, 75, 47],\n        [28, 50, 22, 6, 51, 23],\n        [33, 46, 16, 4, 47, 17],\n        [8, 152, 122, 4, 153, 123],\n        [22, 73, 45, 3, 74, 46],\n        [8, 53, 23, 26, 54, 24],\n        [12, 45, 15, 28, 46, 16],\n        [3, 147, 117, 10, 148, 118],\n        [3, 73, 45, 23, 74, 46],\n        [4, 54, 24, 31, 55, 25],\n        [11, 45, 15, 31, 46, 16],\n        [7, 146, 116, 7, 147, 117],\n        [21, 73, 45, 7, 74, 46],\n        [1, 53, 23, 37, 54, 24],\n        [19, 45, 15, 26, 46, 16],\n        [5, 145, 115, 10, 146, 116],\n        [19, 75, 47, 10, 76, 48],\n        [15, 54, 24, 25, 55, 25],\n        [23, 45, 15, 25, 46, 16],\n        [13, 145, 115, 3, 146, 116],\n        [2, 74, 46, 29, 75, 47],\n        [42, 54, 24, 1, 55, 25],\n        [23, 45, 15, 28, 46, 16],\n        [17, 145, 115],\n        [10, 74, 46, 23, 75, 47],\n        [10, 54, 24, 35, 55, 25],\n        [19, 45, 15, 35, 46, 16],\n        [17, 145, 115, 1, 146, 116],\n        [14, 74, 46, 21, 75, 47],\n        [29, 54, 24, 19, 55, 25],\n        [11, 45, 15, 46, 46, 16],\n        [13, 145, 115, 6, 146, 116],\n        [14, 74, 46, 23, 75, 47],\n        [44, 54, 24, 7, 55, 25],\n        [59, 46, 16, 1, 47, 17],\n        [12, 151, 121, 7, 152, 122],\n        [12, 75, 47, 26, 76, 48],\n        [39, 54, 24, 14, 55, 25],\n        [22, 45, 15, 41, 46, 16],\n        [6, 151, 121, 14, 152, 122],\n        [6, 75, 47, 34, 76, 48],\n        [46, 54, 24, 10, 55, 25],\n        [2, 45, 15, 64, 46, 16],\n        [17, 152, 122, 4, 153, 123],\n        [29, 74, 46, 14, 75, 47],\n        [49, 54, 24, 10, 55, 25],\n        [24, 45, 15, 46, 46, 16],\n        [4, 152, 122, 18, 153, 123],\n        [13, 74, 46, 32, 75, 47],\n        [48, 54, 24, 14, 55, 25],\n        [42, 45, 15, 32, 46, 16],\n        [20, 147, 117, 4, 148, 118],\n        [40, 75, 47, 7, 76, 48],\n        [43, 54, 24, 22, 55, 25],\n        [10, 45, 15, 67, 46, 16],\n        [19, 148, 118, 6, 149, 119],\n        [18, 75, 47, 31, 76, 48],\n        [34, 54, 24, 34, 55, 25],\n        [20, 45, 15, 61, 46, 16]\n      ];\n      var qrRSBlock = function(totalCount, dataCount) {\n        var _this2 = {};\n        _this2.totalCount = totalCount;\n        _this2.dataCount = dataCount;\n        return _this2;\n      };\n      var _this = {};\n      var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {\n        switch (errorCorrectionLevel) {\n          case QRErrorCorrectionLevel.L:\n            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];\n          case QRErrorCorrectionLevel.M:\n            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];\n          case QRErrorCorrectionLevel.Q:\n            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];\n          case QRErrorCorrectionLevel.H:\n            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];\n          default:\n            return void 0;\n        }\n      };\n      _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {\n        var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);\n        if (typeof rsBlock == \"undefined\") {\n          throw \"bad rs block @ typeNumber:\" + typeNumber + \"/errorCorrectionLevel:\" + errorCorrectionLevel;\n        }\n        var length = rsBlock.length / 3;\n        var list = [];\n        for (var i2 = 0; i2 < length; i2 += 1) {\n          var count = rsBlock[i2 * 3 + 0];\n          var totalCount = rsBlock[i2 * 3 + 1];\n          var dataCount = rsBlock[i2 * 3 + 2];\n          for (var j = 0; j < count; j += 1) {\n            list.push(qrRSBlock(totalCount, dataCount));\n          }\n        }\n        return list;\n      };\n      return _this;\n    }();\n    var qrBitBuffer = function() {\n      var _buffer = [];\n      var _length = 0;\n      var _this = {};\n      _this.getBuffer = function() {\n        return _buffer;\n      };\n      _this.getAt = function(index) {\n        var bufIndex = Math.floor(index / 8);\n        return (_buffer[bufIndex] >>> 7 - index % 8 & 1) == 1;\n      };\n      _this.put = function(num, length) {\n        for (var i2 = 0; i2 < length; i2 += 1) {\n          _this.putBit((num >>> length - i2 - 1 & 1) == 1);\n        }\n      };\n      _this.getLengthInBits = function() {\n        return _length;\n      };\n      _this.putBit = function(bit) {\n        var bufIndex = Math.floor(_length / 8);\n        if (_buffer.length <= bufIndex) {\n          _buffer.push(0);\n        }\n        if (bit) {\n          _buffer[bufIndex] |= 128 >>> _length % 8;\n        }\n        _length += 1;\n      };\n      return _this;\n    };\n    var qrNumber = function(data) {\n      var _mode = QRMode.MODE_NUMBER;\n      var _data = data;\n      var _this = {};\n      _this.getMode = function() {\n        return _mode;\n      };\n      _this.getLength = function(buffer) {\n        return _data.length;\n      };\n      _this.write = function(buffer) {\n        var data2 = _data;\n        var i2 = 0;\n        while (i2 + 2 < data2.length) {\n          buffer.put(strToNum(data2.substring(i2, i2 + 3)), 10);\n          i2 += 3;\n        }\n        if (i2 < data2.length) {\n          if (data2.length - i2 == 1) {\n            buffer.put(strToNum(data2.substring(i2, i2 + 1)), 4);\n          } else if (data2.length - i2 == 2) {\n            buffer.put(strToNum(data2.substring(i2, i2 + 2)), 7);\n          }\n        }\n      };\n      var strToNum = function(s2) {\n        var num = 0;\n        for (var i2 = 0; i2 < s2.length; i2 += 1) {\n          num = num * 10 + chatToNum(s2.charAt(i2));\n        }\n        return num;\n      };\n      var chatToNum = function(c2) {\n        if (\"0\" <= c2 && c2 <= \"9\") {\n          return c2.charCodeAt(0) - \"0\".charCodeAt(0);\n        }\n        throw \"illegal char :\" + c2;\n      };\n      return _this;\n    };\n    var qrAlphaNum = function(data) {\n      var _mode = QRMode.MODE_ALPHA_NUM;\n      var _data = data;\n      var _this = {};\n      _this.getMode = function() {\n        return _mode;\n      };\n      _this.getLength = function(buffer) {\n        return _data.length;\n      };\n      _this.write = function(buffer) {\n        var s2 = _data;\n        var i2 = 0;\n        while (i2 + 1 < s2.length) {\n          buffer.put(\n            getCode(s2.charAt(i2)) * 45 + getCode(s2.charAt(i2 + 1)),\n            11\n          );\n          i2 += 2;\n        }\n        if (i2 < s2.length) {\n          buffer.put(getCode(s2.charAt(i2)), 6);\n        }\n      };\n      var getCode = function(c2) {\n        if (\"0\" <= c2 && c2 <= \"9\") {\n          return c2.charCodeAt(0) - \"0\".charCodeAt(0);\n        } else if (\"A\" <= c2 && c2 <= \"Z\") {\n          return c2.charCodeAt(0) - \"A\".charCodeAt(0) + 10;\n        } else {\n          switch (c2) {\n            case \" \":\n              return 36;\n            case \"$\":\n              return 37;\n            case \"%\":\n              return 38;\n            case \"*\":\n              return 39;\n            case \"+\":\n              return 40;\n            case \"-\":\n              return 41;\n            case \".\":\n              return 42;\n            case \"/\":\n              return 43;\n            case \":\":\n              return 44;\n            default:\n              throw \"illegal char :\" + c2;\n          }\n        }\n      };\n      return _this;\n    };\n    var qr8BitByte = function(data) {\n      var _mode = QRMode.MODE_8BIT_BYTE;\n      var _bytes = qrcode3.stringToBytes(data);\n      var _this = {};\n      _this.getMode = function() {\n        return _mode;\n      };\n      _this.getLength = function(buffer) {\n        return _bytes.length;\n      };\n      _this.write = function(buffer) {\n        for (var i2 = 0; i2 < _bytes.length; i2 += 1) {\n          buffer.put(_bytes[i2], 8);\n        }\n      };\n      return _this;\n    };\n    var qrKanji = function(data) {\n      var _mode = QRMode.MODE_KANJI;\n      var stringToBytes = qrcode3.stringToBytesFuncs[\"SJIS\"];\n      if (!stringToBytes) {\n        throw \"sjis not supported.\";\n      }\n      !function(c2, code) {\n        var test = stringToBytes(c2);\n        if (test.length != 2 || (test[0] << 8 | test[1]) != code) {\n          throw \"sjis not supported.\";\n        }\n      }(\"\\u53CB\", 38726);\n      var _bytes = stringToBytes(data);\n      var _this = {};\n      _this.getMode = function() {\n        return _mode;\n      };\n      _this.getLength = function(buffer) {\n        return ~~(_bytes.length / 2);\n      };\n      _this.write = function(buffer) {\n        var data2 = _bytes;\n        var i2 = 0;\n        while (i2 + 1 < data2.length) {\n          var c2 = (255 & data2[i2]) << 8 | 255 & data2[i2 + 1];\n          if (33088 <= c2 && c2 <= 40956) {\n            c2 -= 33088;\n          } else if (57408 <= c2 && c2 <= 60351) {\n            c2 -= 49472;\n          } else {\n            throw \"illegal char at \" + (i2 + 1) + \"/\" + c2;\n          }\n          c2 = (c2 >>> 8 & 255) * 192 + (c2 & 255);\n          buffer.put(c2, 13);\n          i2 += 2;\n        }\n        if (i2 < data2.length) {\n          throw \"illegal char at \" + (i2 + 1);\n        }\n      };\n      return _this;\n    };\n    var byteArrayOutputStream = function() {\n      var _bytes = [];\n      var _this = {};\n      _this.writeByte = function(b) {\n        _bytes.push(b & 255);\n      };\n      _this.writeShort = function(i2) {\n        _this.writeByte(i2);\n        _this.writeByte(i2 >>> 8);\n      };\n      _this.writeBytes = function(b, off, len) {\n        off = off || 0;\n        len = len || b.length;\n        for (var i2 = 0; i2 < len; i2 += 1) {\n          _this.writeByte(b[i2 + off]);\n        }\n      };\n      _this.writeString = function(s2) {\n        for (var i2 = 0; i2 < s2.length; i2 += 1) {\n          _this.writeByte(s2.charCodeAt(i2));\n        }\n      };\n      _this.toByteArray = function() {\n        return _bytes;\n      };\n      _this.toString = function() {\n        var s2 = \"\";\n        s2 += \"[\";\n        for (var i2 = 0; i2 < _bytes.length; i2 += 1) {\n          if (i2 > 0) {\n            s2 += \",\";\n          }\n          s2 += _bytes[i2];\n        }\n        s2 += \"]\";\n        return s2;\n      };\n      return _this;\n    };\n    var base64EncodeOutputStream = function() {\n      var _buffer = 0;\n      var _buflen = 0;\n      var _length = 0;\n      var _base64 = \"\";\n      var _this = {};\n      var writeEncoded = function(b) {\n        _base64 += String.fromCharCode(encode(b & 63));\n      };\n      var encode = function(n2) {\n        if (n2 < 0)\n          ;\n        else if (n2 < 26) {\n          return 65 + n2;\n        } else if (n2 < 52) {\n          return 97 + (n2 - 26);\n        } else if (n2 < 62) {\n          return 48 + (n2 - 52);\n        } else if (n2 == 62) {\n          return 43;\n        } else if (n2 == 63) {\n          return 47;\n        }\n        throw \"n:\" + n2;\n      };\n      _this.writeByte = function(n2) {\n        _buffer = _buffer << 8 | n2 & 255;\n        _buflen += 8;\n        _length += 1;\n        while (_buflen >= 6) {\n          writeEncoded(_buffer >>> _buflen - 6);\n          _buflen -= 6;\n        }\n      };\n      _this.flush = function() {\n        if (_buflen > 0) {\n          writeEncoded(_buffer << 6 - _buflen);\n          _buffer = 0;\n          _buflen = 0;\n        }\n        if (_length % 3 != 0) {\n          var padlen = 3 - _length % 3;\n          for (var i2 = 0; i2 < padlen; i2 += 1) {\n            _base64 += \"=\";\n          }\n        }\n      };\n      _this.toString = function() {\n        return _base64;\n      };\n      return _this;\n    };\n    var base64DecodeInputStream = function(str) {\n      var _str = str;\n      var _pos = 0;\n      var _buffer = 0;\n      var _buflen = 0;\n      var _this = {};\n      _this.read = function() {\n        while (_buflen < 8) {\n          if (_pos >= _str.length) {\n            if (_buflen == 0) {\n              return -1;\n            }\n            throw \"unexpected end of file./\" + _buflen;\n          }\n          var c2 = _str.charAt(_pos);\n          _pos += 1;\n          if (c2 == \"=\") {\n            _buflen = 0;\n            return -1;\n          } else if (c2.match(/^\\s$/)) {\n            continue;\n          }\n          _buffer = _buffer << 6 | decode(c2.charCodeAt(0));\n          _buflen += 6;\n        }\n        var n2 = _buffer >>> _buflen - 8 & 255;\n        _buflen -= 8;\n        return n2;\n      };\n      var decode = function(c2) {\n        if (65 <= c2 && c2 <= 90) {\n          return c2 - 65;\n        } else if (97 <= c2 && c2 <= 122) {\n          return c2 - 97 + 26;\n        } else if (48 <= c2 && c2 <= 57) {\n          return c2 - 48 + 52;\n        } else if (c2 == 43) {\n          return 62;\n        } else if (c2 == 47) {\n          return 63;\n        } else {\n          throw \"c:\" + c2;\n        }\n      };\n      return _this;\n    };\n    var gifImage = function(width, height) {\n      var _width = width;\n      var _height = height;\n      var _data = new Array(width * height);\n      var _this = {};\n      _this.setPixel = function(x, y, pixel) {\n        _data[y * _width + x] = pixel;\n      };\n      _this.write = function(out) {\n        out.writeString(\"GIF87a\");\n        out.writeShort(_width);\n        out.writeShort(_height);\n        out.writeByte(128);\n        out.writeByte(0);\n        out.writeByte(0);\n        out.writeByte(0);\n        out.writeByte(0);\n        out.writeByte(0);\n        out.writeByte(255);\n        out.writeByte(255);\n        out.writeByte(255);\n        out.writeString(\",\");\n        out.writeShort(0);\n        out.writeShort(0);\n        out.writeShort(_width);\n        out.writeShort(_height);\n        out.writeByte(0);\n        var lzwMinCodeSize = 2;\n        var raster = getLZWRaster(lzwMinCodeSize);\n        out.writeByte(lzwMinCodeSize);\n        var offset = 0;\n        while (raster.length - offset > 255) {\n          out.writeByte(255);\n          out.writeBytes(raster, offset, 255);\n          offset += 255;\n        }\n        out.writeByte(raster.length - offset);\n        out.writeBytes(raster, offset, raster.length - offset);\n        out.writeByte(0);\n        out.writeString(\";\");\n      };\n      var bitOutputStream = function(out) {\n        var _out = out;\n        var _bitLength = 0;\n        var _bitBuffer = 0;\n        var _this2 = {};\n        _this2.write = function(data, length) {\n          if (data >>> length != 0) {\n            throw \"length over\";\n          }\n          while (_bitLength + length >= 8) {\n            _out.writeByte(255 & (data << _bitLength | _bitBuffer));\n            length -= 8 - _bitLength;\n            data >>>= 8 - _bitLength;\n            _bitBuffer = 0;\n            _bitLength = 0;\n          }\n          _bitBuffer = data << _bitLength | _bitBuffer;\n          _bitLength = _bitLength + length;\n        };\n        _this2.flush = function() {\n          if (_bitLength > 0) {\n            _out.writeByte(_bitBuffer);\n          }\n        };\n        return _this2;\n      };\n      var getLZWRaster = function(lzwMinCodeSize) {\n        var clearCode = 1 << lzwMinCodeSize;\n        var endCode = (1 << lzwMinCodeSize) + 1;\n        var bitLength = lzwMinCodeSize + 1;\n        var table = lzwTable();\n        for (var i2 = 0; i2 < clearCode; i2 += 1) {\n          table.add(String.fromCharCode(i2));\n        }\n        table.add(String.fromCharCode(clearCode));\n        table.add(String.fromCharCode(endCode));\n        var byteOut = byteArrayOutputStream();\n        var bitOut = bitOutputStream(byteOut);\n        bitOut.write(clearCode, bitLength);\n        var dataIndex = 0;\n        var s2 = String.fromCharCode(_data[dataIndex]);\n        dataIndex += 1;\n        while (dataIndex < _data.length) {\n          var c2 = String.fromCharCode(_data[dataIndex]);\n          dataIndex += 1;\n          if (table.contains(s2 + c2)) {\n            s2 = s2 + c2;\n          } else {\n            bitOut.write(table.indexOf(s2), bitLength);\n            if (table.size() < 4095) {\n              if (table.size() == 1 << bitLength) {\n                bitLength += 1;\n              }\n              table.add(s2 + c2);\n            }\n            s2 = c2;\n          }\n        }\n        bitOut.write(table.indexOf(s2), bitLength);\n        bitOut.write(endCode, bitLength);\n        bitOut.flush();\n        return byteOut.toByteArray();\n      };\n      var lzwTable = function() {\n        var _map = {};\n        var _size = 0;\n        var _this2 = {};\n        _this2.add = function(key) {\n          if (_this2.contains(key)) {\n            throw \"dup key:\" + key;\n          }\n          _map[key] = _size;\n          _size += 1;\n        };\n        _this2.size = function() {\n          return _size;\n        };\n        _this2.indexOf = function(key) {\n          return _map[key];\n        };\n        _this2.contains = function(key) {\n          return typeof _map[key] != \"undefined\";\n        };\n        return _this2;\n      };\n      return _this;\n    };\n    var createDataURL = function(width, height, getPixel) {\n      var gif = gifImage(width, height);\n      for (var y = 0; y < height; y += 1) {\n        for (var x = 0; x < width; x += 1) {\n          gif.setPixel(x, y, getPixel(x, y));\n        }\n      }\n      var b = byteArrayOutputStream();\n      gif.write(b);\n      var base64 = base64EncodeOutputStream();\n      var bytes = b.toByteArray();\n      for (var i2 = 0; i2 < bytes.length; i2 += 1) {\n        base64.writeByte(bytes[i2]);\n      }\n      base64.flush();\n      return \"data:image/gif;base64,\" + base64;\n    };\n    return qrcode3;\n  }();\n  !function() {\n    qrcode2.stringToBytesFuncs[\"UTF-8\"] = function(s2) {\n      function toUTF8Array(str) {\n        var utf8 = [];\n        for (var i2 = 0; i2 < str.length; i2++) {\n          var charcode = str.charCodeAt(i2);\n          if (charcode < 128)\n            utf8.push(charcode);\n          else if (charcode < 2048) {\n            utf8.push(\n              192 | charcode >> 6,\n              128 | charcode & 63\n            );\n          } else if (charcode < 55296 || charcode >= 57344) {\n            utf8.push(\n              224 | charcode >> 12,\n              128 | charcode >> 6 & 63,\n              128 | charcode & 63\n            );\n          } else {\n            i2++;\n            charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i2) & 1023);\n            utf8.push(\n              240 | charcode >> 18,\n              128 | charcode >> 12 & 63,\n              128 | charcode >> 6 & 63,\n              128 | charcode & 63\n            );\n          }\n        }\n        return utf8;\n      }\n      return toUTF8Array(s2);\n    };\n  }();\n  (function(factory) {\n    {\n      module.exports = factory();\n    }\n  })(function() {\n    return qrcode2;\n  });\n})(qrcode$1);\nconst qrcode = qrcode$1.exports;\nfunction copyToClipboard(text) {\n  if (navigator == null ? void 0 : navigator.clipboard) {\n    return navigator.clipboard.writeText(text);\n  }\n  fallbackCopyTextToClipboard(text);\n  return Promise.resolve();\n}\nfunction fallbackCopyTextToClipboard(text) {\n  const textArea = document.createElement(\"textarea\");\n  textArea.value = text;\n  textArea.style.top = \"0\";\n  textArea.style.left = \"0\";\n  textArea.style.position = \"fixed\";\n  document.body.appendChild(textArea);\n  textArea.focus();\n  textArea.select();\n  try {\n    document.execCommand(\"copy\");\n  } finally {\n    document.body.removeChild(textArea);\n  }\n}\nvar deepReadObject = (obj, path, defaultValue) => {\n  const value = path.trim().split(\".\").reduce((a2, b) => a2 ? a2[b] : void 0, obj);\n  return value !== void 0 ? value : defaultValue;\n};\nvar template = (str, params, reg = /{{(.*?)}}/g) => str.replace(reg, (_, key) => deepReadObject(params, key, \"\"));\nvar createI18nContext = (init = {}, lang = navigator.language in init ? navigator.language : Object.keys(init)[0]) => {\n  const [locale, setLocale] = createSignal(lang);\n  const [dict, setDict] = createStore(init);\n  const translate = (key, params, defaultValue) => {\n    const val = deepReadObject(dict[locale()], key, defaultValue || \"\");\n    if (typeof val === \"function\")\n      return val(params);\n    if (typeof val === \"string\")\n      return template(val, params || {});\n    return val;\n  };\n  const actions = {\n    add(lang2, table) {\n      setDict(lang2, (t2) => Object.assign(t2 || {}, table));\n    },\n    locale: (lang2) => lang2 ? setLocale(lang2) : locale(),\n    dict: (lang2) => deepReadObject(dict, lang2)\n  };\n  return [translate, actions];\n};\nvar I18nContext = createContext({});\nvar useI18n = () => useContext(I18nContext);\nconst Translation = (props) => {\n  const [t2] = useI18n();\n  return createMemo(() => {\n    var _a;\n    return t2(props.translationKey, props.translationValues, (_a = props.children) == null ? void 0 : _a.toString());\n  });\n};\nconst _tmpl$$d = /* @__PURE__ */ template$1(`<div></div>`);\nconst copyText = {\n  translationKey: \"common.copyLink\",\n  text: \"Copy Link\"\n};\nconst copiedText = {\n  translationKey: \"common.copied\",\n  text: \"Copied!\"\n};\nconst QRCode = (props) => {\n  let qrCodeCanvasRef;\n  let qrCodeWrapperRef;\n  let imageRef;\n  const [copyButtonOpened, setCopyButtonOpened] = createSignal(false);\n  const [copyButtonHovered, setCopyButtonHovered] = createSignal(false);\n  const [qrHovered, setQrHovered] = createSignal(false);\n  const [copyButtonText, setCopyButtonText] = createSignal(copyText);\n  const [picSize, setPicSize] = createSignal(picSizeDefault);\n  createEffect(() => setCopyButtonOpened(copyButtonHovered() || qrHovered()));\n  createEffect(() => !copyButtonOpened() && setCopyButtonText(copyText));\n  createEffect(() => {\n    const errorCorrectionLevel = \"L\";\n    const cellSize = 4;\n    const qr = qrcode(0, errorCorrectionLevel);\n    qr.addData(props.sourceUrl);\n    qr.make();\n    qrCodeCanvasRef.innerHTML = qr.createSvgTag(cellSize, 0);\n    const qrSize = qrCodeCanvasRef.firstElementChild.clientWidth;\n    const scale = Math.round(qrNormalSize / qrSize * 1e5) / 1e5;\n    if (imageRef) {\n      const imgSize = Math.ceil(imgSizeDefault / (scale * cellSize)) * cellSize;\n      const imgOffset = toPx(Math.ceil((qrSize - imgSize) / (2 * cellSize)) * cellSize);\n      imageRef.style.top = imgOffset;\n      imageRef.style.left = imgOffset;\n      imageRef.style.height = toPx(imgSize);\n      imageRef.style.width = toPx(imgSize);\n      setPicSize(Math.round(picSizeDefault / scale));\n    }\n    qrCodeWrapperRef.style.transform = `scale(${scale})`;\n  });\n  let timeoutId = null;\n  const onCopyClick = () => {\n    copyToClipboard(props.sourceUrl);\n    setCopyButtonText(copiedText);\n    if (timeoutId != null) {\n      clearTimeout(timeoutId);\n    }\n    timeoutId = setTimeout(() => setCopyButtonText(copyText), 3e3);\n  };\n  return createComponent(QrCodeBackground, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    get children() {\n      return [createComponent(QrCodeWrapper, {\n        ref(r$) {\n          const _ref$ = qrCodeWrapperRef;\n          typeof _ref$ === \"function\" ? _ref$(r$) : qrCodeWrapperRef = r$;\n        },\n        onMouseEnter: () => setQrHovered(true),\n        onMouseLeave: () => setTimeout(() => setQrHovered(false)),\n        get children() {\n          return [(() => {\n            const _el$ = _tmpl$$d.cloneNode(true);\n            const _ref$2 = qrCodeCanvasRef;\n            typeof _ref$2 === \"function\" ? use(_ref$2, _el$) : qrCodeCanvasRef = _el$;\n            return _el$;\n          })(), createComponent(Show, {\n            get when() {\n              return props.imageUrl;\n            },\n            get children() {\n              return createComponent(ImageBackground, {\n                ref(r$) {\n                  const _ref$3 = imageRef;\n                  typeof _ref$3 === \"function\" ? _ref$3(r$) : imageRef = r$;\n                },\n                get children() {\n                  return createComponent(ImageStyled$2, {\n                    get src() {\n                      return props.imageUrl;\n                    },\n                    alt: \"\",\n                    get size() {\n                      return picSize();\n                    }\n                  });\n                }\n              });\n            }\n          })];\n        }\n      }), createComponent(Transition, {\n        onBeforeEnter: (el) => {\n          el.animate([{\n            opacity: 0,\n            transform: \"translate(-50%, 44px)\"\n          }, {\n            opacity: 1,\n            transform: \"translate(-50%, 0)\"\n          }], {\n            duration: 200\n          });\n        },\n        onExit: (el, done) => {\n          el.animate([{\n            opacity: 1,\n            transform: \"translate(-50%, 0)\"\n          }, {\n            opacity: 0,\n            transform: \"translate(-50%, 44px)\"\n          }], {\n            duration: 200\n          }).finished.then(() => {\n            done();\n          });\n        },\n        get children() {\n          return createComponent(Show, {\n            get when() {\n              return copyButtonOpened() && !props.disableCopy;\n            },\n            get children() {\n              return createComponent(CopyButtonStyled, {\n                onClick: onCopyClick,\n                onMouseEnter: () => copyButtonOpened() && setCopyButtonHovered(true),\n                onMouseLeave: () => setTimeout(() => setCopyButtonHovered(false)),\n                get children() {\n                  return createComponent(Translation, {\n                    get translationKey() {\n                      return copyButtonText().translationKey;\n                    },\n                    get children() {\n                      return copyButtonText().text;\n                    }\n                  });\n                }\n              });\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nconst TextStyled$3 = styled.div`\n    font-style: normal;\n    font-weight: ${(props) => props.fontWeight};\n    font-size: ${(props) => props.fontSize};\n    line-height: ${(props) => props.lineHeight};\n\n    color: ${(props) => props.color};\n`;\nconst Text = (inputs) => {\n  const theme = useTheme();\n  const [t2] = useI18n();\n  let textRef;\n  const color = () => inputs.color || theme.colors.text.primary;\n  const props = mergeProps({\n    fontSize: \"14px\",\n    fontWeight: \"510\",\n    lineHeight: \"130%\"\n  }, inputs);\n  createEffect(() => {\n    if (!textRef) {\n      return;\n    }\n    if (props.cursor === \"unset\") {\n      return;\n    }\n    if (getComputedStyle(textRef).cursor !== \"pointer\") {\n      textRef.style.cursor = \"default\";\n    }\n  });\n  return createComponent(TextStyled$3, {\n    get fontSize() {\n      return props.fontSize;\n    },\n    get fontWeight() {\n      return props.fontWeight;\n    },\n    get lineHeight() {\n      return props.lineHeight;\n    },\n    get color() {\n      return color();\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    ref(r$) {\n      const _ref$ = textRef;\n      typeof _ref$ === \"function\" ? _ref$(r$) : textRef = r$;\n    },\n    \"data-tc-text\": \"true\",\n    get children() {\n      var _a;\n      return createMemo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a = props.children) == null ? void 0 : _a.toString()) : props.children;\n    }\n  });\n};\nconst WalletItemStyled = styled.button`\n    cursor: pointer;\n    border: none;\n    background-color: unset;\n    padding: 12px 8px 8px;\n    height: 94px;\n    width: 92px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n\n    transition: transform 0.125s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${media(\"mobile\")} {\n        padding: 8px 4px;\n        height: 124px;\n        width: 82px;\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst ImageStyled$1 = styled(Image)`\n    width: 48px;\n    height: 48px;\n    border-radius: 12px;\n\n    margin-bottom: 8px;\n\n    ${media(\"mobile\")} {\n        width: 64px;\n        height: 64px;\n        border-radius: 16px;\n    }\n`;\nconst StyledText = styled(Text)`\n    font-weight: 590;\n    max-width: 76px;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n`;\nconst WalletItem = (props) => {\n  return createComponent(WalletItemStyled, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    onClick: () => props.onClick(),\n    \"data-tc-wallet-item\": \"true\",\n    get children() {\n      return [createComponent(ImageStyled$1, {\n        get src() {\n          return props.iconUrl;\n        },\n        alt: \"\"\n      }), createComponent(StyledText, {\n        get children() {\n          return props.name;\n        }\n      })];\n    }\n  });\n};\nconst H1Styled$3 = styled.h1`\n    font-style: normal;\n    font-weight: 700;\n    font-size: 24px;\n    line-height: 30px;\n\n    text-align: center;\n\n    color: ${(props) => props.theme.colors.text.primary};\n\n    margin-top: 0;\n    margin-bottom: 6px;\n\n    cursor: default;\n`;\nconst H1 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H1Styled$3, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-h1\": \"true\",\n    get children() {\n      var _a;\n      return createMemo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a = props.children) == null ? void 0 : _a.toString()) : props.children;\n    }\n  });\n};\nconst H2Styled$3 = styled.h2`\n    font-style: normal;\n    font-weight: 510;\n    font-size: 16px;\n    line-height: 20px;\n\n    text-align: center;\n\n    color: ${(props) => props.theme.colors.text.secondary};\n\n    margin-top: 0;\n    margin-bottom: 32px;\n\n    cursor: default;\n`;\nconst H2 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H2Styled$3, {\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-h2\": \"true\",\n    get children() {\n      var _a;\n      return createMemo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a = props.children) == null ? void 0 : _a.toString()) : props.children;\n    }\n  });\n};\nconst H3Styled = styled.h3`\n    font-style: normal;\n    font-weight: 590;\n    font-size: 15px;\n    line-height: 20px;\n\n    color: ${(props) => props.theme.colors.text.primary};\n\n    margin-top: 0;\n    margin-bottom: 0;\n\n    cursor: default;\n`;\nconst H3 = (props) => {\n  const [t2] = useI18n();\n  return createComponent(H3Styled, {\n    \"data-tc-h3\": \"true\",\n    get children() {\n      var _a;\n      return createMemo(() => !!props.translationKey)() ? t2(props.translationKey, props.translationValues, (_a = props.children) == null ? void 0 : _a.toString()) : props.children;\n    }\n  });\n};\nconst _tmpl$$c = /* @__PURE__ */ template$1(`<svg width=\"18\" height=\"17\" viewBox=\"0 0 18 17\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M1.5 15.999L16.5 0.999023M16.5 0.999023V12.999M16.5 0.999023H4.5\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>`);\nconst LongArrowIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.secondary;\n  return (() => {\n    const _el$ = _tmpl$$c.cloneNode(true), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"stroke\", fill()));\n    return _el$;\n  })();\n};\nconst _tmpl$$b = /* @__PURE__ */ template$1(`<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M14.1839 17.7069C13.6405 18.6507 13.3688 19.1226 13.0591 19.348C12.4278 19.8074 11.5723 19.8074 10.941 19.348C10.6312 19.1226 10.3595 18.6507 9.81613 17.7069L5.52066 10.2464C4.76864 8.94024 4.39263 8.28717 4.33762 7.75894C4.2255 6.68236 4.81894 5.65591 5.80788 5.21589C6.29309 5 7.04667 5 8.55383 5H15.4462C16.9534 5 17.7069 5 18.1922 5.21589C19.1811 5.65591 19.7745 6.68236 19.6624 7.75894C19.6074 8.28717 19.2314 8.94024 18.4794 10.2464L14.1839 17.7069ZM11.1 16.3412L6.56139 8.48002C6.31995 8.06185 6.19924 7.85276 6.18146 7.68365C6.14523 7.33896 6.33507 7.01015 6.65169 6.86919C6.80703 6.80002 7.04847 6.80002 7.53133 6.80002H7.53134L11.1 6.80002V16.3412ZM12.9 16.3412L17.4387 8.48002C17.6801 8.06185 17.8008 7.85276 17.8186 7.68365C17.8548 7.33896 17.665 7.01015 17.3484 6.86919C17.193 6.80002 16.9516 6.80002 16.4687 6.80002L12.9 6.80002V16.3412Z\"></path></svg>`);\nconst TonIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    const _el$ = _tmpl$$b.cloneNode(true), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nconst _tmpl$$a = /* @__PURE__ */ template$1(`<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\"></circle><path d=\"M17.1364 9.6364C17.4879 9.28493 17.4879 8.71508 17.1364 8.36361C16.7849 8.01214 16.2151 8.01214 15.8636 8.36361L10 14.2272L8.1364 12.3636C7.78493 12.0121 7.21508 12.0121 6.86361 12.3636C6.51214 12.7151 6.51214 13.2849 6.86361 13.6364L9.36361 16.1364C9.71508 16.4879 10.2849 16.4879 10.6364 16.1364L17.1364 9.6364Z\"></path></svg>`), _tmpl$2$3 = /* @__PURE__ */ template$1(`<svg width=\"72\" height=\"72\" viewBox=\"0 0 72 72\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"36\" cy=\"36\" r=\"33\"></circle><path d=\"M50.9142 28.4142C51.6953 27.6332 51.6953 26.3668 50.9142 25.5858C50.1332 24.8047 48.8668 24.8047 48.0858 25.5858L30 43.6716L23.9142 37.5858C23.1332 36.8047 21.8668 36.8047 21.0858 37.5858C20.3047 38.3668 20.3047 39.6332 21.0858 40.4142L28.5858 47.9142C29.3668 48.6953 30.6332 48.6953 31.4142 47.9142L50.9142 28.4142Z\"></path></svg>`);\nconst SuccessIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"s\";\n  const fill = () => props.fill || theme.colors.icon.success;\n  return createMemo((() => {\n    const _c$ = createMemo(() => size() === \"s\");\n    return () => _c$() ? (() => {\n      const _el$ = _tmpl$$a.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n      createRenderEffect((_p$) => {\n        const _v$ = props.class, _v$2 = fill(), _v$3 = theme.colors.constant.white;\n        _v$ !== _p$._v$ && setAttribute(_el$, \"class\", _p$._v$ = _v$);\n        _v$2 !== _p$._v$2 && setAttribute(_el$2, \"fill\", _p$._v$2 = _v$2);\n        _v$3 !== _p$._v$3 && setAttribute(_el$3, \"fill\", _p$._v$3 = _v$3);\n        return _p$;\n      }, {\n        _v$: void 0,\n        _v$2: void 0,\n        _v$3: void 0\n      });\n      return _el$;\n    })() : (() => {\n      const _el$4 = _tmpl$2$3.cloneNode(true), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;\n      createRenderEffect((_p$) => {\n        const _v$4 = props.class, _v$5 = fill(), _v$6 = theme.colors.constant.white;\n        _v$4 !== _p$._v$4 && setAttribute(_el$4, \"class\", _p$._v$4 = _v$4);\n        _v$5 !== _p$._v$5 && setAttribute(_el$5, \"fill\", _p$._v$5 = _v$5);\n        _v$6 !== _p$._v$6 && setAttribute(_el$6, \"fill\", _p$._v$6 = _v$6);\n        return _p$;\n      }, {\n        _v$4: void 0,\n        _v$5: void 0,\n        _v$6: void 0\n      });\n      return _el$4;\n    })();\n  })());\n};\nconst _tmpl$$9 = /* @__PURE__ */ template$1(`<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"12\" cy=\"12\" r=\"11\"></circle><path d=\"M7.86361 9.1364C7.51214 8.78493 7.51214 8.21508 7.86361 7.86361C8.21508 7.51214 8.78493 7.51214 9.1364 7.86361L12 10.7272L14.8636 7.86361C15.2151 7.51214 15.7849 7.51214 16.1364 7.86361C16.4879 8.21508 16.4879 8.78493 16.1364 9.1364L13.2728 12L16.1364 14.8636C16.4879 15.2151 16.4879 15.7849 16.1364 16.1364C15.7849 16.4879 15.2151 16.4879 14.8636 16.1364L12 13.2728L9.1364 16.1364C8.78493 16.4879 8.21508 16.4879 7.86361 16.1364C7.51214 15.7849 7.51214 15.2151 7.86361 14.8636L10.7272 12L7.86361 9.1364Z\"></path></svg>`), _tmpl$2$2 = /* @__PURE__ */ template$1(`<svg width=\"72\" height=\"72\" viewBox=\"0 0 72 72\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"36\" cy=\"36\" r=\"33\"></circle><path d=\"M24.0858 26.9142C23.3047 26.1332 23.3047 24.8668 24.0858 24.0858C24.8668 23.3047 26.1332 23.3047 26.9142 24.0858L36 33.1716L45.0858 24.0858C45.8668 23.3047 47.1332 23.3047 47.9142 24.0858C48.6953 24.8668 48.6953 26.1332 47.9142 26.9142L38.8284 36L47.9142 45.0858C48.6953 45.8668 48.6953 47.1332 47.9142 47.9142C47.1332 48.6953 45.8668 48.6953 45.0858 47.9142L36 38.8284L26.9142 47.9142C26.1332 48.6953 24.8668 48.6953 24.0858 47.9142C23.3047 47.1332 23.3047 45.8668 24.0858 45.0858L33.1716 36L24.0858 26.9142Z\"></path></svg>`);\nconst ErrorIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"s\";\n  const fill = () => props.fill || theme.colors.icon.error;\n  return createMemo((() => {\n    const _c$ = createMemo(() => size() === \"s\");\n    return () => _c$() ? (() => {\n      const _el$ = _tmpl$$9.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n      createRenderEffect((_p$) => {\n        const _v$ = props.class, _v$2 = fill(), _v$3 = theme.colors.constant.white;\n        _v$ !== _p$._v$ && setAttribute(_el$, \"class\", _p$._v$ = _v$);\n        _v$2 !== _p$._v$2 && setAttribute(_el$2, \"fill\", _p$._v$2 = _v$2);\n        _v$3 !== _p$._v$3 && setAttribute(_el$3, \"fill\", _p$._v$3 = _v$3);\n        return _p$;\n      }, {\n        _v$: void 0,\n        _v$2: void 0,\n        _v$3: void 0\n      });\n      return _el$;\n    })() : (() => {\n      const _el$4 = _tmpl$2$2.cloneNode(true), _el$5 = _el$4.firstChild, _el$6 = _el$5.nextSibling;\n      createRenderEffect((_p$) => {\n        const _v$4 = props.class, _v$5 = fill(), _v$6 = theme.colors.constant.white;\n        _v$4 !== _p$._v$4 && setAttribute(_el$4, \"class\", _p$._v$4 = _v$4);\n        _v$5 !== _p$._v$5 && setAttribute(_el$5, \"fill\", _p$._v$5 = _v$5);\n        _v$6 !== _p$._v$6 && setAttribute(_el$6, \"fill\", _p$._v$6 = _v$6);\n        return _p$;\n      }, {\n        _v$4: void 0,\n        _v$5: void 0,\n        _v$6: void 0\n      });\n      return _el$4;\n    })();\n  })());\n};\nconst _tmpl$$8 = /* @__PURE__ */ template$1(`<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M15.55 5.85123C18.9459 7.81184 20.1094 12.1541 18.1488 15.55C16.1882 18.9459 11.8459 20.1094 8.44998 18.1488C8.01952 17.9003 7.46909 18.0478 7.22056 18.4782C6.97203 18.9087 7.11952 19.4591 7.54998 19.7076C11.8068 22.1653 17.2499 20.7068 19.7076 16.45C22.1653 12.1932 20.7068 6.75005 16.45 4.29239C12.1932 1.83472 6.75003 3.29321 4.29236 7.55001C4.04383 7.98047 4.19132 8.53091 4.62178 8.77943C5.05224 9.02796 5.60268 8.88048 5.8512 8.45001C7.81181 5.05413 12.1541 3.89062 15.55 5.85123Z\"></path></svg>`), _tmpl$2$1 = /* @__PURE__ */ template$1(`<svg width=\"72\" height=\"72\" viewBox=\"0 0 72 72\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M24 56.7846C35.479 63.412 50.1572 59.479 56.7846 47.9999C63.412 36.5209 59.479 21.8427 48 15.2153C36.521 8.58791 21.8428 12.5209 15.2154 23.9999\" stroke-width=\"4\" stroke-linecap=\"round\" stroke-linejoin=\"round\"></path></svg>`);\nconst LoaderIcon = (props) => {\n  const theme = useTheme();\n  const size = () => props.size || \"s\";\n  const fill = () => props.fill || theme.colors.icon.tertiary;\n  const rotateAnimation = h`\n        0% {\n          transform: rotate(0deg);\n        }\n        100% {\n          transform: rotate(360deg);\n        }\n    `;\n  const svgClass = u`\n        animation: ${rotateAnimation} 1s linear infinite;\n    `;\n  return createMemo((() => {\n    const _c$ = createMemo(() => size() === \"s\");\n    return () => _c$() ? (() => {\n      const _el$ = _tmpl$$8.cloneNode(true), _el$2 = _el$.firstChild;\n      createRenderEffect((_p$) => {\n        const _v$ = classnames__WEBPACK_IMPORTED_MODULE_3___default()(svgClass, props.class), _v$2 = fill();\n        _v$ !== _p$._v$ && setAttribute(_el$, \"class\", _p$._v$ = _v$);\n        _v$2 !== _p$._v$2 && setAttribute(_el$2, \"fill\", _p$._v$2 = _v$2);\n        return _p$;\n      }, {\n        _v$: void 0,\n        _v$2: void 0\n      });\n      return _el$;\n    })() : (() => {\n      const _el$3 = _tmpl$2$1.cloneNode(true), _el$4 = _el$3.firstChild;\n      createRenderEffect((_p$) => {\n        const _v$3 = classnames__WEBPACK_IMPORTED_MODULE_3___default()(svgClass, props.class), _v$4 = fill();\n        _v$3 !== _p$._v$3 && setAttribute(_el$3, \"class\", _p$._v$3 = _v$3);\n        _v$4 !== _p$._v$4 && setAttribute(_el$4, \"stroke\", _p$._v$4 = _v$4);\n        return _p$;\n      }, {\n        _v$3: void 0,\n        _v$4: void 0\n      });\n      return _el$3;\n    })();\n  })());\n};\nconst TonConnectUiContext = createContext();\nconst _tmpl$$7 = /* @__PURE__ */ template$1(`<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M7.76228 2.09998H10.2378C11.0458 2.09997 11.7067 2.09996 12.2438 2.14384C12.7997 2.18926 13.3017 2.28614 13.7706 2.52505C14.5045 2.89896 15.1011 3.49558 15.475 4.22941C15.7139 4.6983 15.8108 5.20038 15.8562 5.75629C15.9001 6.29337 15.9001 6.95422 15.9001 7.76227V8.1H16.2377C17.0457 8.09999 17.7066 8.09998 18.2437 8.14386C18.7996 8.18928 19.3017 8.28616 19.7705 8.52507C20.5044 8.89898 21.101 9.4956 21.4749 10.2294C21.7138 10.6983 21.8107 11.2004 21.8561 11.7563C21.9 12.2934 21.9 12.9542 21.9 13.7623V16.2377C21.9 17.0458 21.9 17.7066 21.8561 18.2437C21.8107 18.7996 21.7138 19.3017 21.4749 19.7706C21.101 20.5044 20.5044 21.101 19.7705 21.4749C19.3017 21.7138 18.7996 21.8107 18.2437 21.8561C17.7066 21.9 17.0458 21.9 16.2378 21.9H13.7623C12.9543 21.9 12.2934 21.9 11.7563 21.8561C11.2004 21.8107 10.6983 21.7138 10.2294 21.4749C9.49561 21.101 8.89898 20.5044 8.52508 19.7706C8.28616 19.3017 8.18928 18.7996 8.14386 18.2437C8.09998 17.7066 8.09999 17.0458 8.1 16.2377V15.9H7.76227C6.95426 15.9 6.29335 15.9 5.75629 15.8561C5.20038 15.8107 4.6983 15.7138 4.22941 15.4749C3.49558 15.101 2.89896 14.5044 2.52505 13.7705C2.28614 13.3017 2.18926 12.7996 2.14384 12.2437C2.09996 11.7066 2.09997 11.0458 2.09998 10.2377V7.76228C2.09997 6.95424 2.09996 6.29336 2.14384 5.75629C2.18926 5.20038 2.28614 4.6983 2.52505 4.22941C2.89896 3.49558 3.49558 2.89896 4.22941 2.52505C4.6983 2.28614 5.20038 2.18926 5.75629 2.14384C6.29336 2.09996 6.95425 2.09997 7.76228 2.09998ZM8.1 14.1V13.7623C8.09999 12.9542 8.09998 12.2934 8.14386 11.7563C8.18928 11.2004 8.28616 10.6983 8.52508 10.2294C8.89898 9.4956 9.49561 8.89898 10.2294 8.52507C10.6983 8.28616 11.2004 8.18928 11.7563 8.14386C12.2934 8.09998 12.9542 8.09999 13.7623 8.1H14.1001V7.79998C14.1001 6.94505 14.0994 6.35798 14.0622 5.90287C14.0259 5.45827 13.9593 5.21944 13.8712 5.0466C13.6699 4.65146 13.3486 4.3302 12.9535 4.12886C12.7806 4.04079 12.5418 3.97419 12.0972 3.93786C11.6421 3.90068 11.055 3.89998 10.2001 3.89998H7.79998C6.94505 3.89998 6.35798 3.90068 5.90287 3.93786C5.45827 3.97419 5.21944 4.04079 5.0466 4.12886C4.65146 4.3302 4.3302 4.65146 4.12886 5.0466C4.04079 5.21944 3.97419 5.45827 3.93786 5.90287C3.90068 6.35798 3.89998 6.94505 3.89998 7.79998V10.2C3.89998 11.0549 3.90068 11.642 3.93786 12.0971C3.97419 12.5417 4.04079 12.7805 4.12886 12.9534C4.3302 13.3485 4.65146 13.6698 5.0466 13.8711C5.21944 13.9592 5.45827 14.0258 5.90287 14.0621C6.35798 14.0993 6.94505 14.1 7.79998 14.1H8.1ZM11.0466 10.1289C11.2195 10.0408 11.4583 9.97421 11.9029 9.93788C12.358 9.9007 12.9451 9.9 13.8 9.9H16.2C17.0549 9.9 17.642 9.9007 18.0971 9.93788C18.5417 9.97421 18.7805 10.0408 18.9534 10.1289C19.3485 10.3302 19.6698 10.6515 19.8711 11.0466C19.9592 11.2195 20.0258 11.4583 20.0621 11.9029C20.0993 12.358 20.1 12.9451 20.1 13.8V16.2C20.1 17.0549 20.0993 17.642 20.0621 18.0971C20.0258 18.5417 19.9592 18.7805 19.8711 18.9534C19.6698 19.3485 19.3485 19.6698 18.9534 19.8711C18.7805 19.9592 18.5417 20.0258 18.0971 20.0621C17.642 20.0993 17.0549 20.1 16.2 20.1H13.8C12.9451 20.1 12.358 20.0993 11.9029 20.0621C11.4583 20.0258 11.2195 19.9592 11.0466 19.8711C10.6515 19.6698 10.3302 19.3485 10.1289 18.9534C10.0408 18.7805 9.97421 18.5417 9.93788 18.0971C9.9007 17.642 9.9 17.0549 9.9 16.2V13.8C9.9 12.9451 9.9007 12.358 9.93788 11.9029C9.97421 11.4583 10.0408 11.2195 10.1289 11.0466C10.3302 10.6515 10.6515 10.3302 11.0466 10.1289Z\"></path></svg>`);\nconst CopyIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    const _el$ = _tmpl$$7.cloneNode(true), _el$2 = _el$.firstChild;\n    createRenderEffect(() => setAttribute(_el$2, \"fill\", fill()));\n    return _el$;\n  })();\n};\nconst _tmpl$$6 = /* @__PURE__ */ template$1(`<svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.7624 3.10001C7.95435 3.1 7.29349 3.09999 6.75642 3.14387C6.2005 3.18929 5.69842 3.28617 5.22954 3.52508C4.4957 3.89899 3.89908 4.49561 3.52517 5.22944C3.28626 5.69833 3.18938 6.20041 3.14396 6.75632C3.10008 7.2934 3.10009 7.95424 3.1001 8.76229V15.2377C3.10009 16.0458 3.10008 16.7066 3.14396 17.2437C3.18938 17.7996 3.28626 18.3017 3.52517 18.7706C3.89908 19.5044 4.4957 20.101 5.22954 20.4749C5.69842 20.7138 6.2005 20.8107 6.75642 20.8561C7.29349 20.9 7.95434 20.9 8.76239 20.9H12.0001C12.4972 20.9 12.9001 20.4971 12.9001 20C12.9001 19.503 12.4972 19.1 12.0001 19.1H8.8001C7.94517 19.1 7.3581 19.0993 6.90299 19.0621C6.45839 19.0258 6.21956 18.9592 6.04672 18.8711C5.65158 18.6698 5.33032 18.3485 5.12898 17.9534C5.04092 17.7805 4.97431 17.5417 4.93798 17.0971C4.9008 16.642 4.9001 16.0549 4.9001 15.2V8.80001C4.9001 7.94508 4.9008 7.35801 4.93798 6.9029C4.97431 6.4583 5.04092 6.21947 5.12898 6.04663C5.33032 5.65149 5.65158 5.33023 6.04672 5.12889C6.21956 5.04082 6.45839 4.97422 6.90299 4.93789C7.3581 4.90071 7.94517 4.90001 8.8001 4.90001H12.0001C12.4972 4.90001 12.9001 4.49706 12.9001 4.00001C12.9001 3.50295 12.4972 3.10001 12.0001 3.10001H8.7624Z\"></path><path d=\"M17.6364 7.3636C17.2849 7.01212 16.7151 7.01212 16.3636 7.3636C16.0121 7.71507 16.0121 8.28492 16.3636 8.63639L18.8272 11.1H9.00001C8.50295 11.1 8.10001 11.5029 8.10001 12C8.10001 12.497 8.50295 12.9 9.00001 12.9H18.8272L16.3636 15.3636C16.0121 15.7151 16.0121 16.2849 16.3636 16.6364C16.7151 16.9879 17.2849 16.9879 17.6364 16.6364L21.6364 12.6364C21.9879 12.2849 21.9879 11.7151 21.6364 11.3636L17.6364 7.3636Z\"></path></svg>`);\nconst DisconnectIcon = (props) => {\n  const theme = useTheme();\n  const fill = () => props.fill || theme.colors.icon.primary;\n  return (() => {\n    const _el$ = _tmpl$$6.cloneNode(true), _el$2 = _el$.firstChild, _el$3 = _el$2.nextSibling;\n    createRenderEffect((_p$) => {\n      const _v$ = fill(), _v$2 = fill();\n      _v$ !== _p$._v$ && setAttribute(_el$2, \"fill\", _p$._v$ = _v$);\n      _v$2 !== _p$._v$2 && setAttribute(_el$3, \"fill\", _p$._v$2 = _v$2);\n      return _p$;\n    }, {\n      _v$: void 0,\n      _v$2: void 0\n    });\n    return _el$;\n  })();\n};\nconst hoverBorders$1 = {\n  m: \"8px\",\n  s: \"4px\",\n  none: \"0\"\n};\nconst dropdownBorders = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst AccountButtonDropdownStyled = styled.div`\n    width: 256px;\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n    border-radius: ${(props) => dropdownBorders[props.theme.borderRadius]};\n\n    background-color: ${(props) => props.theme.colors.background.primary}\n           \n    color: ${(props) => props.theme.colors.text.primary}\n`;\nconst UlStyled$1 = styled.ul`\n    background-color: ${(props) => props.theme.colors.background.primary};\n    padding: 8px;\n`;\nconst MenuButtonStyled = styled.button`\n    display: flex;\n    align-items: center;\n    gap: 8px;\n    height: 40px;\n    padding-left: 8px;\n    width: 100%;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border: none;\n    border-radius: ${(props) => hoverBorders$1[props.theme.borderRadius]};\n    cursor: pointer;\n\n    transition: background-color, transform 0.1s ease-in-out;\n\n    &:hover {\n        background-color: ${(props) => props.theme.colors.background.secondary};\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n`;\nconst _tmpl$$5 = /* @__PURE__ */ template$1(`<li></li>`);\nconst MenuItemText = (props) => createComponent(Text, {\n  get translationKey() {\n    return props.translationKey;\n  },\n  fontSize: \"15px\",\n  fontWeight: \"590\",\n  get children() {\n    return props.children;\n  }\n});\nconst AccountButtonDropdown = (props) => {\n  const tonConnectUi = useContext(TonConnectUiContext);\n  const [isCopiedShown, setIsCopiedShown] = createSignal(false);\n  const onCopy = () => __async(void 0, null, function* () {\n    const userFriendlyAddress = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.toUserFriendlyAddress)(tonConnectUi.account.address, tonConnectUi.account.chain === _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CHAIN.TESTNET);\n    yield copyToClipboard(userFriendlyAddress);\n    setIsCopiedShown(true);\n    setTimeout(() => setIsCopiedShown(false), 1e3);\n  });\n  const onDisconnect = () => {\n    tonConnectUi.disconnect();\n    props.onClose();\n  };\n  return createComponent(AccountButtonDropdownStyled, {\n    ref(r$) {\n      const _ref$ = props.ref;\n      typeof _ref$ === \"function\" ? _ref$(r$) : props.ref = r$;\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-dropdown\": \"true\",\n    get children() {\n      return createComponent(UlStyled$1, {\n        get children() {\n          return [(() => {\n            const _el$ = _tmpl$$5.cloneNode(true);\n            insert(_el$, createComponent(MenuButtonStyled, {\n              onClick: () => onCopy(),\n              get children() {\n                return [createComponent(CopyIcon, {}), createComponent(Show, {\n                  get when() {\n                    return !isCopiedShown();\n                  },\n                  get children() {\n                    return createComponent(MenuItemText, {\n                      translationKey: \"button.dropdown.copy\",\n                      children: \"Copy address\"\n                    });\n                  }\n                }), createComponent(Show, {\n                  get when() {\n                    return isCopiedShown();\n                  },\n                  get children() {\n                    return createComponent(MenuItemText, {\n                      translationKey: \"button.dropdown.copied\",\n                      children: \"Address copied!\"\n                    });\n                  }\n                })];\n              }\n            }));\n            return _el$;\n          })(), (() => {\n            const _el$2 = _tmpl$$5.cloneNode(true);\n            insert(_el$2, createComponent(MenuButtonStyled, {\n              onClick: () => onDisconnect(),\n              get children() {\n                return [createComponent(DisconnectIcon, {}), createComponent(MenuItemText, {\n                  translationKey: \"button.dropdown.disconnect\",\n                  children: \"Disconnect\"\n                })];\n              }\n            }));\n            return _el$2;\n          })()];\n        }\n      });\n    }\n  });\n};\nconst borders$2 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst NotificationStyled = styled.div`\n    width: 256px;\n    padding: 12px 16px;\n    display: flex;\n    gap: 9px;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n    border-radius: ${(props) => borders$2[props.theme.borderRadius]};\n`;\nconst NotificationContentStyled = styled.div`\n    width: 192px;\n`;\nconst TextStyled$2 = styled(Text)`\n    margin-top: 4px;\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst Notification = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  return createComponent(NotificationStyled, mergeProps({\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification\": \"true\"\n  }, dataAttrs, {\n    get children() {\n      return [createComponent(NotificationContentStyled, {\n        get children() {\n          return [createComponent(H3, {\n            get translationKey() {\n              return props.header.translationKey;\n            },\n            get translationValues() {\n              return props.header.translationValues;\n            },\n            get children() {\n              return props.children;\n            }\n          }), createComponent(Show, {\n            get when() {\n              return props.text;\n            },\n            get children() {\n              return createComponent(TextStyled$2, {\n                get translationKey() {\n                  return props.text.translationKey;\n                },\n                get translationValues() {\n                  return props.text.translationValues;\n                }\n              });\n            }\n          })];\n        }\n      }), createMemo(() => props.icon)];\n    }\n  }));\n};\nconst LoaderIconStyled$1 = styled(LoaderIcon)`\n    align-self: center;\n`;\nconst ConfirmOperationNotification = (props) => {\n  var _a;\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = ((_a = tonConnectUI.wallet) == null ? void 0 : _a.name) || t2(\"common.yourWallet\", {}, \"your wallet\");\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.confirm.header\",\n      translationValues: {\n        name\n      }\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    get icon() {\n      return createComponent(LoaderIconStyled$1, {});\n    },\n    \"data-tc-notification-confirm\": \"true\",\n    children: \"Confirm operation in your wallet\"\n  });\n};\nconst ErrorIconStyled = styled(ErrorIcon)`\n    margin-top: 2px;\n`;\nconst ErrorTransactionNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.transactionCanceled.header\"\n    },\n    text: {\n      translationKey: \"notifications.transactionCanceled.text\"\n    },\n    get icon() {\n      return createComponent(ErrorIconStyled, {});\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-tx-cancelled\": \"true\",\n    children: \"Transaction cancelled\"\n  });\n};\nconst SuccessIconStyled = styled(SuccessIcon)`\n    margin-top: 2px;\n`;\nconst SuccessTransactionNotification = (props) => {\n  return createComponent(Notification, {\n    header: {\n      translationKey: \"notifications.transactionSent.header\"\n    },\n    text: {\n      translationKey: \"notifications.transactionSent.text\"\n    },\n    get icon() {\n      return createComponent(SuccessIconStyled, {});\n    },\n    get [\"class\"]() {\n      return props.class;\n    },\n    \"data-tc-notification-tx-sent\": \"true\",\n    children: \"Transaction sent\"\n  });\n};\nconst NotificationClass = u`\n    transform: translateY(-8px);\n    margin-bottom: 12px;\n`;\nconst _tmpl$$4 = /* @__PURE__ */ template$1(`<div data-tc-list-notifications=\"true\"></div>`);\nconst Notifications = (props) => {\n  const timeouts = [];\n  const [openedNotifications, setOpenedNotifications] = createSignal([]);\n  let lastId = -1;\n  const liveTimeoutMs = 4500;\n  createEffect(on(action, (action2) => {\n    if (action2 && action2.showNotification) {\n      lastId++;\n      const id = lastId;\n      setOpenedNotifications((notifications2) => notifications2.filter((notification) => notification.action !== \"confirm-transaction\").concat({\n        id,\n        action: action2.name\n      }));\n      timeouts.push(setTimeout(() => setOpenedNotifications((notifications2) => notifications2.filter((notification) => notification.id !== id)), liveTimeoutMs));\n    }\n  }));\n  onCleanup(() => {\n    timeouts.forEach(clearTimeout);\n  });\n  return (() => {\n    const _el$ = _tmpl$$4.cloneNode(true);\n    insert(_el$, createComponent(TransitionGroup, {\n      onBeforeEnter: (el) => {\n        el.animate([{\n          opacity: 0,\n          transform: \"translateY(0)\"\n        }, {\n          opacity: 1,\n          transform: \"translateY(-8px)\"\n        }], {\n          duration: 200\n        });\n      },\n      onExit: (el, done) => {\n        const a2 = el.animate([{\n          opacity: 1,\n          transform: \"translateY(-8px)\"\n        }, {\n          opacity: 0,\n          transform: \"translateY(-30px)\"\n        }], {\n          duration: 200\n        });\n        a2.finished.then(done);\n      },\n      get children() {\n        return createComponent(For, {\n          get each() {\n            return openedNotifications();\n          },\n          children: (openedNotification) => createComponent(Switch, {\n            get children() {\n              return [createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"transaction-sent\";\n                },\n                get children() {\n                  return createComponent(SuccessTransactionNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"transaction-canceled\";\n                },\n                get children() {\n                  return createComponent(ErrorTransactionNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              }), createComponent(Match, {\n                get when() {\n                  return openedNotification.action === \"confirm-transaction\";\n                },\n                get children() {\n                  return createComponent(ConfirmOperationNotification, {\n                    \"class\": NotificationClass\n                  });\n                }\n              })];\n            }\n          })\n        });\n      }\n    }));\n    createRenderEffect(() => className(_el$, props.class));\n    return _el$;\n  })();\n};\nconst AccountButtonStyled = styled(Button)`\n    background-color: ${(props) => props.theme.colors.connectButton.background};\n    color: ${(props) => props.theme.colors.connectButton.foreground};\n    box-shadow: ${(props) => `0 4px 24px ${rgba(props.theme.colors.constant.black, 0.16)}`};\n    padding: 8px 16px 8px 12px;\n\n    display: flex;\n    align-items: center;\n    gap: 4px;\n    height: 40px;\n`;\nconst DropdownButtonStyled = styled(AccountButtonStyled)`\n    padding: 12px 16px;\n    min-width: 148px;\n    justify-content: center;\n    background-color: ${(props) => props.theme.colors.background.primary};\n`;\nconst LoaderButtonStyled = styled(Button)`\n    min-width: 148px;\n    height: 40px;\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    color: ${(props) => props.theme.colors.connectButton.foreground};\n    box-shadow: ${(props) => `0 4px 24px ${rgba(props.theme.colors.constant.black, 0.16)}`};\n\n    display: flex;\n    align-items: center;\n    justify-content: center;\n`;\nconst LoaderIconStyled = styled(LoaderIcon)`\n    height: 18px;\n    width: 18px;\n`;\nconst DropdownContainerStyled = styled.div`\n    width: fit-content;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-end;\n`;\nconst DropdownStyled = styled(AccountButtonDropdown)`\n    box-sizing: border-box;\n    overflow: hidden;\n    margin-top: 12px;\n`;\nconst NotificationsStyled = styled(Notifications)`\n    > div:first-child {\n        margin-top: 20px;\n    }\n`;\nfunction getSide(placement) {\n  return placement.split(\"-\")[0];\n}\nfunction getAlignment(placement) {\n  return placement.split(\"-\")[1];\n}\nfunction getMainAxisFromPlacement(placement) {\n  return [\"top\", \"bottom\"].includes(getSide(placement)) ? \"x\" : \"y\";\n}\nfunction getLengthFromAxis(axis) {\n  return axis === \"y\" ? \"height\" : \"width\";\n}\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const mainAxis = getMainAxisFromPlacement(placement);\n  const length = getLengthFromAxis(mainAxis);\n  const commonAlign = reference[length] / 2 - floating[length] / 2;\n  const side = getSide(placement);\n  const isVertical = mainAxis === \"x\";\n  let coords;\n  switch (side) {\n    case \"top\":\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case \"bottom\":\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case \"right\":\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case \"left\":\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case \"start\":\n      coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case \"end\":\n      coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\nconst computePosition$1 = (reference, floating, config) => __async(void 0, null, function* () {\n  const {\n    placement = \"bottom\",\n    strategy = \"absolute\",\n    middleware = [],\n    platform: platform2\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = yield platform2.isRTL == null ? void 0 : platform2.isRTL(floating);\n  if ({}.NODE_ENV !== \"production\") {\n    if (platform2 == null) {\n      console.error([\"Floating UI: `platform` property was not passed to config. If you\", \"want to use Floating UI on the web, install @floating-ui/dom\", \"instead of the /core package. Otherwise, you can create your own\", \"`platform`: https://floating-ui.com/docs/platform\"].join(\" \"));\n    }\n    if (validMiddleware.filter((_ref) => {\n      let {\n        name\n      } = _ref;\n      return name === \"autoPlacement\" || name === \"flip\";\n    }).length > 1) {\n      throw new Error([\"Floating UI: duplicate `flip` and/or `autoPlacement` middleware\", \"detected. This will lead to an infinite loop. Ensure only one of\", \"either has been passed to the `middleware` array.\"].join(\" \"));\n    }\n    if (!reference || !floating) {\n      console.error([\"Floating UI: The reference and/or floating element was not defined\", \"when `computePosition()` was called. Ensure that both elements have\", \"been created and can be measured.\"].join(\" \"));\n    }\n  }\n  let rects = yield platform2.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i2 = 0; i2 < validMiddleware.length; i2++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i2];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = yield fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform: platform2,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = __spreadProps(__spreadValues({}, middlewareData), {\n      [name]: __spreadValues(__spreadValues({}, middlewareData[name]), data)\n    });\n    if ({}.NODE_ENV !== \"production\") {\n      if (resetCount > 50) {\n        console.warn([\"Floating UI: The middleware lifecycle appears to be running in an\", \"infinite loop. This is usually caused by a `reset` continually\", \"being returned without a break condition.\"].join(\" \"));\n      }\n    }\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === \"object\") {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? yield platform2.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i2 = -1;\n      continue;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n});\nfunction rectToClientRect(rect) {\n  return __spreadProps(__spreadValues({}, rect), {\n    top: rect.y,\n    left: rect.x,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getComputedStyle$1(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeName(node) {\n  return isNode(node) ? (node.nodeName || \"\").toLowerCase() : \"\";\n}\nlet uaString;\nfunction getUAString() {\n  if (uaString) {\n    return uaString;\n  }\n  const uaData = navigator.userAgentData;\n  if (uaData && Array.isArray(uaData.brands)) {\n    uaString = uaData.brands.map((item) => item.brand + \"/\" + item.version).join(\" \");\n    return uaString;\n  }\n  return navigator.userAgent;\n}\nfunction isHTMLElement(value) {\n  return value instanceof getWindow(value).HTMLElement;\n}\nfunction isElement(value) {\n  return value instanceof getWindow(value).Element;\n}\nfunction isNode(value) {\n  return value instanceof getWindow(value).Node;\n}\nfunction isShadowRoot(node) {\n  if (typeof ShadowRoot === \"undefined\") {\n    return false;\n  }\n  const OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle$1(element);\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX) && ![\"inline\", \"contents\"].includes(display);\n}\nfunction isTableElement(element) {\n  return [\"table\", \"td\", \"th\"].includes(getNodeName(element));\n}\nfunction isContainingBlock(element) {\n  const isFirefox = /firefox/i.test(getUAString());\n  const css = getComputedStyle$1(element);\n  const backdropFilter = css.backdropFilter || css.WebkitBackdropFilter;\n  return css.transform !== \"none\" || css.perspective !== \"none\" || (backdropFilter ? backdropFilter !== \"none\" : false) || isFirefox && css.willChange === \"filter\" || isFirefox && (css.filter ? css.filter !== \"none\" : false) || [\"transform\", \"perspective\"].some((value) => css.willChange.includes(value)) || [\"paint\", \"layout\", \"strict\", \"content\"].some(\n    (value) => {\n      const contain = css.contain;\n      return contain != null ? contain.includes(value) : false;\n    }\n  );\n}\nfunction isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}\nfunction isLastTraversableNode(node) {\n  return [\"html\", \"body\", \"#document\"].includes(getNodeName(node));\n}\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst FALLBACK_SCALE = {\n  x: 1,\n  y: 1\n};\nfunction getScale(element) {\n  const domElement = !isElement(element) && element.contextElement ? element.contextElement : isElement(element) ? element : null;\n  if (!domElement) {\n    return FALLBACK_SCALE;\n  }\n  const rect = domElement.getBoundingClientRect();\n  const css = getComputedStyle$1(domElement);\n  if (css.boxSizing !== \"border-box\") {\n    if (!isHTMLElement(domElement)) {\n      return FALLBACK_SCALE;\n    }\n    return {\n      x: domElement.offsetWidth > 0 ? round(rect.width) / domElement.offsetWidth || 1 : 1,\n      y: domElement.offsetHeight > 0 ? round(rect.height) / domElement.offsetHeight || 1 : 1\n    };\n  }\n  let x = rect.width / parseFloat(css.width);\n  let y = rect.height / parseFloat(css.height);\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  let scale = FALLBACK_SCALE;\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const win = isElement(element) ? getWindow(element) : window;\n  const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scale.x;\n  const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scale.y;\n  const width = clientRect.width / scale.x;\n  const height = clientRect.height / scale.y;\n  return {\n    width,\n    height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x,\n    y\n  };\n}\nfunction getDocumentElement(node) {\n  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.pageXOffset,\n    scrollTop: element.pageYOffset\n  };\n}\nfunction getWindowScrollBarX(element) {\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const rect = getBoundingClientRect(element, true, strategy === \"fixed\", offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent, true);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === \"html\") {\n    return node;\n  }\n  const result = node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || getComputedStyle$1(element).position === \"fixed\") {\n    return null;\n  }\n  return element.offsetParent;\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else {\n      currentNode = getParentNode(currentNode);\n    }\n  }\n  return null;\n}\nfunction getOffsetParent(element) {\n  const window2 = getWindow(element);\n  let offsetParent = getTrueOffsetParent(element);\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === \"static\") {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n  if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle$1(offsetParent).position === \"static\" && !isContainingBlock(offsetParent))) {\n    return window2;\n  }\n  return offsetParent || getContainingBlock(element) || window2;\n}\nfunction getDimensions(element) {\n  if (isHTMLElement(element)) {\n    return {\n      width: element.offsetWidth,\n      height: element.offsetHeight\n    };\n  }\n  const rect = getBoundingClientRect(element);\n  return {\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  if (offsetParent === documentElement) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = {\n    x: 1,\n    y: 1\n  };\n  const offsets = {\n    x: 0,\n    y: 0\n  };\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== \"fixed\") {\n    if (getNodeName(offsetParent) !== \"body\" || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const layoutViewport = isLayoutViewport();\n    if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getDocumentRect(element) {\n  var _element$ownerDocumen;\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle$1(body || html).direction === \"rtl\") {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list) {\n  var _node$ownerDocument;\n  if (list === void 0) {\n    list = [];\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor));\n}\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === \"fixed\");\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : {\n    x: 1,\n    y: 1\n  };\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y,\n    width,\n    height\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  if (clippingAncestor === \"viewport\") {\n    return rectToClientRect(getViewportRect(element, strategy));\n  }\n  if (isElement(clippingAncestor)) {\n    return getInnerBoundingClientRect(clippingAncestor, strategy);\n  }\n  return rectToClientRect(getDocumentRect(getDocumentElement(element)));\n}\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element).filter((el) => isElement(el) && getNodeName(el) !== \"body\");\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle$1(element).position === \"fixed\";\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle$1(currentNode);\n    const containingBlock = isContainingBlock(currentNode);\n    const shouldDropCurrentNode = elementIsFixed ? !containingBlock && !currentContainingBlockComputedStyle : !containingBlock && computedStyle.position === \"static\" && !!currentContainingBlockComputedStyle && [\"absolute\", \"fixed\"].includes(currentContainingBlockComputedStyle.position);\n    if (shouldDropCurrentNode) {\n      result = result.filter((ancestor) => ancestor !== currentNode);\n    } else {\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === \"clippingAncestors\" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\nconst platform = {\n  getClippingRect,\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  isElement,\n  getDimensions,\n  getOffsetParent,\n  getDocumentElement,\n  getScale,\n  getElementRects(_ref) {\n    return __async(this, null, function* () {\n      let {\n        reference,\n        floating,\n        strategy\n      } = _ref;\n      const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n      const getDimensionsFn = this.getDimensions;\n      return {\n        reference: getRectRelativeToOffsetParent(reference, yield getOffsetParentFn(floating), strategy),\n        floating: __spreadValues({\n          x: 0,\n          y: 0\n        }, yield getDimensionsFn(floating))\n      };\n    });\n  },\n  getClientRects: (element) => Array.from(element.getClientRects()),\n  isRTL: (element) => getComputedStyle$1(element).direction === \"rtl\"\n};\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll: _ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = true,\n    animationFrame = false\n  } = options;\n  const ancestorScroll = _ancestorScroll && !animationFrame;\n  const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : reference.contextElement ? getOverflowAncestors(reference.contextElement) : [], ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach((ancestor) => {\n    ancestorScroll && ancestor.addEventListener(\"scroll\", update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener(\"resize\", update);\n  });\n  let observer = null;\n  if (elementResize) {\n    let initialUpdate = true;\n    observer = new ResizeObserver(() => {\n      if (!initialUpdate) {\n        update();\n      }\n      initialUpdate = false;\n    });\n    isElement(reference) && !animationFrame && observer.observe(reference);\n    if (!isElement(reference) && reference.contextElement && !animationFrame) {\n      observer.observe(reference.contextElement);\n    }\n    observer.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _observer;\n    ancestors.forEach((ancestor) => {\n      ancestorScroll && ancestor.removeEventListener(\"scroll\", update);\n      ancestorResize && ancestor.removeEventListener(\"resize\", update);\n    });\n    (_observer = observer) == null ? void 0 : _observer.disconnect();\n    observer = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\nconst computePosition = (reference, floating, options) => {\n  const cache = /* @__PURE__ */ new Map();\n  const mergedOptions = __spreadValues({\n    platform\n  }, options);\n  const platformWithCache = __spreadProps(__spreadValues({}, mergedOptions.platform), {\n    _c: cache\n  });\n  return computePosition$1(reference, floating, __spreadProps(__spreadValues({}, mergedOptions), {\n    platform: platformWithCache\n  }));\n};\nfunction P(l2, u2, e2) {\n  let c2 = () => {\n    var t2;\n    return (t2 = e2 == null ? void 0 : e2.placement) != null ? t2 : \"bottom\";\n  }, d = () => {\n    var t2;\n    return (t2 = e2 == null ? void 0 : e2.strategy) != null ? t2 : \"absolute\";\n  }, [n2, o2] = createSignal({ x: null, y: null, placement: c2(), strategy: d(), middlewareData: {} }), [x, F] = createSignal();\n  createEffect(() => {\n    let t2 = x();\n    if (t2)\n      throw t2.value;\n  });\n  let s2 = createMemo(() => (l2(), u2(), {}));\n  function i2() {\n    let t2 = l2(), r = u2();\n    if (t2 && r) {\n      let a2 = s2();\n      computePosition(t2, r, { middleware: e2 == null ? void 0 : e2.middleware, placement: c2(), strategy: d() }).then((m) => {\n        a2 === s2() && o2(m);\n      }, (m) => {\n        F(m);\n      });\n    }\n  }\n  return createEffect(() => {\n    let t2 = l2(), r = u2();\n    if (e2 == null || e2.middleware, c2(), d(), t2 && r)\n      if (e2 != null && e2.whileElementsMounted) {\n        let a2 = e2.whileElementsMounted(t2, r, i2);\n        a2 && onCleanup(a2);\n      } else\n        i2();\n  }), { get x() {\n    return n2().x;\n  }, get y() {\n    return n2().y;\n  }, get placement() {\n    return n2().placement;\n  }, get strategy() {\n    return n2().strategy;\n  }, get middlewareData() {\n    return n2().middlewareData;\n  }, update: i2 };\n}\nconst _tmpl$$3 = /* @__PURE__ */ template$1(`<tc-root data-tc-dropdown-container=\"true\"></tc-root>`);\nconst AccountButton = () => {\n  const theme = useTheme();\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [isOpened, setIsOpened] = createSignal(false);\n  const [account, setAccount] = createSignal(connector.account);\n  const [restoringProcess, setRestoringProcess] = createSignal(true);\n  let dropDownRef;\n  const [floating, setFloating] = createSignal();\n  const [anchor, setAnchor] = createSignal();\n  const position = P(anchor, floating, {\n    whileElementsMounted: autoUpdate,\n    placement: \"bottom-end\"\n  });\n  const normalizedAddress = () => {\n    const acc = account();\n    if (acc) {\n      const userFriendlyAddress = (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.toUserFriendlyAddress)(acc.address, acc.chain === _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.CHAIN.TESTNET);\n      return userFriendlyAddress.slice(0, 4) + \"\\u2026\" + userFriendlyAddress.slice(-4);\n    }\n    return \"\";\n  };\n  tonConnectUI.connectionRestored.then(() => setRestoringProcess(false));\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (!wallet) {\n      setIsOpened(false);\n      setAccount(null);\n      return;\n    }\n    setAccount(wallet.account);\n  });\n  const onClick = (e2) => {\n    if (!account() || !isOpened()) {\n      return;\n    }\n    const clickToButton = anchor().contains(e2.target);\n    const clickToDropdown = dropDownRef.contains(e2.target);\n    if (!clickToButton && !clickToDropdown) {\n      setIsOpened(false);\n    }\n  };\n  onMount(() => {\n    document.body.addEventListener(\"click\", onClick);\n  });\n  onCleanup(() => {\n    document.body.removeEventListener(\"click\", onClick);\n    unsubscribe();\n  });\n  return createComponent(Dynamic, {\n    component: globalStylesTag,\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return restoringProcess();\n        },\n        get children() {\n          return createComponent(LoaderButtonStyled, {\n            disabled: true,\n            \"data-tc-connect-button-loading\": \"true\",\n            get children() {\n              return createComponent(LoaderIconStyled, {});\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !restoringProcess();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return !account();\n            },\n            get children() {\n              return createComponent(AccountButtonStyled, {\n                onClick: () => tonConnectUI.connectWallet(),\n                \"data-tc-connect-button\": \"true\",\n                get children() {\n                  return [createComponent(TonIcon, {\n                    get fill() {\n                      return theme.colors.connectButton.foreground;\n                    }\n                  }), createComponent(Text, {\n                    translationKey: \"button.connectWallet\",\n                    fontSize: \"15px\",\n                    lineHeight: \"18px\",\n                    fontWeight: \"590\",\n                    get color() {\n                      return theme.colors.connectButton.foreground;\n                    },\n                    children: \"Connect wallet\"\n                  })];\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return account();\n            },\n            get children() {\n              return createComponent(DropdownContainerStyled, {\n                get children() {\n                  return [createComponent(DropdownButtonStyled, {\n                    onClick: () => setIsOpened((v) => !v),\n                    ref: setAnchor,\n                    \"data-tc-dropdown-button\": \"true\",\n                    get children() {\n                      return [createComponent(Text, {\n                        fontSize: \"15px\",\n                        fontWeight: \"590\",\n                        lineHeight: \"18px\",\n                        get children() {\n                          return normalizedAddress();\n                        }\n                      }), createComponent(ArrowIcon, {\n                        direction: \"bottom\"\n                      })];\n                    }\n                  }), createComponent(Portal, {\n                    get children() {\n                      const _el$ = untrack(() => document.importNode(_tmpl$$3, true));\n                      use(setFloating, _el$);\n                      _el$.style.setProperty(\"z-index\", \"999\");\n                      _el$._$owner = getOwner();\n                      insert(_el$, createComponent(Transition, {\n                        onBeforeEnter: (el) => {\n                          el.animate([{\n                            opacity: 0,\n                            transform: \"translateY(-8px)\"\n                          }, {\n                            opacity: 1,\n                            transform: \"translateY(0)\"\n                          }], {\n                            duration: 150\n                          });\n                        },\n                        onExit: (el, done) => {\n                          const a2 = el.animate([{\n                            opacity: 1,\n                            transform: \"translateY(0)\"\n                          }, {\n                            opacity: 0,\n                            transform: \"translateY(-8px)\"\n                          }], {\n                            duration: 150\n                          });\n                          a2.finished.then(done);\n                        },\n                        get children() {\n                          return createComponent(Show, {\n                            get when() {\n                              return isOpened();\n                            },\n                            get children() {\n                              return createComponent(DropdownStyled, {\n                                get hidden() {\n                                  return !isOpened();\n                                },\n                                onClose: () => setIsOpened(false),\n                                ref(r$) {\n                                  const _ref$ = dropDownRef;\n                                  typeof _ref$ === \"function\" ? _ref$(r$) : dropDownRef = r$;\n                                }\n                              });\n                            }\n                          });\n                        }\n                      }), null);\n                      insert(_el$, createComponent(NotificationsStyled, {}), null);\n                      createRenderEffect((_p$) => {\n                        var _a, _b;\n                        const _v$ = position.strategy, _v$2 = `${(_a = position.y) != null ? _a : 0}px`, _v$3 = `${(_b = position.x) != null ? _b : 0}px`;\n                        _v$ !== _p$._v$ && _el$.style.setProperty(\"position\", _p$._v$ = _v$);\n                        _v$2 !== _p$._v$2 && _el$.style.setProperty(\"top\", _p$._v$2 = _v$2);\n                        _v$3 !== _p$._v$3 && _el$.style.setProperty(\"left\", _p$._v$3 = _v$3);\n                        return _p$;\n                      }, {\n                        _v$: void 0,\n                        _v$2: void 0,\n                        _v$3: void 0\n                      });\n                      return _el$;\n                    }\n                  })];\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst borders$1 = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst QrCodeModalStyled = styled.div`\n    ${media(\"mobile\")} {\n        padding: 10px 16px 0 16px;\n    }\n`;\nconst H1Styled$2 = styled(H1)`\n    max-width: 320px;\n    margin: 0 auto 6px;\n`;\nconst StyledIconButton = styled(IconButton)`\n    position: absolute;\n    top: 16px;\n    left: 16px;\n`;\nconst QRStyled = styled(QRCode)`\n    margin-bottom: 16px;\n`;\nconst ButtonsContainerStyled$1 = styled.div`\n    display: flex;\n    gap: 16px;\n    height: 56px;\n    margin-bottom: 24px;\n`;\nconst ActionButtonStyled$1 = styled(Button)`\n    padding: 0 16px;\n    height: 56px;\n    font-size: 16px;\n    line-height: 20px;\n    width: 100%;\n    border-radius: ${(props) => borders$1[props.theme.borderRadius]};\n`;\nconst GetWalletStyled$1 = styled.div`\n    display: flex;\n    justify-content: space-between;\n    align-items: center;\n`;\nconst TextStyled$1 = styled(Text)`\n    padding-left: 8px;\n    color: ${(props) => props.theme.colors.text.secondary};\n    font-size: 16px;\n`;\nconst [appState, setAppState] = createStore({\n  buttonRootId: null,\n  language: \"en\",\n  returnStrategy: \"back\",\n  walletsListConfiguration: {}\n});\nconst AStyled = styled.a`\n    display: block;\n    text-decoration: unset;\n`;\nconst Link = (props) => {\n  const attributes = () => props.blank ? {\n    rel: \"noreferrer noopener\"\n  } : {};\n  return createComponent(AStyled, mergeProps({\n    get href() {\n      return props.href;\n    },\n    get target() {\n      return props.blank ? \"_blank\" : \"_self\";\n    }\n  }, attributes, {\n    get children() {\n      return props.children;\n    }\n  }));\n};\nconst QrCodeModal = (props) => {\n  const connector = useContext(ConnectorContext);\n  const universalLink = createMemo(() => connector.connect({\n    universalLink: props.wallet.universalLink,\n    bridgeUrl: props.wallet.bridgeUrl\n  }, props.additionalRequest));\n  return createComponent(QrCodeModalStyled, {\n    \"data-tc-wallet-qr-modal-desktop\": \"true\",\n    get children() {\n      return [createComponent(StyledIconButton, {\n        icon: \"arrow\",\n        onClick: () => props.onBackClick()\n      }), createComponent(H1Styled$2, {\n        translationKey: \"walletModal.qrCodeModal.connectWith\",\n        get translationValues() {\n          return {\n            name: props.wallet.name\n          };\n        },\n        get children() {\n          return [\"Connect with \", createMemo(() => props.wallet.name)];\n        }\n      }), createComponent(H2, {\n        translationKey: \"walletModal.qrCodeModal.scan\",\n        get translationValues() {\n          return {\n            name: props.wallet.name\n          };\n        },\n        get children() {\n          return [\"Scan QR code with your phone\\u2019s or \", createMemo(() => props.wallet.name), \"\\u2019s camera.\"];\n        }\n      }), createComponent(QRStyled, {\n        disableCopy: false,\n        get sourceUrl() {\n          return universalLink();\n        },\n        get imageUrl() {\n          return props.wallet.imageUrl;\n        }\n      }), createComponent(ButtonsContainerStyled$1, {\n        get children() {\n          return [createComponent(ActionButtonStyled$1, {\n            scale: \"s\",\n            onClick: () => {\n              setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, props.wallet), {\n                openMethod: \"universal-link\"\n              }));\n              openLinkBlank(addReturnStrategy(universalLink(), appState.returnStrategy));\n            },\n            get children() {\n              return createComponent(Translation, {\n                translationKey: \"walletModal.qrCodeModal.openWallet\",\n                get translationValues() {\n                  return {\n                    name: props.wallet.name\n                  };\n                },\n                get children() {\n                  return [\"Open \", createMemo(() => props.wallet.name)];\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return (0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(props.wallet);\n            },\n            get children() {\n              return createComponent(ActionButtonStyled$1, {\n                scale: \"s\",\n                onClick: () => {\n                  setLastSelectedWalletInfo(props.wallet);\n                  connector.connect({\n                    jsBridgeKey: props.wallet.jsBridgeKey\n                  }, props.additionalRequest);\n                },\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"common.openExtension\",\n                    children: \"Open Extension\"\n                  });\n                }\n              });\n            }\n          })];\n        }\n      }), createComponent(GetWalletStyled$1, {\n        get children() {\n          return [createComponent(TextStyled$1, {\n            translationKey: \"walletModal.qrCodeModal.dontHave\",\n            get translationValues() {\n              return {\n                name: props.wallet.name\n              };\n            },\n            get children() {\n              return [\"Don't have \", createMemo(() => props.wallet.name), \"?\"];\n            }\n          }), createComponent(Link, {\n            get href() {\n              return props.wallet.aboutUrl;\n            },\n            blank: true,\n            get children() {\n              return createComponent(Button, {\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"common.get\",\n                    children: \"GET\"\n                  });\n                }\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst StyledModal = styled(Modal)`\n    padding-left: 24px;\n    padding-right: 24px;\n\n    ${media(\"mobile\")} {\n        padding-left: 0;\n        padding-right: 0;\n\n        min-height: 364px;\n    }\n`;\nconst H1Styled$1 = styled(H1)`\n    margin-top: 12px;\n\n    ${media(\"mobile\")} {\n        padding: 0 10px;\n    }\n`;\nconst LoaderContainerStyled = styled.div`\n    margin: 30px 0;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n\n    ${media(\"mobile\")} {\n        height: 160px;\n        align-items: center;\n    }\n`;\nconst TabTextStyled = styled(Text)`\n    min-width: 84px;\n    text-align: center;\n    font-weight: 590;\n`;\nconst TabBarStyled = styled(TabBar)`\n    margin: 0 auto 22px;\n`;\nfunction uniq(array) {\n  return [...new Set(array)];\n}\nfunction mergeConcat(idKey, array1, array2) {\n  return array1.map((item1) => {\n    const item2 = array2.find((elem) => elem[idKey] === item1[idKey]);\n    array2 = array2.filter((elem) => elem[idKey] !== item1[idKey]);\n    return item2 === void 0 ? item1 : item2;\n  }).concat(array2);\n}\nfunction uiWalletToWalletInfo(uiWallet) {\n  if (\"jsBridgeKey\" in uiWallet) {\n    return __spreadProps(__spreadValues({}, uiWallet), {\n      injected: _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.isWalletInjected(uiWallet.jsBridgeKey),\n      embedded: _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.isInsideWalletBrowser(uiWallet.jsBridgeKey)\n    });\n  }\n  return uiWallet;\n}\nfunction applyWalletsListConfiguration(walletsList, configuration) {\n  var _a;\n  if (!configuration) {\n    return walletsList;\n  }\n  if ((_a = configuration.includeWallets) == null ? void 0 : _a.length) {\n    walletsList = mergeConcat(\n      \"name\",\n      walletsList,\n      configuration.includeWallets.map(uiWalletToWalletInfo)\n    );\n  }\n  return walletsList;\n}\nfunction eqWalletName(wallet1, name) {\n  if (!name) {\n    return false;\n  }\n  return wallet1.name.toLowerCase() === name.toLowerCase() || wallet1.appName.toLowerCase() === name.toLowerCase();\n}\nconst [isMobile, setIsMobile] = createSignal(isDevice(\"mobile\"));\nif (getWindow$1()) {\n  window.addEventListener(\"resize\", () => setIsMobile(isDevice(\"mobile\")));\n}\nconst UlStyled = styled.ul`\n    display: flex;\n    margin: 0 auto 24px;\n    width: fit-content;\n    min-height: 124px;\n    max-width: 100%;\n    overflow-x: auto;\n    overflow-y: hidden;\n    padding: 0 24px;\n\n    &&::-webkit-scrollbar {\n        display: none;\n    }\n\n    -ms-overflow-style: none;\n    scrollbar-width: none;\n`;\nconst DefaultWallet = styled.li`\n    width: 82px;\n    min-width: 82px;\n    height: 124px;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding: 8px 4px;\n\n    text-align: center;\n    cursor: pointer;\n\n    transition: transform 0.1s ease-in-out;\n\n    ${mediaNotTouch} {\n        &:hover {\n            transform: scale(1.04);\n        }\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n\n    ${mediaTouch} {\n        &:active {\n            transform: scale(0.92);\n        }\n    }\n`;\nconst Divider = styled.div`\n    width: 1px;\n    margin: 0 10px;\n    height: 24px;\n    position: relative;\n    top: 30px;\n\n    background-color: ${(props) => props.theme.colors.icon.tertiary};\n`;\nconst LongArrowIconContainer = styled.div`\n    width: 64px;\n    height: 64px;\n    border-radius: 16px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n\n    background-color: ${(props) => rgba(props.theme.colors.accent, 0.12)};\n    color: ${(props) => props.theme.colors.accent};\n\n    margin-bottom: 8px;\n`;\nconst H2Styled$2 = styled(H2)`\n    margin-bottom: 24px;\n    padding: 0 24px;\n    min-height: 44px;\n`;\nconst ButtonStyled$2 = styled(Button)`\n    display: block;\n    margin: 0 auto;\n`;\nconst LINKS = {\n  LEARN_MORE: \"https://ton.org/wallets\"\n};\nconst _tmpl$$2 = /* @__PURE__ */ template$1(`<div data-tc-wallets-modal-mobile=\"true\"></div>`), _tmpl$2 = /* @__PURE__ */ template$1(`<li></li>`);\nconst MobileSelectWalletModal = (props) => {\n  const connector = appState.connector;\n  const theme = useTheme();\n  const onSelect = (walletInfo) => {\n    if (!isMobileUserAgent()) {\n      return props.onSelect(walletInfo);\n    }\n    if (\"universalLink\" in walletInfo) {\n      setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, walletInfo), {\n        openMethod: \"universal-link\"\n      }));\n      const universalLink = connector.connect({\n        universalLink: walletInfo.universalLink,\n        bridgeUrl: walletInfo.bridgeUrl\n      }, props.additionalRequest);\n      openLink(addReturnStrategy(universalLink, appState.returnStrategy));\n      return;\n    }\n    openLinkBlank(walletInfo.aboutUrl);\n  };\n  const onSelectUniversal = () => {\n    const universalLink = connector.connect(props.walletsList.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote).map((item) => ({\n      bridgeUrl: item.bridgeUrl,\n      universalLink: item.universalLink\n    })), props.additionalRequest);\n    setLastSelectedWalletInfo({\n      openMethod: \"universal-link\"\n    });\n    openLink(addReturnStrategy(universalLink, appState.returnStrategy));\n  };\n  return (() => {\n    const _el$ = _tmpl$$2.cloneNode(true);\n    insert(_el$, createComponent(H1, {\n      translationKey: \"walletModal.mobileSelectWalletModal.connectWallet\",\n      children: \"Connect a wallet\"\n    }), null);\n    insert(_el$, createComponent(H2Styled$2, {\n      translationKey: \"walletModal.mobileSelectWalletModal.selectWallet\",\n      children: \"Select your wallet from the options to get started.\"\n    }), null);\n    insert(_el$, createComponent(UlStyled, {\n      get children() {\n        return [createComponent(DefaultWallet, {\n          onClick: onSelectUniversal,\n          get children() {\n            return [createComponent(LongArrowIconContainer, {\n              get children() {\n                return createComponent(LongArrowIcon, {\n                  get fill() {\n                    return theme.colors.accent;\n                  }\n                });\n              }\n            }), createComponent(Text, {\n              fontWeight: 590,\n              translationKey: \"walletModal.mobileSelectWalletModal.installedWallet\",\n              children: \"Installed wallet\"\n            })];\n          }\n        }), createComponent(Divider, {\n          children: \"\\xA0\"\n        }), createComponent(For, {\n          get each() {\n            return props.walletsList.filter((wallet) => \"bridgeUrl\" in wallet);\n          },\n          children: (wallet) => (() => {\n            const _el$2 = _tmpl$2.cloneNode(true);\n            insert(_el$2, createComponent(WalletItem, {\n              get iconUrl() {\n                return wallet.imageUrl;\n              },\n              get name() {\n                return wallet.name;\n              },\n              onClick: () => onSelect(wallet)\n            }));\n            return _el$2;\n          })()\n        })];\n      }\n    }), null);\n    insert(_el$, createComponent(Link, {\n      get href() {\n        return LINKS.LEARN_MORE;\n      },\n      blank: true,\n      get children() {\n        return createComponent(ButtonStyled$2, {\n          get children() {\n            return createComponent(Translation, {\n              translationKey: \"common.learnMore\",\n              children: \"Learn more\"\n            });\n          }\n        });\n      }\n    }), null);\n    return _el$;\n  })();\n};\nconst borders = {\n  m: \"16px\",\n  s: \"8px\",\n  none: \"0\"\n};\nconst hoverBorders = {\n  m: \"8px\",\n  s: \"4px\",\n  none: \"0\"\n};\nconst UniversalQrModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst H2Styled$1 = styled(H2)`\n    max-width: 320px;\n    margin-bottom: 24px;\n`;\nconst QRCodeStyled = styled(QRCode)`\n    margin-bottom: 16px;\n`;\nconst ButtonsContainerStyled = styled.div`\n    display: flex;\n    gap: 16px;\n    width: 100%;\n`;\nconst ActionButtonStyled = styled(Button)`\n    position: relative;\n    font-size: 16px;\n    line-height: 20px;\n    width: 100%;\n    padding: 0 16px;\n    height: 56px;\n    border-radius: ${(props) => borders[props.theme.borderRadius]};\n\n    &:hover {\n        ${(props) => props.disableEventsAnimation ? \"transform: unset;\" : \"\"}\n    }\n\n    &:active {\n        ${(props) => props.disableEventsAnimation ? \"transform: unset;\" : \"\"}\n    }\n`;\nconst PopupWrapperStyled = styled.ul`\n    position: absolute;\n    bottom: 100%;\n    left: 0;\n    margin: 0;\n    padding: 8px;\n    width: 188px;\n    transform: translateY(-16px);\n\n    background-color: ${(props) => props.theme.colors.background.primary};\n    border-radius: ${(props) => borders[props.theme.borderRadius]};\n    box-shadow: 0 4px 24px rgba(0, 0, 0, 0.16);\n`;\nconst ExtensionLiStyled = styled.li`\n    padding: 8px;\n\n    display: flex;\n    align-items: center;\n    gap: 8px;\n\n    cursor: pointer;\n    border-radius: ${(props) => hoverBorders[props.theme.borderRadius]};\n\n    transition: background-color, transform 0.1s ease-in-out;\n\n    &:hover {\n        background-color: ${(props) => props.theme.colors.background.secondary};\n    }\n\n    &:active {\n        transform: scale(0.96);\n    }\n`;\nconst ImageStyled = styled(Image)`\n    width: 24px;\n    height: 24px;\n\n    border-radius: 6px;\n`;\nconst GetWalletStyled = styled.div`\n    margin-top: 23px;\n    margin-bottom: 1px;\n    width: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n`;\nstyled(Text)`\n    color: ${(props) => props.theme.colors.text.secondary};\n    font-size: 16px;\n`;\nconst UniversalQrModal = (props) => {\n  const [popupOpened, setPopupOpened] = createSignal(false);\n  const connector = appState.connector;\n  const walletsBridges = props.walletsList.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote).map((item) => ({\n    bridgeUrl: item.bridgeUrl,\n    universalLink: item.universalLink\n  }));\n  const availableInjectableWallets = props.walletsList.filter(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected);\n  setLastSelectedWalletInfo({\n    openMethod: \"qrcode\"\n  });\n  const request = createMemo(() => connector.connect(walletsBridges, props.additionalRequest));\n  const onOpenWalletClick = () => {\n    let blurred = false;\n    function blurHandler() {\n      blurred = true;\n      setLastSelectedWalletInfo({\n        openMethod: \"universal-link\"\n      });\n      window.removeEventListener(\"blur\", blurHandler);\n    }\n    window.addEventListener(\"blur\", blurHandler);\n    openLink(addReturnStrategy(request(), appState.returnStrategy));\n    setTimeout(() => {\n      if (!blurred) {\n        props.openWalletFallback();\n      }\n      window.removeEventListener(\"blur\", blurHandler);\n    }, 200);\n  };\n  const onOpenExtensionClick = (e2) => {\n    e2.stopPropagation();\n    if (availableInjectableWallets.length === 1) {\n      const walletInfo = availableInjectableWallets[0];\n      setLastSelectedWalletInfo(walletInfo);\n      connector.connect({\n        jsBridgeKey: walletInfo.jsBridgeKey\n      }, props.additionalRequest);\n      return;\n    }\n    setPopupOpened((opened) => !opened);\n  };\n  const onExtensionClick = (walletInfo) => {\n    setLastSelectedWalletInfo(walletInfo);\n    connector.connect({\n      jsBridgeKey: walletInfo.jsBridgeKey\n    }, props.additionalRequest);\n  };\n  return createComponent(UniversalQrModalStyled, {\n    onClick: () => setPopupOpened(false),\n    \"data-tc-universal-qr-desktop\": \"true\",\n    get children() {\n      return [createComponent(H2Styled$1, {\n        translationKey: \"walletModal.universalQRModal.scanQR\",\n        children: \"Scan QR code with a TON Connect compatible wallet.\"\n      }), createComponent(QRCodeStyled, {\n        get sourceUrl() {\n          return request();\n        },\n        get disableCopy() {\n          return popupOpened();\n        }\n      }), createComponent(ButtonsContainerStyled, {\n        get children() {\n          return [createComponent(ActionButtonStyled, {\n            onClick: onOpenWalletClick,\n            scale: \"s\",\n            get children() {\n              return [createComponent(Show, {\n                get when() {\n                  return availableInjectableWallets.length;\n                },\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"walletModal.universalQRModal.openWallet\",\n                    children: \"Open Wallet\"\n                  });\n                }\n              }), createComponent(Show, {\n                get when() {\n                  return !availableInjectableWallets.length;\n                },\n                get children() {\n                  return createComponent(Translation, {\n                    translationKey: \"walletModal.universalQRModal.openInstalledWallet\",\n                    children: \"Open Installed Wallet\"\n                  });\n                }\n              })];\n            }\n          }), createComponent(Show, {\n            get when() {\n              return availableInjectableWallets.length;\n            },\n            get children() {\n              return createComponent(ActionButtonStyled, {\n                onClick: onOpenExtensionClick,\n                get disableEventsAnimation() {\n                  return popupOpened();\n                },\n                scale: \"s\",\n                get children() {\n                  return [createComponent(Transition, {\n                    onBeforeEnter: (el) => {\n                      el.animate([{\n                        opacity: 0,\n                        transform: \"translateY(0)\"\n                      }, {\n                        opacity: 1,\n                        transform: \"translateY(-16px)\"\n                      }], {\n                        duration: 150\n                      });\n                    },\n                    onExit: (el, done) => {\n                      el.animate([{\n                        opacity: 1,\n                        transform: \"translateY(-16px)\"\n                      }, {\n                        opacity: 0,\n                        transform: \"translateY(0)\"\n                      }], {\n                        duration: 150\n                      }).finished.then(done);\n                    },\n                    get children() {\n                      return createComponent(Show, {\n                        get when() {\n                          return popupOpened();\n                        },\n                        get children() {\n                          return createComponent(PopupWrapperStyled, {\n                            get children() {\n                              return createComponent(For, {\n                                each: availableInjectableWallets,\n                                children: (wallet) => createComponent(ExtensionLiStyled, {\n                                  onClick: () => onExtensionClick(wallet),\n                                  get children() {\n                                    return [createComponent(ImageStyled, {\n                                      get src() {\n                                        return wallet.imageUrl;\n                                      },\n                                      alt: \"\"\n                                    }), createComponent(Text, {\n                                      fontWeight: 590,\n                                      get children() {\n                                        return wallet.name;\n                                      }\n                                    })];\n                                  }\n                                })\n                              });\n                            }\n                          });\n                        }\n                      });\n                    }\n                  }), createComponent(Translation, {\n                    translationKey: \"common.openExtension\",\n                    children: \"Open Extension\"\n                  })];\n                }\n              });\n            }\n          })];\n        }\n      }), createComponent(Show, {\n        get when() {\n          return !availableInjectableWallets.length;\n        },\n        get children() {\n          return createComponent(GetWalletStyled, {\n            get children() {\n              return createComponent(Link, {\n                get href() {\n                  return LINKS.LEARN_MORE;\n                },\n                blank: true,\n                get children() {\n                  return createComponent(Button, {\n                    appearance: \"flat\",\n                    \"class\": u`\n                                font-size: 15px;\n                            `,\n                    get children() {\n                      return createComponent(Translation, {\n                        translationKey: \"common.learnMore\",\n                        children: \"Learn more\"\n                      });\n                    }\n                  });\n                }\n              });\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nconst DesktopSelectWalletModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n`;\nconst H2Styled = styled(H2)`\n    margin-bottom: 26px;\n`;\nconst WalletsUl = styled.ul`\n    display: grid;\n    grid-template-columns: repeat(auto-fit, 92px);\n    justify-content: center;\n    row-gap: 8px;\n    overflow-y: auto;\n    max-height: 410px;\n    width: calc(100% + 12px);\n    margin-bottom: 30px;\n    padding: 10px 0;\n    align-self: flex-start;\n\n    &&::-webkit-scrollbar {\n        width: 8px;\n    }\n\n    &&::-webkit-scrollbar-track {\n        background: transparent;\n    }\n\n    &&::-webkit-scrollbar-thumb {\n        background: #cacaca;\n        border-radius: 12px;\n    }\n`;\nconst ButtonStyled$1 = styled(Button)`\n    display: block;\n    margin: 0 auto 1px;\n    font-size: 15px;\n`;\nconst _tmpl$$1 = /* @__PURE__ */ template$1(`<li></li>`);\nconst DesktopSelectWalletModal = (props) => {\n  return createComponent(DesktopSelectWalletModalStyled, {\n    \"data-tc-select-wallet-desktop\": \"true\",\n    get children() {\n      return [createComponent(H2Styled, {\n        translationKey: \"walletModal.desktopSelectWalletModal.selectWallet\",\n        children: \"Choose your preferred wallet from the options to get started.\"\n      }), createComponent(WalletsUl, {\n        get children() {\n          return createComponent(For, {\n            get each() {\n              return props.walletsList;\n            },\n            children: (wallet) => (() => {\n              const _el$ = _tmpl$$1.cloneNode(true);\n              insert(_el$, createComponent(WalletItem, {\n                get iconUrl() {\n                  return wallet.imageUrl;\n                },\n                get name() {\n                  return wallet.name;\n                },\n                onClick: () => props.onSelect(wallet)\n              }));\n              return _el$;\n            })()\n          });\n        }\n      }), createComponent(Link, {\n        get href() {\n          return LINKS.LEARN_MORE;\n        },\n        blank: true,\n        get children() {\n          return createComponent(ButtonStyled$1, {\n            appearance: \"flat\",\n            get children() {\n              return createComponent(Translation, {\n                translationKey: \"common.learnMore\",\n                children: \"Learn more\"\n              });\n            }\n          });\n        }\n      })];\n    }\n  });\n};\nconst _tmpl$ = /* @__PURE__ */ template$1(`<div data-tc-wallets-modal-desktop=\"true\"></div>`);\nconst WalletsModal = () => {\n  const {\n    locale\n  } = useI18n()[1];\n  createEffect(() => locale(appState.language));\n  const connector = useContext(ConnectorContext);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [fetchedWalletsList] = createResource(() => tonConnectUI.getWallets());\n  const [selectedWalletInfo, setSelectedWalletInfo] = createSignal(null);\n  const [selectedTabIndex, setSelectedTabIndex] = createSignal(0);\n  const walletsList = createMemo(() => {\n    if (fetchedWalletsList.state !== \"ready\") {\n      return null;\n    }\n    let walletsList2 = applyWalletsListConfiguration(fetchedWalletsList(), appState.walletsListConfiguration);\n    const preferredWalletName = appState.preferredWalletName;\n    const preferredWallet = walletsList2.find((item) => eqWalletName(item, preferredWalletName));\n    const someWalletsWithSameName = walletsList2.filter((item) => eqWalletName(item, preferredWalletName)).length >= 2;\n    if (preferredWalletName && preferredWallet && !someWalletsWithSameName) {\n      walletsList2 = [preferredWallet].concat(walletsList2.filter((item) => !eqWalletName(item, preferredWalletName)));\n    }\n    return walletsList2;\n  });\n  const additionalRequestLoading = () => {\n    var _a;\n    return ((_a = appState.connectRequestParameters) == null ? void 0 : _a.state) === \"loading\";\n  };\n  const additionalRequest = createMemo(() => {\n    var _a;\n    if (additionalRequestLoading()) {\n      return void 0;\n    }\n    return (_a = appState.connectRequestParameters) == null ? void 0 : _a.value;\n  });\n  const onClose = () => {\n    setWalletsModalOpen(false);\n    setSelectedWalletInfo(null);\n  };\n  const onSelectInDesktopList = (walletInfo) => {\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyInjected)(walletInfo)) {\n      setLastSelectedWalletInfo(walletInfo);\n      connector.connect({\n        jsBridgeKey: walletInfo.jsBridgeKey\n      }, additionalRequest());\n      return;\n    }\n    if ((0,_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoRemote)(walletInfo)) {\n      setLastSelectedWalletInfo(__spreadProps(__spreadValues({}, walletInfo), {\n        openMethod: \"qrcode\"\n      }));\n      setSelectedWalletInfo(walletInfo);\n      return;\n    }\n    openLinkBlank(walletInfo.aboutUrl);\n  };\n  const unsubscribe = connector.onStatusChange((wallet) => {\n    if (wallet) {\n      onClose();\n    }\n  });\n  onCleanup(unsubscribe);\n  return createComponent(StyledModal, {\n    get opened() {\n      return walletsModalOpen();\n    },\n    onClose,\n    \"data-tc-wallets-modal-container\": \"true\",\n    get children() {\n      return [createComponent(Show, {\n        get when() {\n          return additionalRequestLoading() || !walletsList();\n        },\n        get children() {\n          return [createComponent(H1Styled$1, {\n            translationKey: \"walletModal.loading\",\n            children: \"Wallets list is loading\"\n          }), createComponent(LoaderContainerStyled, {\n            get children() {\n              return createComponent(LoaderIcon, {\n                size: \"m\"\n              });\n            }\n          })];\n        }\n      }), createComponent(Show, {\n        get when() {\n          return createMemo(() => !!!additionalRequestLoading())() && walletsList();\n        },\n        get children() {\n          return [createComponent(Show, {\n            get when() {\n              return createMemo(() => !!isMobile())() && !selectedWalletInfo();\n            },\n            get children() {\n              return createComponent(MobileSelectWalletModal, {\n                onSelect: onSelectInDesktopList,\n                get walletsList() {\n                  return walletsList();\n                },\n                get additionalRequest() {\n                  return additionalRequest();\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return !isMobile();\n            },\n            get children() {\n              return createComponent(Show, {\n                get when() {\n                  return !selectedWalletInfo();\n                },\n                get children() {\n                  const _el$ = _tmpl$.cloneNode(true);\n                  insert(_el$, createComponent(TabBarStyled, {\n                    get tab1() {\n                      return createComponent(TabTextStyled, {\n                        translationKey: \"walletModal.qrCode\",\n                        cursor: \"unset\",\n                        children: \"QR Code\"\n                      });\n                    },\n                    get tab2() {\n                      return createComponent(TabTextStyled, {\n                        translationKey: \"walletModal.wallets\",\n                        cursor: \"unset\",\n                        children: \"Wallets\"\n                      });\n                    },\n                    get selectedTabIndex() {\n                      return selectedTabIndex();\n                    },\n                    onSelectedTabIndexChange: setSelectedTabIndex\n                  }), null);\n                  insert(_el$, createComponent(Switch, {\n                    get children() {\n                      return [createComponent(Match, {\n                        get when() {\n                          return selectedTabIndex() === 0;\n                        },\n                        get children() {\n                          return createComponent(UniversalQrModal, {\n                            get walletsList() {\n                              return walletsList();\n                            },\n                            get additionalRequest() {\n                              return additionalRequest();\n                            },\n                            openWalletFallback: () => setSelectedTabIndex(1)\n                          });\n                        }\n                      }), createComponent(Match, {\n                        get when() {\n                          return selectedTabIndex() === 1;\n                        },\n                        get children() {\n                          return createComponent(DesktopSelectWalletModal, {\n                            get walletsList() {\n                              return walletsList();\n                            },\n                            onSelect: onSelectInDesktopList\n                          });\n                        }\n                      })];\n                    }\n                  }), null);\n                  return _el$;\n                }\n              });\n            }\n          }), createComponent(Show, {\n            get when() {\n              return selectedWalletInfo();\n            },\n            get children() {\n              return createComponent(QrCodeModal, {\n                get additionalRequest() {\n                  return additionalRequest();\n                },\n                get wallet() {\n                  return selectedWalletInfo();\n                },\n                onBackClick: () => setSelectedWalletInfo(null)\n              });\n            }\n          })];\n        }\n      })];\n    }\n  });\n};\nconst ActionModalStyled = styled.div`\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n    padding-bottom: 8px;\n`;\nconst H1Styled = styled(H1)`\n    margin-top: 16px;\n`;\nconst TextStyled = styled(Text)`\n    font-weight: 510;\n    font-size: 16px;\n    line-height: 20px;\n    text-align: center;\n    max-width: 250px;\n\n    color: ${(props) => props.theme.colors.text.secondary};\n`;\nconst ButtonStyled = styled(Button)`\n    margin-top: 32px;\n`;\nconst ActionModal = (props) => {\n  const dataAttrs = useDataAttributes(props);\n  const tonConnectUI = useContext(TonConnectUiContext);\n  let universalLink;\n  if ((tonConnectUI == null ? void 0 : tonConnectUI.wallet) && \"universalLink\" in tonConnectUI.wallet && tonConnectUI.wallet.openMethod === \"universal-link\") {\n    universalLink = tonConnectUI.wallet.universalLink;\n  }\n  const onOpenWallet = () => {\n    openLink(addReturnStrategy(universalLink, \"back\"));\n  };\n  return createComponent(ActionModalStyled, mergeProps(dataAttrs, {\n    get children() {\n      return [createMemo(() => props.icon), createComponent(H1Styled, {\n        get translationKey() {\n          return props.headerTranslationKey;\n        },\n        get translationValues() {\n          return props.headerTranslationValues;\n        }\n      }), createComponent(TextStyled, {\n        get translationKey() {\n          return props.textTranslationKey;\n        },\n        get translationValues() {\n          return props.textTranslationValues;\n        }\n      }), createComponent(Show, {\n        get when() {\n          return props.showButton !== \"open-wallet\";\n        },\n        get children() {\n          return createComponent(ButtonStyled, {\n            onClick: () => props.onClose(),\n            get children() {\n              return createComponent(Translation, {\n                translationKey: \"common.close\",\n                children: \"Close\"\n              });\n            }\n          });\n        }\n      }), createComponent(Show, {\n        get when() {\n          return props.showButton === \"open-wallet\" && universalLink;\n        },\n        get children() {\n          return createComponent(ButtonStyled, {\n            onClick: onOpenWallet,\n            get children() {\n              return createComponent(Translation, {\n                translationKey: \"common.openWallet\",\n                children: \"Open wallet\"\n              });\n            }\n          });\n        }\n      })];\n    }\n  }));\n};\nconst ConfirmTransactionModal = (props) => {\n  var _a;\n  const tonConnectUI = useContext(TonConnectUiContext);\n  const [t2] = useI18n();\n  const name = ((_a = tonConnectUI.wallet) == null ? void 0 : _a.name) || t2(\"common.yourWallet\", {}, \"your wallet\");\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.confirmTransaction.header\",\n    headerTranslationValues: {\n      name\n    },\n    textTranslationKey: \"actionModal.confirmTransaction.text\",\n    get icon() {\n      return createComponent(LoaderIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    showButton: \"open-wallet\",\n    \"data-tc-confirm-modal\": \"true\"\n  });\n};\nconst TransactionCanceledModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.transactionCanceled.header\",\n    textTranslationKey: \"actionModal.transactionCanceled.text\",\n    get icon() {\n      return createComponent(ErrorIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-transaction-canceled-modal\": \"true\"\n  });\n};\nconst TransactionSentModal = (props) => {\n  return createComponent(ActionModal, {\n    headerTranslationKey: \"actionModal.transactionSent.header\",\n    textTranslationKey: \"actionModal.transactionSent.text\",\n    get icon() {\n      return createComponent(SuccessIcon, {\n        size: \"m\"\n      });\n    },\n    onClose: () => props.onClose(),\n    \"data-tc-transaction-sent-modal\": \"true\"\n  });\n};\nconst ActionsModal = () => {\n  return createComponent(Modal, {\n    get opened() {\n      var _a;\n      return createMemo(() => action() !== null)() && ((_a = action()) == null ? void 0 : _a.openModal) === true;\n    },\n    onClose: () => setAction(null),\n    \"data-tc-actions-modal-container\": \"true\",\n    get children() {\n      return createComponent(Switch, {\n        get children() {\n          return [createComponent(Match, {\n            get when() {\n              return action().name === \"transaction-sent\";\n            },\n            get children() {\n              return createComponent(TransactionSentModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"transaction-canceled\";\n            },\n            get children() {\n              return createComponent(TransactionCanceledModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          }), createComponent(Match, {\n            get when() {\n              return action().name === \"confirm-transaction\";\n            },\n            get children() {\n              return createComponent(ConfirmTransactionModal, {\n                onClose: () => setAction(null)\n              });\n            }\n          })];\n        }\n      });\n    }\n  });\n};\nconst App = (props) => {\n  const translations = createI18nContext(i18nDictionary, appState.language);\n  defineStylesRoot();\n  fixMobileSafariActiveTransition();\n  return createComponent(I18nContext.Provider, {\n    value: translations,\n    get children() {\n      return createComponent(TonConnectUiContext.Provider, {\n        get value() {\n          return props.tonConnectUI;\n        },\n        get children() {\n          return createComponent(ConnectorContext.Provider, {\n            get value() {\n              return appState.connector;\n            },\n            get children() {\n              return [createComponent(GlobalStyles, {}), createComponent(ThemeProvider, {\n                theme: themeState,\n                get children() {\n                  return [createComponent(Show, {\n                    get when() {\n                      return appState.buttonRootId;\n                    },\n                    get children() {\n                      return createComponent(Portal, {\n                        get mount() {\n                          return document.getElementById(appState.buttonRootId);\n                        },\n                        get children() {\n                          return createComponent(AccountButton, {});\n                        }\n                      });\n                    }\n                  }), createComponent(Dynamic, {\n                    component: globalStylesTag,\n                    get children() {\n                      return [createComponent(WalletsModal, {}), createComponent(ActionsModal, {})];\n                    }\n                  })];\n                }\n              })];\n            }\n          });\n        }\n      });\n    }\n  });\n};\nconst widgetController = {\n  openWalletsModal: () => void setTimeout(() => setWalletsModalOpen(true)),\n  closeWalletsModal: () => void setTimeout(() => setWalletsModalOpen(false)),\n  setAction: (action2) => void setTimeout(() => setAction(action2)),\n  clearAction: () => void setTimeout(() => setAction(null)),\n  getSelectedWalletInfo: () => lastSelectedWalletInfo(),\n  renderApp: (root, tonConnectUI) => render(() => createComponent(App, {\n    tonConnectUI\n  }), document.getElementById(root))\n};\nclass WalletInfoStorage {\n  constructor() {\n    __publicField(this, \"localStorage\");\n    __publicField(this, \"storageKey\", \"ton-connect-ui_wallet-info\");\n    checkLocalStorageExists();\n    this.localStorage = localStorage;\n  }\n  setWalletInfo(walletInfo) {\n    this.localStorage.setItem(this.storageKey, JSON.stringify(walletInfo));\n  }\n  getWalletInfo() {\n    const walletInfoString = this.localStorage.getItem(this.storageKey);\n    if (!walletInfoString) {\n      return null;\n    }\n    return JSON.parse(walletInfoString);\n  }\n  removeWalletInfo() {\n    this.localStorage.removeItem(this.storageKey);\n  }\n}\nclass PreferredWalletStorage {\n  constructor() {\n    __publicField(this, \"localStorage\");\n    __publicField(this, \"storageKey\", \"ton-connect-ui_preferred-wallet\");\n    checkLocalStorageExists();\n    this.localStorage = localStorage;\n  }\n  setPreferredWalletName(name) {\n    this.localStorage.setItem(this.storageKey, name);\n  }\n  getPreferredWalletName() {\n    return this.localStorage.getItem(this.storageKey) || void 0;\n  }\n}\nclass TonConnectUI {\n  constructor(options) {\n    __publicField(this, \"walletInfoStorage\", new WalletInfoStorage());\n    __publicField(this, \"preferredWalletStorage\", new PreferredWalletStorage());\n    __publicField(this, \"connector\");\n    __publicField(this, \"walletInfo\", null);\n    __publicField(this, \"systemThemeChangeUnsubscribe\", null);\n    __publicField(this, \"actionsConfiguration\");\n    __publicField(this, \"walletsList\");\n    __publicField(this, \"connectRequestParametersCallback\");\n    __publicField(this, \"connectionRestored\", Promise.resolve(false));\n    if (options && \"connector\" in options && options.connector) {\n      this.connector = options.connector;\n    } else if (options && \"manifestUrl\" in options && options.manifestUrl) {\n      this.connector = new _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect({ manifestUrl: options.manifestUrl });\n    } else {\n      throw new TonConnectUIError(\n        \"You have to specify a `manifestUrl` or a `connector` in the options.\"\n      );\n    }\n    this.walletsList = this.getWallets();\n    this.walletsList.then((list) => preloadImages(uniq(list.map((item) => item.imageUrl))));\n    const rootId = this.normalizeWidgetRoot(options == null ? void 0 : options.widgetRootId);\n    this.subscribeToWalletChange();\n    if ((options == null ? void 0 : options.restoreConnection) !== false) {\n      this.connectionRestored = new Promise((resolve) => __async(this, null, function* () {\n        yield this.connector.restoreConnection();\n        if (!this.connector.connected) {\n          this.walletInfoStorage.removeWalletInfo();\n        }\n        resolve(this.connector.connected);\n      }));\n    }\n    this.uiOptions = mergeOptions(options, { uiPreferences: { theme: \"SYSTEM\" } });\n    const preferredWalletName = this.preferredWalletStorage.getPreferredWalletName();\n    setAppState({\n      connector: this.connector,\n      preferredWalletName\n    });\n    widgetController.renderApp(rootId, this);\n  }\n  static getWallets() {\n    return _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnect.getWallets();\n  }\n  get connected() {\n    return this.connector.connected;\n  }\n  get account() {\n    return this.connector.account;\n  }\n  get wallet() {\n    if (!this.connector.wallet || !this.walletInfo) {\n      return null;\n    }\n    return __spreadValues(__spreadValues({}, this.connector.wallet), this.walletInfo);\n  }\n  set uiOptions(options) {\n    var _a, _b, _c, _d, _e;\n    this.checkButtonRootExist(options.buttonRootId);\n    this.actionsConfiguration = options.actionsConfiguration;\n    if ((_a = options.uiPreferences) == null ? void 0 : _a.theme) {\n      if (((_b = options.uiPreferences) == null ? void 0 : _b.theme) !== \"SYSTEM\") {\n        (_c = this.systemThemeChangeUnsubscribe) == null ? void 0 : _c.call(this);\n        setTheme(options.uiPreferences.theme, options.uiPreferences.colorsSet);\n      } else {\n        setTheme(getSystemTheme(), options.uiPreferences.colorsSet);\n        if (!this.systemThemeChangeUnsubscribe) {\n          this.systemThemeChangeUnsubscribe = subscribeToThemeChange(setTheme);\n        }\n      }\n    } else {\n      if ((_d = options.uiPreferences) == null ? void 0 : _d.colorsSet) {\n        setColors(options.uiPreferences.colorsSet);\n      }\n    }\n    if ((_e = options.uiPreferences) == null ? void 0 : _e.borderRadius) {\n      setBorderRadius(options.uiPreferences.borderRadius);\n    }\n    setAppState((state) => {\n      var _a2;\n      const merged = mergeOptions(\n        __spreadValues(__spreadValues(__spreadValues({}, options.language && { language: options.language }), !!((_a2 = options.actionsConfiguration) == null ? void 0 : _a2.returnStrategy) && {\n          returnStrategy: options.actionsConfiguration.returnStrategy\n        }), !!options.walletsListConfiguration && {\n          walletsListConfiguration: options.walletsListConfiguration\n        }),\n        unwrap(state)\n      );\n      if (options.buttonRootId !== void 0) {\n        merged.buttonRootId = options.buttonRootId;\n      }\n      return merged;\n    });\n  }\n  setConnectRequestParameters(connectRequestParameters) {\n    var _a;\n    setAppState({ connectRequestParameters });\n    if ((connectRequestParameters == null ? void 0 : connectRequestParameters.state) === \"ready\" || !connectRequestParameters) {\n      (_a = this.connectRequestParametersCallback) == null ? void 0 : _a.call(this, connectRequestParameters == null ? void 0 : connectRequestParameters.value);\n    }\n  }\n  getWallets() {\n    return __async(this, null, function* () {\n      return this.connector.getWallets();\n    });\n  }\n  onStatusChange(callback, errorsHandler) {\n    return this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n      if (wallet) {\n        const lastSelectedWalletInfo2 = yield this.getSelectedWalletInfo(wallet);\n        callback(__spreadValues(__spreadValues({}, wallet), lastSelectedWalletInfo2 || this.walletInfoStorage.getWalletInfo()));\n      } else {\n        callback(wallet);\n      }\n    }), errorsHandler);\n  }\n  connectWallet() {\n    return __async(this, null, function* () {\n      const walletsList = yield this.getWallets();\n      const embeddedWallet = walletsList.find(_tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.isWalletInfoCurrentlyEmbedded);\n      if (embeddedWallet) {\n        const connect = (parameters) => {\n          setLastSelectedWalletInfo(embeddedWallet);\n          this.connector.connect({ jsBridgeKey: embeddedWallet.jsBridgeKey }, parameters);\n        };\n        const additionalRequest = appState.connectRequestParameters;\n        if ((additionalRequest == null ? void 0 : additionalRequest.state) === \"loading\") {\n          this.connectRequestParametersCallback = connect;\n        } else {\n          connect(additionalRequest == null ? void 0 : additionalRequest.value);\n        }\n      } else {\n        widgetController.openWalletsModal();\n      }\n      return new Promise((resolve, reject) => {\n        const unsubscribe = this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n          unsubscribe();\n          if (wallet) {\n            const lastSelectedWalletInfo2 = yield this.getSelectedWalletInfo(wallet);\n            resolve(__spreadValues(__spreadValues({}, wallet), lastSelectedWalletInfo2 || this.walletInfoStorage.getWalletInfo()));\n          } else {\n            reject(new TonConnectUIError(\"Wallet was not connected\"));\n          }\n        }), reject);\n      });\n    });\n  }\n  disconnect() {\n    widgetController.clearAction();\n    this.walletInfoStorage.removeWalletInfo();\n    return this.connector.disconnect();\n  }\n  sendTransaction(tx, options) {\n    return __async(this, null, function* () {\n      if (!this.connected || !this.walletInfo) {\n        throw new TonConnectUIError(\"Connect wallet to send a transaction.\");\n      }\n      const { notifications: notifications2, modals, returnStrategy, skipRedirectToWallet } = this.getModalsAndNotificationsConfiguration(options);\n      const userOSIsIos = getUserAgent().os === \"ios\";\n      const shouldSkipRedirectToWallet = skipRedirectToWallet === \"ios\" && userOSIsIos || skipRedirectToWallet === \"always\";\n      if (\"universalLink\" in this.walletInfo && this.walletInfo.openMethod === \"universal-link\" && !shouldSkipRedirectToWallet) {\n        openLink(addReturnStrategy(this.walletInfo.universalLink, returnStrategy));\n      }\n      widgetController.setAction({\n        name: \"confirm-transaction\",\n        showNotification: notifications2.includes(\"before\"),\n        openModal: modals.includes(\"before\")\n      });\n      try {\n        const result = yield this.connector.sendTransaction(tx);\n        widgetController.setAction({\n          name: \"transaction-sent\",\n          showNotification: notifications2.includes(\"success\"),\n          openModal: modals.includes(\"success\")\n        });\n        return result;\n      } catch (e2) {\n        widgetController.setAction({\n          name: \"transaction-canceled\",\n          showNotification: notifications2.includes(\"error\"),\n          openModal: modals.includes(\"error\")\n        });\n        if (e2 instanceof _tonconnect_sdk__WEBPACK_IMPORTED_MODULE_0__.TonConnectError) {\n          throw e2;\n        } else {\n          console.error(e2);\n          throw new TonConnectUIError(\"Unhandled error:\" + e2);\n        }\n      }\n    });\n  }\n  subscribeToWalletChange() {\n    this.connector.onStatusChange((wallet) => __async(this, null, function* () {\n      var _a;\n      if (wallet) {\n        yield this.updateWalletInfo(wallet);\n        this.setPreferredWalletName(((_a = this.walletInfo) == null ? void 0 : _a.appName) || wallet.device.appName);\n      } else {\n        this.walletInfoStorage.removeWalletInfo();\n      }\n    }));\n  }\n  setPreferredWalletName(value) {\n    this.preferredWalletStorage.setPreferredWalletName(value);\n    setAppState({ preferredWalletName: value });\n  }\n  getSelectedWalletInfo(wallet) {\n    return __async(this, null, function* () {\n      let lastSelectedWalletInfo2 = widgetController.getSelectedWalletInfo();\n      if (!lastSelectedWalletInfo2) {\n        return null;\n      }\n      let fullLastSelectedWalletInfo;\n      if (!(\"name\" in lastSelectedWalletInfo2)) {\n        const walletsList = applyWalletsListConfiguration(\n          yield this.walletsList,\n          appState.walletsListConfiguration\n        );\n        const walletInfo = walletsList.find((item) => eqWalletName(item, wallet.device.appName));\n        if (!walletInfo) {\n          throw new TonConnectUIError(\n            `Cannot find WalletInfo for the '${wallet.device.appName}' wallet`\n          );\n        }\n        fullLastSelectedWalletInfo = __spreadValues(__spreadValues({}, walletInfo), lastSelectedWalletInfo2);\n      } else {\n        fullLastSelectedWalletInfo = lastSelectedWalletInfo2;\n      }\n      return fullLastSelectedWalletInfo;\n    });\n  }\n  updateWalletInfo(wallet) {\n    return __async(this, null, function* () {\n      const selectedWalletInfo = yield this.getSelectedWalletInfo(wallet);\n      if (selectedWalletInfo) {\n        this.walletInfo = selectedWalletInfo;\n        this.walletInfoStorage.setWalletInfo(selectedWalletInfo);\n      } else {\n        this.walletInfo = this.walletInfoStorage.getWalletInfo();\n      }\n    });\n  }\n  normalizeWidgetRoot(rootId) {\n    if (!rootId || !document.getElementById(rootId)) {\n      rootId = \"tc-widget-root\";\n      const rootElement = document.createElement(\"div\");\n      rootElement.id = rootId;\n      document.body.appendChild(rootElement);\n    }\n    return rootId;\n  }\n  checkButtonRootExist(buttonRootId) {\n    if (buttonRootId == null) {\n      return;\n    }\n    if (!document.getElementById(buttonRootId)) {\n      throw new TonConnectUIError(`${buttonRootId} element not found in the document.`);\n    }\n  }\n  getModalsAndNotificationsConfiguration(options) {\n    var _a, _b, _c, _d, _e;\n    const allActions = [\n      \"before\",\n      \"success\",\n      \"error\"\n    ];\n    let notifications2 = allActions;\n    if (((_a = this.actionsConfiguration) == null ? void 0 : _a.notifications) && ((_b = this.actionsConfiguration) == null ? void 0 : _b.notifications) !== \"all\") {\n      notifications2 = this.actionsConfiguration.notifications;\n    }\n    if (options == null ? void 0 : options.notifications) {\n      if (options.notifications === \"all\") {\n        notifications2 = allActions;\n      } else {\n        notifications2 = options.notifications;\n      }\n    }\n    let modals = [\"before\"];\n    if ((_c = this.actionsConfiguration) == null ? void 0 : _c.modals) {\n      if (this.actionsConfiguration.modals === \"all\") {\n        modals = allActions;\n      } else {\n        modals = this.actionsConfiguration.modals;\n      }\n    }\n    if (options == null ? void 0 : options.modals) {\n      if (options.modals === \"all\") {\n        modals = allActions;\n      } else {\n        modals = options.modals;\n      }\n    }\n    const returnStrategy = (options == null ? void 0 : options.returnStrategy) || ((_d = this.actionsConfiguration) == null ? void 0 : _d.returnStrategy) || \"back\";\n    const skipRedirectToWallet = (options == null ? void 0 : options.skipRedirectToWallet) || ((_e = this.actionsConfiguration) == null ? void 0 : _e.skipRedirectToWallet) || \"ios\";\n    return {\n      notifications: notifications2,\n      modals,\n      returnStrategy,\n      skipRedirectToWallet\n    };\n  }\n}\n\n//# sourceMappingURL=index.js.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWkvbGliL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsNkRBQTZEO0FBQzNJO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQzhLO0FBQzlJO0FBQ0U7QUFDRTtBQUNSO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFlBQVksd0JBQXdCLEVBQUUsNkJBQTZCO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixrQkFBa0I7QUFDekM7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw0QkFBNEI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLEtBQUs7QUFDbkIsWUFBWSxFQUFDO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVM7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQixnQkFBZ0IsS0FBSztBQUNyQixNQUFNO0FBQ04sZ0JBQWdCLEtBQUs7QUFDckIsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLHlDQUF5QztBQUN6QywyQ0FBMkM7QUFDM0M7QUFDQSxzQ0FBc0MsVUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsVUFBVTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFO0FBQ2hFLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFD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SztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxHQUFHLEtBQUssR0FBRztBQUMvQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsZ0JBQWdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHVCQUF1QjtBQUNqRCw0QkFBNEIsdUJBQXVCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDLDRCQUE0Qix1QkFBdUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixtQkFBbUI7QUFDN0MsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQW1CO0FBQzdDLDRCQUE0QixtQkFBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVE7QUFDL0I7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsVUFBVTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QiwwQkFBMEI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix3QkFBd0I7QUFDakQsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHdCQUF3QjtBQUNqRDtBQUNBO0FBQ0EseUJBQXlCLHFCQUFxQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixhQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixVQUFVO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsb0JBQW9CO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGdCQUFnQjtBQUN6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RUEsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FB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O0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUtFO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZW1laW5kZXgtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWkvbGliL2luZGV4LmpzP2ZiNzMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2RlZlByb3BzID0gT2JqZWN0LmRlZmluZVByb3BlcnRpZXM7XG52YXIgX19nZXRPd25Qcm9wRGVzY3MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycztcbnZhciBfX2dldE93blByb3BTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fcHJvcElzRW51bSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19zcHJlYWRWYWx1ZXMgPSAoYTIsIGIpID0+IHtcbiAgZm9yICh2YXIgcHJvcCBpbiBiIHx8IChiID0ge30pKVxuICAgIGlmIChfX2hhc093blByb3AuY2FsbChiLCBwcm9wKSlcbiAgICAgIF9fZGVmTm9ybWFsUHJvcChhMiwgcHJvcCwgYltwcm9wXSk7XG4gIGlmIChfX2dldE93blByb3BTeW1ib2xzKVxuICAgIGZvciAodmFyIHByb3Agb2YgX19nZXRPd25Qcm9wU3ltYm9scyhiKSkge1xuICAgICAgaWYgKF9fcHJvcElzRW51bS5jYWxsKGIsIHByb3ApKVxuICAgICAgICBfX2RlZk5vcm1hbFByb3AoYTIsIHByb3AsIGJbcHJvcF0pO1xuICAgIH1cbiAgcmV0dXJuIGEyO1xufTtcbnZhciBfX3NwcmVhZFByb3BzID0gKGEyLCBiKSA9PiBfX2RlZlByb3BzKGEyLCBfX2dldE93blByb3BEZXNjcyhiKSk7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IHtcbiAgX19kZWZOb3JtYWxQcm9wKG9iaiwgdHlwZW9mIGtleSAhPT0gXCJzeW1ib2xcIiA/IGtleSArIFwiXCIgOiBrZXksIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcbnZhciBfX2FzeW5jID0gKF9fdGhpcywgX19hcmd1bWVudHMsIGdlbmVyYXRvcikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHZhciBmdWxmaWxsZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUyKSB7XG4gICAgICAgIHJlamVjdChlMik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ZWQgPSAodmFsdWUpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0ZXAoZ2VuZXJhdG9yLnRocm93KHZhbHVlKSk7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICByZWplY3QoZTIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHN0ZXAgPSAoeCkgPT4geC5kb25lID8gcmVzb2x2ZSh4LnZhbHVlKSA6IFByb21pc2UucmVzb2x2ZSh4LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpO1xuICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseShfX3RoaXMsIF9fYXJndW1lbnRzKSkubmV4dCgpKTtcbiAgfSk7XG59O1xuaW1wb3J0IHsgVG9uQ29ubmVjdEVycm9yLCB0b1VzZXJGcmllbmRseUFkZHJlc3MsIENIQUlOLCBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZCwgVG9uQ29ubmVjdCwgaXNXYWxsZXRJbmZvUmVtb3RlLCBpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCB9IGZyb20gXCJAdG9uY29ubmVjdC9zZGtcIjtcbmV4cG9ydCAqIGZyb20gXCJAdG9uY29ubmVjdC9zZGtcIjtcbmltcG9ydCBkZWVwbWVyZ2UgZnJvbSBcImRlZXBtZXJnZVwiO1xuaW1wb3J0IFVBUGFyc2VyIGZyb20gXCJ1YS1wYXJzZXItanNcIjtcbmltcG9ydCBjbiBmcm9tIFwiY2xhc3NuYW1lc1wiO1xuY29uc3Qgc2hhcmVkQ29uZmlnID0ge307XG5mdW5jdGlvbiBzZXRIeWRyYXRlQ29udGV4dChjb250ZXh0KSB7XG4gIHNoYXJlZENvbmZpZy5jb250ZXh0ID0gY29udGV4dDtcbn1cbmNvbnN0IGVxdWFsRm4gPSAoYTIsIGIpID0+IGEyID09PSBiO1xuY29uc3QgJFBST1hZID0gU3ltYm9sKFwic29saWQtcHJveHlcIik7XG5jb25zdCAkVFJBQ0sgPSBTeW1ib2woXCJzb2xpZC10cmFja1wiKTtcbmNvbnN0IHNpZ25hbE9wdGlvbnMgPSB7XG4gIGVxdWFsczogZXF1YWxGblxufTtcbmxldCBydW5FZmZlY3RzID0gcnVuUXVldWU7XG5jb25zdCBTVEFMRSA9IDE7XG5jb25zdCBQRU5ESU5HID0gMjtcbmNvbnN0IFVOT1dORUQgPSB7XG4gIG93bmVkOiBudWxsLFxuICBjbGVhbnVwczogbnVsbCxcbiAgY29udGV4dDogbnVsbCxcbiAgb3duZXI6IG51bGxcbn07XG5jb25zdCBOT19JTklUID0ge307XG52YXIgT3duZXIgPSBudWxsO1xubGV0IFRyYW5zaXRpb24kMSA9IG51bGw7XG5sZXQgTGlzdGVuZXIgPSBudWxsO1xubGV0IFVwZGF0ZXMgPSBudWxsO1xubGV0IEVmZmVjdHMgPSBudWxsO1xubGV0IEV4ZWNDb3VudCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVSb290KGZuLCBkZXRhY2hlZE93bmVyKSB7XG4gIGNvbnN0IGxpc3RlbmVyID0gTGlzdGVuZXIsIG93bmVyID0gT3duZXIsIHVub3duZWQgPSBmbi5sZW5ndGggPT09IDAsIHJvb3QgPSB1bm93bmVkID8gVU5PV05FRCA6IHtcbiAgICBvd25lZDogbnVsbCxcbiAgICBjbGVhbnVwczogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIG93bmVyOiBkZXRhY2hlZE93bmVyID09PSB2b2lkIDAgPyBvd25lciA6IGRldGFjaGVkT3duZXJcbiAgfSwgdXBkYXRlRm4gPSB1bm93bmVkID8gZm4gOiAoKSA9PiBmbigoKSA9PiB1bnRyYWNrKCgpID0+IGNsZWFuTm9kZShyb290KSkpO1xuICBPd25lciA9IHJvb3Q7XG4gIExpc3RlbmVyID0gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gcnVuVXBkYXRlcyh1cGRhdGVGbiwgdHJ1ZSk7XG4gIH0gZmluYWxseSB7XG4gICAgTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICBPd25lciA9IG93bmVyO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVTaWduYWwodmFsdWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBzaWduYWxPcHRpb25zLCBvcHRpb25zKSA6IHNpZ25hbE9wdGlvbnM7XG4gIGNvbnN0IHMyID0ge1xuICAgIHZhbHVlLFxuICAgIG9ic2VydmVyczogbnVsbCxcbiAgICBvYnNlcnZlclNsb3RzOiBudWxsLFxuICAgIGNvbXBhcmF0b3I6IG9wdGlvbnMuZXF1YWxzIHx8IHZvaWQgMFxuICB9O1xuICBjb25zdCBzZXR0ZXIgPSAodmFsdWUyKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZTIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdmFsdWUyID0gdmFsdWUyKHMyLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHdyaXRlU2lnbmFsKHMyLCB2YWx1ZTIpO1xuICB9O1xuICByZXR1cm4gW3JlYWRTaWduYWwuYmluZChzMiksIHNldHRlcl07XG59XG5mdW5jdGlvbiBjcmVhdGVDb21wdXRlZChmbiwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgYzIgPSBjcmVhdGVDb21wdXRhdGlvbihmbiwgdmFsdWUsIHRydWUsIFNUQUxFKTtcbiAgdXBkYXRlQ29tcHV0YXRpb24oYzIpO1xufVxuZnVuY3Rpb24gY3JlYXRlUmVuZGVyRWZmZWN0KGZuLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBjMiA9IGNyZWF0ZUNvbXB1dGF0aW9uKGZuLCB2YWx1ZSwgZmFsc2UsIFNUQUxFKTtcbiAgdXBkYXRlQ29tcHV0YXRpb24oYzIpO1xufVxuZnVuY3Rpb24gY3JlYXRlRWZmZWN0KGZuLCB2YWx1ZSwgb3B0aW9ucykge1xuICBydW5FZmZlY3RzID0gcnVuVXNlckVmZmVjdHM7XG4gIGNvbnN0IGMyID0gY3JlYXRlQ29tcHV0YXRpb24oZm4sIHZhbHVlLCBmYWxzZSwgU1RBTEUpO1xuICBjMi51c2VyID0gdHJ1ZTtcbiAgRWZmZWN0cyA/IEVmZmVjdHMucHVzaChjMikgOiB1cGRhdGVDb21wdXRhdGlvbihjMik7XG59XG5mdW5jdGlvbiBjcmVhdGVNZW1vKGZuLCB2YWx1ZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIHNpZ25hbE9wdGlvbnMsIG9wdGlvbnMpIDogc2lnbmFsT3B0aW9ucztcbiAgY29uc3QgYzIgPSBjcmVhdGVDb21wdXRhdGlvbihmbiwgdmFsdWUsIHRydWUsIDApO1xuICBjMi5vYnNlcnZlcnMgPSBudWxsO1xuICBjMi5vYnNlcnZlclNsb3RzID0gbnVsbDtcbiAgYzIuY29tcGFyYXRvciA9IG9wdGlvbnMuZXF1YWxzIHx8IHZvaWQgMDtcbiAgdXBkYXRlQ29tcHV0YXRpb24oYzIpO1xuICByZXR1cm4gcmVhZFNpZ25hbC5iaW5kKGMyKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc291cmNlKHBTb3VyY2UsIHBGZXRjaGVyLCBwT3B0aW9ucykge1xuICBsZXQgc291cmNlO1xuICBsZXQgZmV0Y2hlcjtcbiAgbGV0IG9wdGlvbnM7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyICYmIHR5cGVvZiBwRmV0Y2hlciA9PT0gXCJvYmplY3RcIiB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgc291cmNlID0gdHJ1ZTtcbiAgICBmZXRjaGVyID0gcFNvdXJjZTtcbiAgICBvcHRpb25zID0gcEZldGNoZXIgfHwge307XG4gIH0gZWxzZSB7XG4gICAgc291cmNlID0gcFNvdXJjZTtcbiAgICBmZXRjaGVyID0gcEZldGNoZXI7XG4gICAgb3B0aW9ucyA9IHBPcHRpb25zIHx8IHt9O1xuICB9XG4gIGxldCBwciA9IG51bGwsIGluaXRQID0gTk9fSU5JVCwgaWQgPSBudWxsLCBzY2hlZHVsZWQgPSBmYWxzZSwgcmVzb2x2ZWQgPSBcImluaXRpYWxWYWx1ZVwiIGluIG9wdGlvbnMsIGR5bmFtaWMgPSB0eXBlb2Ygc291cmNlID09PSBcImZ1bmN0aW9uXCIgJiYgY3JlYXRlTWVtbyhzb3VyY2UpO1xuICBjb25zdCBjb250ZXh0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksIFt2YWx1ZSwgc2V0VmFsdWVdID0gKG9wdGlvbnMuc3RvcmFnZSB8fCBjcmVhdGVTaWduYWwpKG9wdGlvbnMuaW5pdGlhbFZhbHVlKSwgW2Vycm9yLCBzZXRFcnJvcl0gPSBjcmVhdGVTaWduYWwodm9pZCAwKSwgW3RyYWNrLCB0cmlnZ2VyXSA9IGNyZWF0ZVNpZ25hbCh2b2lkIDAsIHtcbiAgICBlcXVhbHM6IGZhbHNlXG4gIH0pLCBbc3RhdGUsIHNldFN0YXRlXSA9IGNyZWF0ZVNpZ25hbChyZXNvbHZlZCA/IFwicmVhZHlcIiA6IFwidW5yZXNvbHZlZFwiKTtcbiAgaWYgKHNoYXJlZENvbmZpZy5jb250ZXh0KSB7XG4gICAgaWQgPSBgJHtzaGFyZWRDb25maWcuY29udGV4dC5pZH0ke3NoYXJlZENvbmZpZy5jb250ZXh0LmNvdW50Kyt9YDtcbiAgICBsZXQgdjtcbiAgICBpZiAob3B0aW9ucy5zc3JMb2FkRnJvbSA9PT0gXCJpbml0aWFsXCIpXG4gICAgICBpbml0UCA9IG9wdGlvbnMuaW5pdGlhbFZhbHVlO1xuICAgIGVsc2UgaWYgKHNoYXJlZENvbmZpZy5sb2FkICYmICh2ID0gc2hhcmVkQ29uZmlnLmxvYWQoaWQpKSlcbiAgICAgIGluaXRQID0gdlswXTtcbiAgfVxuICBmdW5jdGlvbiBsb2FkRW5kKHAyLCB2LCBlcnJvcjIsIGtleSkge1xuICAgIGlmIChwciA9PT0gcDIpIHtcbiAgICAgIHByID0gbnVsbDtcbiAgICAgIHJlc29sdmVkID0gdHJ1ZTtcbiAgICAgIGlmICgocDIgPT09IGluaXRQIHx8IHYgPT09IGluaXRQKSAmJiBvcHRpb25zLm9uSHlkcmF0ZWQpXG4gICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IG9wdGlvbnMub25IeWRyYXRlZChrZXksIHtcbiAgICAgICAgICB2YWx1ZTogdlxuICAgICAgICB9KSk7XG4gICAgICBpbml0UCA9IE5PX0lOSVQ7XG4gICAgICBjb21wbGV0ZUxvYWQodiwgZXJyb3IyKTtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG4gIH1cbiAgZnVuY3Rpb24gY29tcGxldGVMb2FkKHYsIGVycikge1xuICAgIHJ1blVwZGF0ZXMoKCkgPT4ge1xuICAgICAgaWYgKGVyciA9PT0gdm9pZCAwKVxuICAgICAgICBzZXRWYWx1ZSgoKSA9PiB2KTtcbiAgICAgIHNldFN0YXRlKGVyciAhPT0gdm9pZCAwID8gXCJlcnJvcmVkXCIgOiBcInJlYWR5XCIpO1xuICAgICAgc2V0RXJyb3IoZXJyKTtcbiAgICAgIGZvciAoY29uc3QgYzIgb2YgY29udGV4dHMua2V5cygpKVxuICAgICAgICBjMi5kZWNyZW1lbnQoKTtcbiAgICAgIGNvbnRleHRzLmNsZWFyKCk7XG4gICAgfSwgZmFsc2UpO1xuICB9XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgY29uc3QgYzIgPSBTdXNwZW5zZUNvbnRleHQsIHYgPSB2YWx1ZSgpLCBlcnIgPSBlcnJvcigpO1xuICAgIGlmIChlcnIgIT09IHZvaWQgMCAmJiAhcHIpXG4gICAgICB0aHJvdyBlcnI7XG4gICAgaWYgKExpc3RlbmVyICYmICFMaXN0ZW5lci51c2VyICYmIGMyKSB7XG4gICAgICBjcmVhdGVDb21wdXRlZCgoKSA9PiB7XG4gICAgICAgIHRyYWNrKCk7XG4gICAgICAgIGlmIChwcikge1xuICAgICAgICAgIGlmIChjMi5yZXNvbHZlZClcbiAgICAgICAgICAgIDtcbiAgICAgICAgICBlbHNlIGlmICghY29udGV4dHMuaGFzKGMyKSkge1xuICAgICAgICAgICAgYzIuaW5jcmVtZW50KCk7XG4gICAgICAgICAgICBjb250ZXh0cy5hZGQoYzIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB2O1xuICB9XG4gIGZ1bmN0aW9uIGxvYWQocmVmZXRjaGluZyA9IHRydWUpIHtcbiAgICBpZiAocmVmZXRjaGluZyAhPT0gZmFsc2UgJiYgc2NoZWR1bGVkKVxuICAgICAgcmV0dXJuO1xuICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGxvb2t1cDIgPSBkeW5hbWljID8gZHluYW1pYygpIDogc291cmNlO1xuICAgIGlmIChsb29rdXAyID09IG51bGwgfHwgbG9va3VwMiA9PT0gZmFsc2UpIHtcbiAgICAgIGxvYWRFbmQocHIsIHVudHJhY2sodmFsdWUpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcDIgPSBpbml0UCAhPT0gTk9fSU5JVCA/IGluaXRQIDogdW50cmFjaygoKSA9PiBmZXRjaGVyKGxvb2t1cDIsIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSgpLFxuICAgICAgcmVmZXRjaGluZ1xuICAgIH0pKTtcbiAgICBpZiAodHlwZW9mIHAyICE9PSBcIm9iamVjdFwiIHx8ICEocDIgJiYgXCJ0aGVuXCIgaW4gcDIpKSB7XG4gICAgICBsb2FkRW5kKHByLCBwMiwgdm9pZCAwLCBsb29rdXAyKTtcbiAgICAgIHJldHVybiBwMjtcbiAgICB9XG4gICAgcHIgPSBwMjtcbiAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IHNjaGVkdWxlZCA9IGZhbHNlKTtcbiAgICBydW5VcGRhdGVzKCgpID0+IHtcbiAgICAgIHNldFN0YXRlKHJlc29sdmVkID8gXCJyZWZyZXNoaW5nXCIgOiBcInBlbmRpbmdcIik7XG4gICAgICB0cmlnZ2VyKCk7XG4gICAgfSwgZmFsc2UpO1xuICAgIHJldHVybiBwMi50aGVuKCh2KSA9PiBsb2FkRW5kKHAyLCB2LCB2b2lkIDAsIGxvb2t1cDIpLCAoZTIpID0+IGxvYWRFbmQocDIsIHZvaWQgMCwgY2FzdEVycm9yKGUyKSwgbG9va3VwMikpO1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHJlYWQsIHtcbiAgICBzdGF0ZToge1xuICAgICAgZ2V0OiAoKSA9PiBzdGF0ZSgpXG4gICAgfSxcbiAgICBlcnJvcjoge1xuICAgICAgZ2V0OiAoKSA9PiBlcnJvcigpXG4gICAgfSxcbiAgICBsb2FkaW5nOiB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIGNvbnN0IHMyID0gc3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIHMyID09PSBcInBlbmRpbmdcIiB8fCBzMiA9PT0gXCJyZWZyZXNoaW5nXCI7XG4gICAgICB9XG4gICAgfSxcbiAgICBsYXRlc3Q6IHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICByZXR1cm4gcmVhZCgpO1xuICAgICAgICBjb25zdCBlcnIgPSBlcnJvcigpO1xuICAgICAgICBpZiAoZXJyICYmICFwcilcbiAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIHJldHVybiB2YWx1ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGlmIChkeW5hbWljKVxuICAgIGNyZWF0ZUNvbXB1dGVkKCgpID0+IGxvYWQoZmFsc2UpKTtcbiAgZWxzZVxuICAgIGxvYWQoZmFsc2UpO1xuICByZXR1cm4gW3JlYWQsIHtcbiAgICByZWZldGNoOiBsb2FkLFxuICAgIG11dGF0ZTogc2V0VmFsdWVcbiAgfV07XG59XG5mdW5jdGlvbiBiYXRjaChmbikge1xuICByZXR1cm4gcnVuVXBkYXRlcyhmbiwgZmFsc2UpO1xufVxuZnVuY3Rpb24gdW50cmFjayhmbikge1xuICBpZiAoTGlzdGVuZXIgPT09IG51bGwpXG4gICAgcmV0dXJuIGZuKCk7XG4gIGNvbnN0IGxpc3RlbmVyID0gTGlzdGVuZXI7XG4gIExpc3RlbmVyID0gbnVsbDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBMaXN0ZW5lciA9IGxpc3RlbmVyO1xuICB9XG59XG5mdW5jdGlvbiBvbihkZXBzLCBmbiwgb3B0aW9ucykge1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShkZXBzKTtcbiAgbGV0IHByZXZJbnB1dDtcbiAgbGV0IGRlZmVyID0gb3B0aW9ucyAmJiBvcHRpb25zLmRlZmVyO1xuICByZXR1cm4gKHByZXZWYWx1ZSkgPT4ge1xuICAgIGxldCBpbnB1dDtcbiAgICBpZiAoaXNBcnJheSkge1xuICAgICAgaW5wdXQgPSBBcnJheShkZXBzLmxlbmd0aCk7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgZGVwcy5sZW5ndGg7IGkyKyspXG4gICAgICAgIGlucHV0W2kyXSA9IGRlcHNbaTJdKCk7XG4gICAgfSBlbHNlXG4gICAgICBpbnB1dCA9IGRlcHMoKTtcbiAgICBpZiAoZGVmZXIpIHtcbiAgICAgIGRlZmVyID0gZmFsc2U7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB1bnRyYWNrKCgpID0+IGZuKGlucHV0LCBwcmV2SW5wdXQsIHByZXZWYWx1ZSkpO1xuICAgIHByZXZJbnB1dCA9IGlucHV0O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG59XG5mdW5jdGlvbiBvbk1vdW50KGZuKSB7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB1bnRyYWNrKGZuKSk7XG59XG5mdW5jdGlvbiBvbkNsZWFudXAoZm4pIHtcbiAgaWYgKE93bmVyID09PSBudWxsKVxuICAgIDtcbiAgZWxzZSBpZiAoT3duZXIuY2xlYW51cHMgPT09IG51bGwpXG4gICAgT3duZXIuY2xlYW51cHMgPSBbZm5dO1xuICBlbHNlXG4gICAgT3duZXIuY2xlYW51cHMucHVzaChmbik7XG4gIHJldHVybiBmbjtcbn1cbmZ1bmN0aW9uIGdldExpc3RlbmVyKCkge1xuICByZXR1cm4gTGlzdGVuZXI7XG59XG5mdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgcmV0dXJuIE93bmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlQ29udGV4dChkZWZhdWx0VmFsdWUsIG9wdGlvbnMpIHtcbiAgY29uc3QgaWQgPSBTeW1ib2woXCJjb250ZXh0XCIpO1xuICByZXR1cm4ge1xuICAgIGlkLFxuICAgIFByb3ZpZGVyOiBjcmVhdGVQcm92aWRlcihpZCksXG4gICAgZGVmYXVsdFZhbHVlXG4gIH07XG59XG5mdW5jdGlvbiB1c2VDb250ZXh0KGNvbnRleHQpIHtcbiAgbGV0IGN0eDtcbiAgcmV0dXJuIChjdHggPSBsb29rdXAoT3duZXIsIGNvbnRleHQuaWQpKSAhPT0gdm9pZCAwID8gY3R4IDogY29udGV4dC5kZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiBjaGlsZHJlbihmbikge1xuICBjb25zdCBjaGlsZHJlbjIgPSBjcmVhdGVNZW1vKGZuKTtcbiAgY29uc3QgbWVtbyA9IGNyZWF0ZU1lbW8oKCkgPT4gcmVzb2x2ZUNoaWxkcmVuKGNoaWxkcmVuMigpKSk7XG4gIG1lbW8udG9BcnJheSA9ICgpID0+IHtcbiAgICBjb25zdCBjMiA9IG1lbW8oKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShjMikgPyBjMiA6IGMyICE9IG51bGwgPyBbYzJdIDogW107XG4gIH07XG4gIHJldHVybiBtZW1vO1xufVxubGV0IFN1c3BlbnNlQ29udGV4dDtcbmZ1bmN0aW9uIHJlYWRTaWduYWwoKSB7XG4gIGNvbnN0IHJ1bm5pbmdUcmFuc2l0aW9uID0gVHJhbnNpdGlvbiQxO1xuICBpZiAodGhpcy5zb3VyY2VzICYmICh0aGlzLnN0YXRlIHx8IHJ1bm5pbmdUcmFuc2l0aW9uKSkge1xuICAgIGlmICh0aGlzLnN0YXRlID09PSBTVEFMRSB8fCBydW5uaW5nVHJhbnNpdGlvbilcbiAgICAgIHVwZGF0ZUNvbXB1dGF0aW9uKHRoaXMpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgdXBkYXRlcyA9IFVwZGF0ZXM7XG4gICAgICBVcGRhdGVzID0gbnVsbDtcbiAgICAgIHJ1blVwZGF0ZXMoKCkgPT4gbG9va1Vwc3RyZWFtKHRoaXMpLCBmYWxzZSk7XG4gICAgICBVcGRhdGVzID0gdXBkYXRlcztcbiAgICB9XG4gIH1cbiAgaWYgKExpc3RlbmVyKSB7XG4gICAgY29uc3Qgc1Nsb3QgPSB0aGlzLm9ic2VydmVycyA/IHRoaXMub2JzZXJ2ZXJzLmxlbmd0aCA6IDA7XG4gICAgaWYgKCFMaXN0ZW5lci5zb3VyY2VzKSB7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VzID0gW3RoaXNdO1xuICAgICAgTGlzdGVuZXIuc291cmNlU2xvdHMgPSBbc1Nsb3RdO1xuICAgIH0gZWxzZSB7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VzLnB1c2godGhpcyk7XG4gICAgICBMaXN0ZW5lci5zb3VyY2VTbG90cy5wdXNoKHNTbG90KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm9ic2VydmVycykge1xuICAgICAgdGhpcy5vYnNlcnZlcnMgPSBbTGlzdGVuZXJdO1xuICAgICAgdGhpcy5vYnNlcnZlclNsb3RzID0gW0xpc3RlbmVyLnNvdXJjZXMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub2JzZXJ2ZXJzLnB1c2goTGlzdGVuZXIpO1xuICAgICAgdGhpcy5vYnNlcnZlclNsb3RzLnB1c2goTGlzdGVuZXIuc291cmNlcy5sZW5ndGggLSAxKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXMudmFsdWU7XG59XG5mdW5jdGlvbiB3cml0ZVNpZ25hbChub2RlLCB2YWx1ZSwgaXNDb21wKSB7XG4gIGxldCBjdXJyZW50ID0gbm9kZS52YWx1ZTtcbiAgaWYgKCFub2RlLmNvbXBhcmF0b3IgfHwgIW5vZGUuY29tcGFyYXRvcihjdXJyZW50LCB2YWx1ZSkpIHtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgaWYgKG5vZGUub2JzZXJ2ZXJzICYmIG5vZGUub2JzZXJ2ZXJzLmxlbmd0aCkge1xuICAgICAgcnVuVXBkYXRlcygoKSA9PiB7XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBub2RlLm9ic2VydmVycy5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICBjb25zdCBvMiA9IG5vZGUub2JzZXJ2ZXJzW2kyXTtcbiAgICAgICAgICBjb25zdCBUcmFuc2l0aW9uUnVubmluZyA9IFRyYW5zaXRpb24kMSAmJiBUcmFuc2l0aW9uJDEucnVubmluZztcbiAgICAgICAgICBpZiAoVHJhbnNpdGlvblJ1bm5pbmcgJiYgVHJhbnNpdGlvbiQxLmRpc3Bvc2VkLmhhcyhvMikpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgaWYgKFRyYW5zaXRpb25SdW5uaW5nICYmICFvMi50U3RhdGUgfHwgIVRyYW5zaXRpb25SdW5uaW5nICYmICFvMi5zdGF0ZSkge1xuICAgICAgICAgICAgaWYgKG8yLnB1cmUpXG4gICAgICAgICAgICAgIFVwZGF0ZXMucHVzaChvMik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIEVmZmVjdHMucHVzaChvMik7XG4gICAgICAgICAgICBpZiAobzIub2JzZXJ2ZXJzKVxuICAgICAgICAgICAgICBtYXJrRG93bnN0cmVhbShvMik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChUcmFuc2l0aW9uUnVubmluZylcbiAgICAgICAgICAgIDtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBvMi5zdGF0ZSA9IFNUQUxFO1xuICAgICAgICB9XG4gICAgICAgIGlmIChVcGRhdGVzLmxlbmd0aCA+IDFlNikge1xuICAgICAgICAgIFVwZGF0ZXMgPSBbXTtcbiAgICAgICAgICBpZiAoZmFsc2UpXG4gICAgICAgICAgICA7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29tcHV0YXRpb24obm9kZSkge1xuICBpZiAoIW5vZGUuZm4pXG4gICAgcmV0dXJuO1xuICBjbGVhbk5vZGUobm9kZSk7XG4gIGNvbnN0IG93bmVyID0gT3duZXIsIGxpc3RlbmVyID0gTGlzdGVuZXIsIHRpbWUgPSBFeGVjQ291bnQ7XG4gIExpc3RlbmVyID0gT3duZXIgPSBub2RlO1xuICBydW5Db21wdXRhdGlvbihub2RlLCBub2RlLnZhbHVlLCB0aW1lKTtcbiAgTGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgT3duZXIgPSBvd25lcjtcbn1cbmZ1bmN0aW9uIHJ1bkNvbXB1dGF0aW9uKG5vZGUsIHZhbHVlLCB0aW1lKSB7XG4gIGxldCBuZXh0VmFsdWU7XG4gIHRyeSB7XG4gICAgbmV4dFZhbHVlID0gbm9kZS5mbih2YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChub2RlLnB1cmUpIHtcbiAgICAgIHtcbiAgICAgICAgbm9kZS5zdGF0ZSA9IFNUQUxFO1xuICAgICAgICBub2RlLm93bmVkICYmIG5vZGUub3duZWQuZm9yRWFjaChjbGVhbk5vZGUpO1xuICAgICAgICBub2RlLm93bmVkID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgfVxuICBpZiAoIW5vZGUudXBkYXRlZEF0IHx8IG5vZGUudXBkYXRlZEF0IDw9IHRpbWUpIHtcbiAgICBpZiAobm9kZS51cGRhdGVkQXQgIT0gbnVsbCAmJiBcIm9ic2VydmVyc1wiIGluIG5vZGUpIHtcbiAgICAgIHdyaXRlU2lnbmFsKG5vZGUsIG5leHRWYWx1ZSk7XG4gICAgfSBlbHNlXG4gICAgICBub2RlLnZhbHVlID0gbmV4dFZhbHVlO1xuICAgIG5vZGUudXBkYXRlZEF0ID0gdGltZTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlQ29tcHV0YXRpb24oZm4sIGluaXQsIHB1cmUsIHN0YXRlID0gU1RBTEUsIG9wdGlvbnMpIHtcbiAgY29uc3QgYzIgPSB7XG4gICAgZm4sXG4gICAgc3RhdGUsXG4gICAgdXBkYXRlZEF0OiBudWxsLFxuICAgIG93bmVkOiBudWxsLFxuICAgIHNvdXJjZXM6IG51bGwsXG4gICAgc291cmNlU2xvdHM6IG51bGwsXG4gICAgY2xlYW51cHM6IG51bGwsXG4gICAgdmFsdWU6IGluaXQsXG4gICAgb3duZXI6IE93bmVyLFxuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgcHVyZVxuICB9O1xuICBpZiAoT3duZXIgPT09IG51bGwpXG4gICAgO1xuICBlbHNlIGlmIChPd25lciAhPT0gVU5PV05FRCkge1xuICAgIHtcbiAgICAgIGlmICghT3duZXIub3duZWQpXG4gICAgICAgIE93bmVyLm93bmVkID0gW2MyXTtcbiAgICAgIGVsc2VcbiAgICAgICAgT3duZXIub3duZWQucHVzaChjMik7XG4gICAgfVxuICB9XG4gIHJldHVybiBjMjtcbn1cbmZ1bmN0aW9uIHJ1blRvcChub2RlKSB7XG4gIGNvbnN0IHJ1bm5pbmdUcmFuc2l0aW9uID0gVHJhbnNpdGlvbiQxO1xuICBpZiAobm9kZS5zdGF0ZSA9PT0gMCB8fCBydW5uaW5nVHJhbnNpdGlvbilcbiAgICByZXR1cm47XG4gIGlmIChub2RlLnN0YXRlID09PSBQRU5ESU5HIHx8IHJ1bm5pbmdUcmFuc2l0aW9uKVxuICAgIHJldHVybiBsb29rVXBzdHJlYW0obm9kZSk7XG4gIGlmIChub2RlLnN1c3BlbnNlICYmIHVudHJhY2sobm9kZS5zdXNwZW5zZS5pbkZhbGxiYWNrKSlcbiAgICByZXR1cm4gbm9kZS5zdXNwZW5zZS5lZmZlY3RzLnB1c2gobm9kZSk7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IFtub2RlXTtcbiAgd2hpbGUgKChub2RlID0gbm9kZS5vd25lcikgJiYgKCFub2RlLnVwZGF0ZWRBdCB8fCBub2RlLnVwZGF0ZWRBdCA8IEV4ZWNDb3VudCkpIHtcbiAgICBpZiAobm9kZS5zdGF0ZSB8fCBydW5uaW5nVHJhbnNpdGlvbilcbiAgICAgIGFuY2VzdG9ycy5wdXNoKG5vZGUpO1xuICB9XG4gIGZvciAobGV0IGkyID0gYW5jZXN0b3JzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICBub2RlID0gYW5jZXN0b3JzW2kyXTtcbiAgICBpZiAobm9kZS5zdGF0ZSA9PT0gU1RBTEUgfHwgcnVubmluZ1RyYW5zaXRpb24pIHtcbiAgICAgIHVwZGF0ZUNvbXB1dGF0aW9uKG5vZGUpO1xuICAgIH0gZWxzZSBpZiAobm9kZS5zdGF0ZSA9PT0gUEVORElORyB8fCBydW5uaW5nVHJhbnNpdGlvbikge1xuICAgICAgY29uc3QgdXBkYXRlcyA9IFVwZGF0ZXM7XG4gICAgICBVcGRhdGVzID0gbnVsbDtcbiAgICAgIHJ1blVwZGF0ZXMoKCkgPT4gbG9va1Vwc3RyZWFtKG5vZGUsIGFuY2VzdG9yc1swXSksIGZhbHNlKTtcbiAgICAgIFVwZGF0ZXMgPSB1cGRhdGVzO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcnVuVXBkYXRlcyhmbiwgaW5pdCkge1xuICBpZiAoVXBkYXRlcylcbiAgICByZXR1cm4gZm4oKTtcbiAgbGV0IHdhaXQgPSBmYWxzZTtcbiAgaWYgKCFpbml0KVxuICAgIFVwZGF0ZXMgPSBbXTtcbiAgaWYgKEVmZmVjdHMpXG4gICAgd2FpdCA9IHRydWU7XG4gIGVsc2VcbiAgICBFZmZlY3RzID0gW107XG4gIEV4ZWNDb3VudCsrO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGZuKCk7XG4gICAgY29tcGxldGVVcGRhdGVzKHdhaXQpO1xuICAgIHJldHVybiByZXM7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmICghd2FpdClcbiAgICAgIEVmZmVjdHMgPSBudWxsO1xuICAgIFVwZGF0ZXMgPSBudWxsO1xuICAgIGhhbmRsZUVycm9yKGVycik7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBsZXRlVXBkYXRlcyh3YWl0KSB7XG4gIGlmIChVcGRhdGVzKSB7XG4gICAgcnVuUXVldWUoVXBkYXRlcyk7XG4gICAgVXBkYXRlcyA9IG51bGw7XG4gIH1cbiAgaWYgKHdhaXQpXG4gICAgcmV0dXJuO1xuICBjb25zdCBlMiA9IEVmZmVjdHM7XG4gIEVmZmVjdHMgPSBudWxsO1xuICBpZiAoZTIubGVuZ3RoKVxuICAgIHJ1blVwZGF0ZXMoKCkgPT4gcnVuRWZmZWN0cyhlMiksIGZhbHNlKTtcbn1cbmZ1bmN0aW9uIHJ1blF1ZXVlKHF1ZXVlKSB7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBxdWV1ZS5sZW5ndGg7IGkyKyspXG4gICAgcnVuVG9wKHF1ZXVlW2kyXSk7XG59XG5mdW5jdGlvbiBydW5Vc2VyRWZmZWN0cyhxdWV1ZSkge1xuICBsZXQgaTIsIHVzZXJMZW5ndGggPSAwO1xuICBmb3IgKGkyID0gMDsgaTIgPCBxdWV1ZS5sZW5ndGg7IGkyKyspIHtcbiAgICBjb25zdCBlMiA9IHF1ZXVlW2kyXTtcbiAgICBpZiAoIWUyLnVzZXIpXG4gICAgICBydW5Ub3AoZTIpO1xuICAgIGVsc2VcbiAgICAgIHF1ZXVlW3VzZXJMZW5ndGgrK10gPSBlMjtcbiAgfVxuICBpZiAoc2hhcmVkQ29uZmlnLmNvbnRleHQpXG4gICAgc2V0SHlkcmF0ZUNvbnRleHQoKTtcbiAgZm9yIChpMiA9IDA7IGkyIDwgdXNlckxlbmd0aDsgaTIrKylcbiAgICBydW5Ub3AocXVldWVbaTJdKTtcbn1cbmZ1bmN0aW9uIGxvb2tVcHN0cmVhbShub2RlLCBpZ25vcmUpIHtcbiAgY29uc3QgcnVubmluZ1RyYW5zaXRpb24gPSBUcmFuc2l0aW9uJDE7XG4gIG5vZGUuc3RhdGUgPSAwO1xuICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgbm9kZS5zb3VyY2VzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgIGNvbnN0IHNvdXJjZSA9IG5vZGUuc291cmNlc1tpMl07XG4gICAgaWYgKHNvdXJjZS5zb3VyY2VzKSB7XG4gICAgICBpZiAoc291cmNlLnN0YXRlID09PSBTVEFMRSB8fCBydW5uaW5nVHJhbnNpdGlvbikge1xuICAgICAgICBpZiAoc291cmNlICE9PSBpZ25vcmUpXG4gICAgICAgICAgcnVuVG9wKHNvdXJjZSk7XG4gICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zdGF0ZSA9PT0gUEVORElORyB8fCBydW5uaW5nVHJhbnNpdGlvbilcbiAgICAgICAgbG9va1Vwc3RyZWFtKHNvdXJjZSwgaWdub3JlKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtEb3duc3RyZWFtKG5vZGUpIHtcbiAgY29uc3QgcnVubmluZ1RyYW5zaXRpb24gPSBUcmFuc2l0aW9uJDE7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBub2RlLm9ic2VydmVycy5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICBjb25zdCBvMiA9IG5vZGUub2JzZXJ2ZXJzW2kyXTtcbiAgICBpZiAoIW8yLnN0YXRlIHx8IHJ1bm5pbmdUcmFuc2l0aW9uKSB7XG4gICAgICBvMi5zdGF0ZSA9IFBFTkRJTkc7XG4gICAgICBpZiAobzIucHVyZSlcbiAgICAgICAgVXBkYXRlcy5wdXNoKG8yKTtcbiAgICAgIGVsc2VcbiAgICAgICAgRWZmZWN0cy5wdXNoKG8yKTtcbiAgICAgIG8yLm9ic2VydmVycyAmJiBtYXJrRG93bnN0cmVhbShvMik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjbGVhbk5vZGUobm9kZSkge1xuICBsZXQgaTI7XG4gIGlmIChub2RlLnNvdXJjZXMpIHtcbiAgICB3aGlsZSAobm9kZS5zb3VyY2VzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgc291cmNlID0gbm9kZS5zb3VyY2VzLnBvcCgpLCBpbmRleCA9IG5vZGUuc291cmNlU2xvdHMucG9wKCksIG9icyA9IHNvdXJjZS5vYnNlcnZlcnM7XG4gICAgICBpZiAob2JzICYmIG9icy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgbjIgPSBvYnMucG9wKCksIHMyID0gc291cmNlLm9ic2VydmVyU2xvdHMucG9wKCk7XG4gICAgICAgIGlmIChpbmRleCA8IG9icy5sZW5ndGgpIHtcbiAgICAgICAgICBuMi5zb3VyY2VTbG90c1tzMl0gPSBpbmRleDtcbiAgICAgICAgICBvYnNbaW5kZXhdID0gbjI7XG4gICAgICAgICAgc291cmNlLm9ic2VydmVyU2xvdHNbaW5kZXhdID0gczI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUub3duZWQpIHtcbiAgICBmb3IgKGkyID0gMDsgaTIgPCBub2RlLm93bmVkLmxlbmd0aDsgaTIrKylcbiAgICAgIGNsZWFuTm9kZShub2RlLm93bmVkW2kyXSk7XG4gICAgbm9kZS5vd25lZCA9IG51bGw7XG4gIH1cbiAgaWYgKG5vZGUuY2xlYW51cHMpIHtcbiAgICBmb3IgKGkyID0gMDsgaTIgPCBub2RlLmNsZWFudXBzLmxlbmd0aDsgaTIrKylcbiAgICAgIG5vZGUuY2xlYW51cHNbaTJdKCk7XG4gICAgbm9kZS5jbGVhbnVwcyA9IG51bGw7XG4gIH1cbiAgbm9kZS5zdGF0ZSA9IDA7XG4gIG5vZGUuY29udGV4dCA9IG51bGw7XG59XG5mdW5jdGlvbiBjYXN0RXJyb3IoZXJyKSB7XG4gIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBlcnI7XG4gIHJldHVybiBuZXcgRXJyb3IoXCJVbmtub3duIGVycm9yXCIpO1xufVxuZnVuY3Rpb24gaGFuZGxlRXJyb3IoZXJyKSB7XG4gIGVyciA9IGNhc3RFcnJvcihlcnIpO1xuICB0aHJvdyBlcnI7XG59XG5mdW5jdGlvbiBsb29rdXAob3duZXIsIGtleSkge1xuICByZXR1cm4gb3duZXIgPyBvd25lci5jb250ZXh0ICYmIG93bmVyLmNvbnRleHRba2V5XSAhPT0gdm9pZCAwID8gb3duZXIuY29udGV4dFtrZXldIDogbG9va3VwKG93bmVyLm93bmVyLCBrZXkpIDogdm9pZCAwO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUNoaWxkcmVuKGNoaWxkcmVuMikge1xuICBpZiAodHlwZW9mIGNoaWxkcmVuMiA9PT0gXCJmdW5jdGlvblwiICYmICFjaGlsZHJlbjIubGVuZ3RoKVxuICAgIHJldHVybiByZXNvbHZlQ2hpbGRyZW4oY2hpbGRyZW4yKCkpO1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbjIpKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjaGlsZHJlbjIubGVuZ3RoOyBpMisrKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSByZXNvbHZlQ2hpbGRyZW4oY2hpbGRyZW4yW2kyXSk7XG4gICAgICBBcnJheS5pc0FycmF5KHJlc3VsdCkgPyByZXN1bHRzLnB1c2guYXBwbHkocmVzdWx0cywgcmVzdWx0KSA6IHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuICByZXR1cm4gY2hpbGRyZW4yO1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvdmlkZXIoaWQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb3ZpZGVyKHByb3BzKSB7XG4gICAgbGV0IHJlcztcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gcmVzID0gdW50cmFjaygoKSA9PiB7XG4gICAgICBPd25lci5jb250ZXh0ID0ge1xuICAgICAgICBbaWRdOiBwcm9wcy52YWx1ZVxuICAgICAgfTtcbiAgICAgIHJldHVybiBjaGlsZHJlbigoKSA9PiBwcm9wcy5jaGlsZHJlbik7XG4gICAgfSksIHZvaWQgMCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcbn1cbmNvbnN0IEZBTExCQUNLID0gU3ltYm9sKFwiZmFsbGJhY2tcIik7XG5mdW5jdGlvbiBkaXNwb3NlKGQpIHtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGQubGVuZ3RoOyBpMisrKVxuICAgIGRbaTJdKCk7XG59XG5mdW5jdGlvbiBtYXBBcnJheShsaXN0LCBtYXBGbiwgb3B0aW9ucyA9IHt9KSB7XG4gIGxldCBpdGVtcyA9IFtdLCBtYXBwZWQgPSBbXSwgZGlzcG9zZXJzID0gW10sIGxlbiA9IDAsIGluZGV4ZXMgPSBtYXBGbi5sZW5ndGggPiAxID8gW10gOiBudWxsO1xuICBvbkNsZWFudXAoKCkgPT4gZGlzcG9zZShkaXNwb3NlcnMpKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBsZXQgbmV3SXRlbXMgPSBsaXN0KCkgfHwgW10sIGkyLCBqO1xuICAgIG5ld0l0ZW1zWyRUUkFDS107XG4gICAgcmV0dXJuIHVudHJhY2soKCkgPT4ge1xuICAgICAgbGV0IG5ld0xlbiA9IG5ld0l0ZW1zLmxlbmd0aCwgbmV3SW5kaWNlcywgbmV3SW5kaWNlc05leHQsIHRlbXAsIHRlbXBkaXNwb3NlcnMsIHRlbXBJbmRleGVzLCBzdGFydCwgZW5kLCBuZXdFbmQsIGl0ZW07XG4gICAgICBpZiAobmV3TGVuID09PSAwKSB7XG4gICAgICAgIGlmIChsZW4gIT09IDApIHtcbiAgICAgICAgICBkaXNwb3NlKGRpc3Bvc2Vycyk7XG4gICAgICAgICAgZGlzcG9zZXJzID0gW107XG4gICAgICAgICAgaXRlbXMgPSBbXTtcbiAgICAgICAgICBtYXBwZWQgPSBbXTtcbiAgICAgICAgICBsZW4gPSAwO1xuICAgICAgICAgIGluZGV4ZXMgJiYgKGluZGV4ZXMgPSBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZmFsbGJhY2spIHtcbiAgICAgICAgICBpdGVtcyA9IFtGQUxMQkFDS107XG4gICAgICAgICAgbWFwcGVkWzBdID0gY3JlYXRlUm9vdCgoZGlzcG9zZXIpID0+IHtcbiAgICAgICAgICAgIGRpc3Bvc2Vyc1swXSA9IGRpc3Bvc2VyO1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuZmFsbGJhY2soKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBsZW4gPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgICBtYXBwZWQgPSBuZXcgQXJyYXkobmV3TGVuKTtcbiAgICAgICAgZm9yIChqID0gMDsgaiA8IG5ld0xlbjsgaisrKSB7XG4gICAgICAgICAgaXRlbXNbal0gPSBuZXdJdGVtc1tqXTtcbiAgICAgICAgICBtYXBwZWRbal0gPSBjcmVhdGVSb290KG1hcHBlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gbmV3TGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGVtcCA9IG5ldyBBcnJheShuZXdMZW4pO1xuICAgICAgICB0ZW1wZGlzcG9zZXJzID0gbmV3IEFycmF5KG5ld0xlbik7XG4gICAgICAgIGluZGV4ZXMgJiYgKHRlbXBJbmRleGVzID0gbmV3IEFycmF5KG5ld0xlbikpO1xuICAgICAgICBmb3IgKHN0YXJ0ID0gMCwgZW5kID0gTWF0aC5taW4obGVuLCBuZXdMZW4pOyBzdGFydCA8IGVuZCAmJiBpdGVtc1tzdGFydF0gPT09IG5ld0l0ZW1zW3N0YXJ0XTsgc3RhcnQrKylcbiAgICAgICAgICA7XG4gICAgICAgIGZvciAoZW5kID0gbGVuIC0gMSwgbmV3RW5kID0gbmV3TGVuIC0gMTsgZW5kID49IHN0YXJ0ICYmIG5ld0VuZCA+PSBzdGFydCAmJiBpdGVtc1tlbmRdID09PSBuZXdJdGVtc1tuZXdFbmRdOyBlbmQtLSwgbmV3RW5kLS0pIHtcbiAgICAgICAgICB0ZW1wW25ld0VuZF0gPSBtYXBwZWRbZW5kXTtcbiAgICAgICAgICB0ZW1wZGlzcG9zZXJzW25ld0VuZF0gPSBkaXNwb3NlcnNbZW5kXTtcbiAgICAgICAgICBpbmRleGVzICYmICh0ZW1wSW5kZXhlc1tuZXdFbmRdID0gaW5kZXhlc1tlbmRdKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdJbmRpY2VzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAgICAgbmV3SW5kaWNlc05leHQgPSBuZXcgQXJyYXkobmV3RW5kICsgMSk7XG4gICAgICAgIGZvciAoaiA9IG5ld0VuZDsgaiA+PSBzdGFydDsgai0tKSB7XG4gICAgICAgICAgaXRlbSA9IG5ld0l0ZW1zW2pdO1xuICAgICAgICAgIGkyID0gbmV3SW5kaWNlcy5nZXQoaXRlbSk7XG4gICAgICAgICAgbmV3SW5kaWNlc05leHRbal0gPSBpMiA9PT0gdm9pZCAwID8gLTEgOiBpMjtcbiAgICAgICAgICBuZXdJbmRpY2VzLnNldChpdGVtLCBqKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkyID0gc3RhcnQ7IGkyIDw9IGVuZDsgaTIrKykge1xuICAgICAgICAgIGl0ZW0gPSBpdGVtc1tpMl07XG4gICAgICAgICAgaiA9IG5ld0luZGljZXMuZ2V0KGl0ZW0pO1xuICAgICAgICAgIGlmIChqICE9PSB2b2lkIDAgJiYgaiAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRlbXBbal0gPSBtYXBwZWRbaTJdO1xuICAgICAgICAgICAgdGVtcGRpc3Bvc2Vyc1tqXSA9IGRpc3Bvc2Vyc1tpMl07XG4gICAgICAgICAgICBpbmRleGVzICYmICh0ZW1wSW5kZXhlc1tqXSA9IGluZGV4ZXNbaTJdKTtcbiAgICAgICAgICAgIGogPSBuZXdJbmRpY2VzTmV4dFtqXTtcbiAgICAgICAgICAgIG5ld0luZGljZXMuc2V0KGl0ZW0sIGopO1xuICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgZGlzcG9zZXJzW2kyXSgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IHN0YXJ0OyBqIDwgbmV3TGVuOyBqKyspIHtcbiAgICAgICAgICBpZiAoaiBpbiB0ZW1wKSB7XG4gICAgICAgICAgICBtYXBwZWRbal0gPSB0ZW1wW2pdO1xuICAgICAgICAgICAgZGlzcG9zZXJzW2pdID0gdGVtcGRpc3Bvc2Vyc1tqXTtcbiAgICAgICAgICAgIGlmIChpbmRleGVzKSB7XG4gICAgICAgICAgICAgIGluZGV4ZXNbal0gPSB0ZW1wSW5kZXhlc1tqXTtcbiAgICAgICAgICAgICAgaW5kZXhlc1tqXShqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIG1hcHBlZFtqXSA9IGNyZWF0ZVJvb3QobWFwcGVyKTtcbiAgICAgICAgfVxuICAgICAgICBtYXBwZWQgPSBtYXBwZWQuc2xpY2UoMCwgbGVuID0gbmV3TGVuKTtcbiAgICAgICAgaXRlbXMgPSBuZXdJdGVtcy5zbGljZSgwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXBwZWQ7XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gbWFwcGVyKGRpc3Bvc2VyKSB7XG4gICAgICBkaXNwb3NlcnNbal0gPSBkaXNwb3NlcjtcbiAgICAgIGlmIChpbmRleGVzKSB7XG4gICAgICAgIGNvbnN0IFtzMiwgc2V0XSA9IGNyZWF0ZVNpZ25hbChqKTtcbiAgICAgICAgaW5kZXhlc1tqXSA9IHNldDtcbiAgICAgICAgcmV0dXJuIG1hcEZuKG5ld0l0ZW1zW2pdLCBzMik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWFwRm4obmV3SXRlbXNbal0pO1xuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudChDb21wLCBwcm9wcykge1xuICByZXR1cm4gdW50cmFjaygoKSA9PiBDb21wKHByb3BzIHx8IHt9KSk7XG59XG5mdW5jdGlvbiB0cnVlRm4oKSB7XG4gIHJldHVybiB0cnVlO1xufVxuY29uc3QgcHJvcFRyYXBzID0ge1xuICBnZXQoXywgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUFJPWFkpXG4gICAgICByZXR1cm4gcmVjZWl2ZXI7XG4gICAgcmV0dXJuIF8uZ2V0KHByb3BlcnR5KTtcbiAgfSxcbiAgaGFzKF8sIHByb3BlcnR5KSB7XG4gICAgaWYgKHByb3BlcnR5ID09PSAkUFJPWFkpXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICByZXR1cm4gXy5oYXMocHJvcGVydHkpO1xuICB9LFxuICBzZXQ6IHRydWVGbixcbiAgZGVsZXRlUHJvcGVydHk6IHRydWVGbixcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF8sIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBfLmdldChwcm9wZXJ0eSk7XG4gICAgICB9LFxuICAgICAgc2V0OiB0cnVlRm4sXG4gICAgICBkZWxldGVQcm9wZXJ0eTogdHJ1ZUZuXG4gICAgfTtcbiAgfSxcbiAgb3duS2V5cyhfKSB7XG4gICAgcmV0dXJuIF8ua2V5cygpO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZVNvdXJjZShzMikge1xuICByZXR1cm4gIShzMiA9IHR5cGVvZiBzMiA9PT0gXCJmdW5jdGlvblwiID8gczIoKSA6IHMyKSA/IHt9IDogczI7XG59XG5mdW5jdGlvbiBtZXJnZVByb3BzKC4uLnNvdXJjZXMpIHtcbiAgbGV0IHByb3h5ID0gZmFsc2U7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCBzb3VyY2VzLmxlbmd0aDsgaTIrKykge1xuICAgIGNvbnN0IHMyID0gc291cmNlc1tpMl07XG4gICAgcHJveHkgPSBwcm94eSB8fCAhIXMyICYmICRQUk9YWSBpbiBzMjtcbiAgICBzb3VyY2VzW2kyXSA9IHR5cGVvZiBzMiA9PT0gXCJmdW5jdGlvblwiID8gKHByb3h5ID0gdHJ1ZSwgY3JlYXRlTWVtbyhzMikpIDogczI7XG4gIH1cbiAgaWYgKHByb3h5KSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7XG4gICAgICBnZXQocHJvcGVydHkpIHtcbiAgICAgICAgZm9yIChsZXQgaTIgPSBzb3VyY2VzLmxlbmd0aCAtIDE7IGkyID49IDA7IGkyLS0pIHtcbiAgICAgICAgICBjb25zdCB2ID0gcmVzb2x2ZVNvdXJjZShzb3VyY2VzW2kyXSlbcHJvcGVydHldO1xuICAgICAgICAgIGlmICh2ICE9PSB2b2lkIDApXG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGhhcyhwcm9wZXJ0eSkge1xuICAgICAgICBmb3IgKGxldCBpMiA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgICAgICAgIGlmIChwcm9wZXJ0eSBpbiByZXNvbHZlU291cmNlKHNvdXJjZXNbaTJdKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICBrZXlzKCkge1xuICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBzb3VyY2VzLmxlbmd0aDsgaTIrKylcbiAgICAgICAgICBrZXlzLnB1c2goLi4uT2JqZWN0LmtleXMocmVzb2x2ZVNvdXJjZShzb3VyY2VzW2kyXSkpKTtcbiAgICAgICAgcmV0dXJuIFsuLi5uZXcgU2V0KGtleXMpXTtcbiAgICAgIH1cbiAgICB9LCBwcm9wVHJhcHMpO1xuICB9XG4gIGNvbnN0IHRhcmdldCA9IHt9O1xuICBmb3IgKGxldCBpMiA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaTIgPj0gMDsgaTItLSkge1xuICAgIGlmIChzb3VyY2VzW2kyXSkge1xuICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2VzW2kyXSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZXNjcmlwdG9ycykge1xuICAgICAgICBpZiAoa2V5IGluIHRhcmdldClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpMyA9IHNvdXJjZXMubGVuZ3RoIC0gMTsgaTMgPj0gMDsgaTMtLSkge1xuICAgICAgICAgICAgICBjb25zdCB2ID0gKHNvdXJjZXNbaTNdIHx8IHt9KVtrZXldO1xuICAgICAgICAgICAgICBpZiAodiAhPT0gdm9pZCAwKVxuICAgICAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBzcGxpdFByb3BzKHByb3BzLCAuLi5rZXlzKSB7XG4gIGNvbnN0IGJsb2NrZWQgPSBuZXcgU2V0KGtleXMuZmxhdCgpKTtcbiAgaWYgKCRQUk9YWSBpbiBwcm9wcykge1xuICAgIGNvbnN0IHJlcyA9IGtleXMubWFwKChrKSA9PiB7XG4gICAgICByZXR1cm4gbmV3IFByb3h5KHtcbiAgICAgICAgZ2V0KHByb3BlcnR5KSB7XG4gICAgICAgICAgcmV0dXJuIGsuaW5jbHVkZXMocHJvcGVydHkpID8gcHJvcHNbcHJvcGVydHldIDogdm9pZCAwO1xuICAgICAgICB9LFxuICAgICAgICBoYXMocHJvcGVydHkpIHtcbiAgICAgICAgICByZXR1cm4gay5pbmNsdWRlcyhwcm9wZXJ0eSkgJiYgcHJvcGVydHkgaW4gcHJvcHM7XG4gICAgICAgIH0sXG4gICAgICAgIGtleXMoKSB7XG4gICAgICAgICAgcmV0dXJuIGsuZmlsdGVyKChwcm9wZXJ0eSkgPT4gcHJvcGVydHkgaW4gcHJvcHMpO1xuICAgICAgICB9XG4gICAgICB9LCBwcm9wVHJhcHMpO1xuICAgIH0pO1xuICAgIHJlcy5wdXNoKG5ldyBQcm94eSh7XG4gICAgICBnZXQocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrZWQuaGFzKHByb3BlcnR5KSA/IHZvaWQgMCA6IHByb3BzW3Byb3BlcnR5XTtcbiAgICAgIH0sXG4gICAgICBoYXMocHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrZWQuaGFzKHByb3BlcnR5KSA/IGZhbHNlIDogcHJvcGVydHkgaW4gcHJvcHM7XG4gICAgICB9LFxuICAgICAga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5maWx0ZXIoKGspID0+ICFibG9ja2VkLmhhcyhrKSk7XG4gICAgICB9XG4gICAgfSwgcHJvcFRyYXBzKSk7XG4gICAgcmV0dXJuIHJlcztcbiAgfVxuICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHByb3BzKTtcbiAga2V5cy5wdXNoKE9iamVjdC5rZXlzKGRlc2NyaXB0b3JzKS5maWx0ZXIoKGspID0+ICFibG9ja2VkLmhhcyhrKSkpO1xuICByZXR1cm4ga2V5cy5tYXAoKGspID0+IHtcbiAgICBjb25zdCBjbG9uZSA9IHt9O1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBrLmxlbmd0aDsgaTIrKykge1xuICAgICAgY29uc3Qga2V5ID0ga1tpMl07XG4gICAgICBpZiAoIShrZXkgaW4gcHJvcHMpKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjbG9uZSwga2V5LCBkZXNjcmlwdG9yc1trZXldID8gZGVzY3JpcHRvcnNba2V5XSA6IHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmU7XG4gIH0pO1xufVxuZnVuY3Rpb24gRm9yKHByb3BzKSB7XG4gIGNvbnN0IGZhbGxiYWNrID0gXCJmYWxsYmFja1wiIGluIHByb3BzICYmIHtcbiAgICBmYWxsYmFjazogKCkgPT4gcHJvcHMuZmFsbGJhY2tcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8obWFwQXJyYXkoKCkgPT4gcHJvcHMuZWFjaCwgcHJvcHMuY2hpbGRyZW4sIGZhbGxiYWNrIHx8IHZvaWQgMCkpO1xufVxuZnVuY3Rpb24gU2hvdyhwcm9wcykge1xuICBsZXQgc3RyaWN0RXF1YWwgPSBmYWxzZTtcbiAgY29uc3Qga2V5ZWQgPSBwcm9wcy5rZXllZDtcbiAgY29uc3QgY29uZGl0aW9uID0gY3JlYXRlTWVtbygoKSA9PiBwcm9wcy53aGVuLCB2b2lkIDAsIHtcbiAgICBlcXVhbHM6IChhMiwgYikgPT4gc3RyaWN0RXF1YWwgPyBhMiA9PT0gYiA6ICFhMiA9PT0gIWJcbiAgfSk7XG4gIHJldHVybiBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjMiA9IGNvbmRpdGlvbigpO1xuICAgIGlmIChjMikge1xuICAgICAgY29uc3QgY2hpbGQgPSBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGNvbnN0IGZuID0gdHlwZW9mIGNoaWxkID09PSBcImZ1bmN0aW9uXCIgJiYgY2hpbGQubGVuZ3RoID4gMDtcbiAgICAgIHN0cmljdEVxdWFsID0ga2V5ZWQgfHwgZm47XG4gICAgICByZXR1cm4gZm4gPyB1bnRyYWNrKCgpID0+IGNoaWxkKGMyKSkgOiBjaGlsZDtcbiAgICB9XG4gICAgcmV0dXJuIHByb3BzLmZhbGxiYWNrO1xuICB9LCB2b2lkIDAsIHZvaWQgMCk7XG59XG5mdW5jdGlvbiBTd2l0Y2gocHJvcHMpIHtcbiAgbGV0IHN0cmljdEVxdWFsID0gZmFsc2U7XG4gIGxldCBrZXllZCA9IGZhbHNlO1xuICBjb25zdCBlcXVhbHMgPSAoYTIsIGIpID0+IGEyWzBdID09PSBiWzBdICYmIChzdHJpY3RFcXVhbCA/IGEyWzFdID09PSBiWzFdIDogIWEyWzFdID09PSAhYlsxXSkgJiYgYTJbMl0gPT09IGJbMl07XG4gIGNvbnN0IGNvbmRpdGlvbnMgPSBjaGlsZHJlbigoKSA9PiBwcm9wcy5jaGlsZHJlbiksIGV2YWxDb25kaXRpb25zID0gY3JlYXRlTWVtbygoKSA9PiB7XG4gICAgbGV0IGNvbmRzID0gY29uZGl0aW9ucygpO1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb25kcykpXG4gICAgICBjb25kcyA9IFtjb25kc107XG4gICAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGNvbmRzLmxlbmd0aDsgaTIrKykge1xuICAgICAgY29uc3QgYzIgPSBjb25kc1tpMl0ud2hlbjtcbiAgICAgIGlmIChjMikge1xuICAgICAgICBrZXllZCA9ICEhY29uZHNbaTJdLmtleWVkO1xuICAgICAgICByZXR1cm4gW2kyLCBjMiwgY29uZHNbaTJdXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFstMV07XG4gIH0sIHZvaWQgMCwge1xuICAgIGVxdWFsc1xuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IFtpbmRleCwgd2hlbiwgY29uZF0gPSBldmFsQ29uZGl0aW9ucygpO1xuICAgIGlmIChpbmRleCA8IDApXG4gICAgICByZXR1cm4gcHJvcHMuZmFsbGJhY2s7XG4gICAgY29uc3QgYzIgPSBjb25kLmNoaWxkcmVuO1xuICAgIGNvbnN0IGZuID0gdHlwZW9mIGMyID09PSBcImZ1bmN0aW9uXCIgJiYgYzIubGVuZ3RoID4gMDtcbiAgICBzdHJpY3RFcXVhbCA9IGtleWVkIHx8IGZuO1xuICAgIHJldHVybiBmbiA/IHVudHJhY2soKCkgPT4gYzIod2hlbikpIDogYzI7XG4gIH0sIHZvaWQgMCwgdm9pZCAwKTtcbn1cbmZ1bmN0aW9uIE1hdGNoKHByb3BzKSB7XG4gIHJldHVybiBwcm9wcztcbn1cbmNvbnN0IGJvb2xlYW5zID0gW1wiYWxsb3dmdWxsc2NyZWVuXCIsIFwiYXN5bmNcIiwgXCJhdXRvZm9jdXNcIiwgXCJhdXRvcGxheVwiLCBcImNoZWNrZWRcIiwgXCJjb250cm9sc1wiLCBcImRlZmF1bHRcIiwgXCJkaXNhYmxlZFwiLCBcImZvcm1ub3ZhbGlkYXRlXCIsIFwiaGlkZGVuXCIsIFwiaW5kZXRlcm1pbmF0ZVwiLCBcImlzbWFwXCIsIFwibG9vcFwiLCBcIm11bHRpcGxlXCIsIFwibXV0ZWRcIiwgXCJub21vZHVsZVwiLCBcIm5vdmFsaWRhdGVcIiwgXCJvcGVuXCIsIFwicGxheXNpbmxpbmVcIiwgXCJyZWFkb25seVwiLCBcInJlcXVpcmVkXCIsIFwicmV2ZXJzZWRcIiwgXCJzZWFtbGVzc1wiLCBcInNlbGVjdGVkXCJdO1xuY29uc3QgUHJvcGVydGllcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcImNsYXNzTmFtZVwiLCBcInZhbHVlXCIsIFwicmVhZE9ubHlcIiwgXCJmb3JtTm9WYWxpZGF0ZVwiLCBcImlzTWFwXCIsIFwibm9Nb2R1bGVcIiwgXCJwbGF5c0lubGluZVwiLCAuLi5ib29sZWFuc10pO1xuY29uc3QgQ2hpbGRQcm9wZXJ0aWVzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoW1wiaW5uZXJIVE1MXCIsIFwidGV4dENvbnRlbnRcIiwgXCJpbm5lclRleHRcIiwgXCJjaGlsZHJlblwiXSk7XG5jb25zdCBBbGlhc2VzID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5hc3NpZ24oLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgY2xhc3NOYW1lOiBcImNsYXNzXCIsXG4gIGh0bWxGb3I6IFwiZm9yXCJcbn0pO1xuY29uc3QgUHJvcEFsaWFzZXMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmFzc2lnbigvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSwge1xuICBjbGFzczogXCJjbGFzc05hbWVcIixcbiAgZm9ybW5vdmFsaWRhdGU6IFwiZm9ybU5vVmFsaWRhdGVcIixcbiAgaXNtYXA6IFwiaXNNYXBcIixcbiAgbm9tb2R1bGU6IFwibm9Nb2R1bGVcIixcbiAgcGxheXNpbmxpbmU6IFwicGxheXNJbmxpbmVcIixcbiAgcmVhZG9ubHk6IFwicmVhZE9ubHlcIlxufSk7XG5jb25zdCBEZWxlZ2F0ZWRFdmVudHMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldChbXCJiZWZvcmVpbnB1dFwiLCBcImNsaWNrXCIsIFwiZGJsY2xpY2tcIiwgXCJjb250ZXh0bWVudVwiLCBcImZvY3VzaW5cIiwgXCJmb2N1c291dFwiLCBcImlucHV0XCIsIFwia2V5ZG93blwiLCBcImtleXVwXCIsIFwibW91c2Vkb3duXCIsIFwibW91c2Vtb3ZlXCIsIFwibW91c2VvdXRcIiwgXCJtb3VzZW92ZXJcIiwgXCJtb3VzZXVwXCIsIFwicG9pbnRlcmRvd25cIiwgXCJwb2ludGVybW92ZVwiLCBcInBvaW50ZXJvdXRcIiwgXCJwb2ludGVyb3ZlclwiLCBcInBvaW50ZXJ1cFwiLCBcInRvdWNoZW5kXCIsIFwidG91Y2htb3ZlXCIsIFwidG91Y2hzdGFydFwiXSk7XG5jb25zdCBTVkdFbGVtZW50cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtcbiAgXCJhbHRHbHlwaFwiLFxuICBcImFsdEdseXBoRGVmXCIsXG4gIFwiYWx0R2x5cGhJdGVtXCIsXG4gIFwiYW5pbWF0ZVwiLFxuICBcImFuaW1hdGVDb2xvclwiLFxuICBcImFuaW1hdGVNb3Rpb25cIixcbiAgXCJhbmltYXRlVHJhbnNmb3JtXCIsXG4gIFwiY2lyY2xlXCIsXG4gIFwiY2xpcFBhdGhcIixcbiAgXCJjb2xvci1wcm9maWxlXCIsXG4gIFwiY3Vyc29yXCIsXG4gIFwiZGVmc1wiLFxuICBcImRlc2NcIixcbiAgXCJlbGxpcHNlXCIsXG4gIFwiZmVCbGVuZFwiLFxuICBcImZlQ29sb3JNYXRyaXhcIixcbiAgXCJmZUNvbXBvbmVudFRyYW5zZmVyXCIsXG4gIFwiZmVDb21wb3NpdGVcIixcbiAgXCJmZUNvbnZvbHZlTWF0cml4XCIsXG4gIFwiZmVEaWZmdXNlTGlnaHRpbmdcIixcbiAgXCJmZURpc3BsYWNlbWVudE1hcFwiLFxuICBcImZlRGlzdGFudExpZ2h0XCIsXG4gIFwiZmVGbG9vZFwiLFxuICBcImZlRnVuY0FcIixcbiAgXCJmZUZ1bmNCXCIsXG4gIFwiZmVGdW5jR1wiLFxuICBcImZlRnVuY1JcIixcbiAgXCJmZUdhdXNzaWFuQmx1clwiLFxuICBcImZlSW1hZ2VcIixcbiAgXCJmZU1lcmdlXCIsXG4gIFwiZmVNZXJnZU5vZGVcIixcbiAgXCJmZU1vcnBob2xvZ3lcIixcbiAgXCJmZU9mZnNldFwiLFxuICBcImZlUG9pbnRMaWdodFwiLFxuICBcImZlU3BlY3VsYXJMaWdodGluZ1wiLFxuICBcImZlU3BvdExpZ2h0XCIsXG4gIFwiZmVUaWxlXCIsXG4gIFwiZmVUdXJidWxlbmNlXCIsXG4gIFwiZmlsdGVyXCIsXG4gIFwiZm9udFwiLFxuICBcImZvbnQtZmFjZVwiLFxuICBcImZvbnQtZmFjZS1mb3JtYXRcIixcbiAgXCJmb250LWZhY2UtbmFtZVwiLFxuICBcImZvbnQtZmFjZS1zcmNcIixcbiAgXCJmb250LWZhY2UtdXJpXCIsXG4gIFwiZm9yZWlnbk9iamVjdFwiLFxuICBcImdcIixcbiAgXCJnbHlwaFwiLFxuICBcImdseXBoUmVmXCIsXG4gIFwiaGtlcm5cIixcbiAgXCJpbWFnZVwiLFxuICBcImxpbmVcIixcbiAgXCJsaW5lYXJHcmFkaWVudFwiLFxuICBcIm1hcmtlclwiLFxuICBcIm1hc2tcIixcbiAgXCJtZXRhZGF0YVwiLFxuICBcIm1pc3NpbmctZ2x5cGhcIixcbiAgXCJtcGF0aFwiLFxuICBcInBhdGhcIixcbiAgXCJwYXR0ZXJuXCIsXG4gIFwicG9seWdvblwiLFxuICBcInBvbHlsaW5lXCIsXG4gIFwicmFkaWFsR3JhZGllbnRcIixcbiAgXCJyZWN0XCIsXG4gIFwic2V0XCIsXG4gIFwic3RvcFwiLFxuICBcInN2Z1wiLFxuICBcInN3aXRjaFwiLFxuICBcInN5bWJvbFwiLFxuICBcInRleHRcIixcbiAgXCJ0ZXh0UGF0aFwiLFxuICBcInRyZWZcIixcbiAgXCJ0c3BhblwiLFxuICBcInVzZVwiLFxuICBcInZpZXdcIixcbiAgXCJ2a2VyblwiXG5dKTtcbmNvbnN0IFNWR05hbWVzcGFjZSA9IHtcbiAgeGxpbms6IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLFxuICB4bWw6IFwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCJcbn07XG5mdW5jdGlvbiByZWNvbmNpbGVBcnJheXMocGFyZW50Tm9kZSwgYTIsIGIpIHtcbiAgbGV0IGJMZW5ndGggPSBiLmxlbmd0aCwgYUVuZCA9IGEyLmxlbmd0aCwgYkVuZCA9IGJMZW5ndGgsIGFTdGFydCA9IDAsIGJTdGFydCA9IDAsIGFmdGVyID0gYTJbYUVuZCAtIDFdLm5leHRTaWJsaW5nLCBtYXAgPSBudWxsO1xuICB3aGlsZSAoYVN0YXJ0IDwgYUVuZCB8fCBiU3RhcnQgPCBiRW5kKSB7XG4gICAgaWYgKGEyW2FTdGFydF0gPT09IGJbYlN0YXJ0XSkge1xuICAgICAgYVN0YXJ0Kys7XG4gICAgICBiU3RhcnQrKztcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB3aGlsZSAoYTJbYUVuZCAtIDFdID09PSBiW2JFbmQgLSAxXSkge1xuICAgICAgYUVuZC0tO1xuICAgICAgYkVuZC0tO1xuICAgIH1cbiAgICBpZiAoYUVuZCA9PT0gYVN0YXJ0KSB7XG4gICAgICBjb25zdCBub2RlID0gYkVuZCA8IGJMZW5ndGggPyBiU3RhcnQgPyBiW2JTdGFydCAtIDFdLm5leHRTaWJsaW5nIDogYltiRW5kIC0gYlN0YXJ0XSA6IGFmdGVyO1xuICAgICAgd2hpbGUgKGJTdGFydCA8IGJFbmQpXG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbYlN0YXJ0KytdLCBub2RlKTtcbiAgICB9IGVsc2UgaWYgKGJFbmQgPT09IGJTdGFydCkge1xuICAgICAgd2hpbGUgKGFTdGFydCA8IGFFbmQpIHtcbiAgICAgICAgaWYgKCFtYXAgfHwgIW1hcC5oYXMoYTJbYVN0YXJ0XSkpXG4gICAgICAgICAgYTJbYVN0YXJ0XS5yZW1vdmUoKTtcbiAgICAgICAgYVN0YXJ0Kys7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChhMlthU3RhcnRdID09PSBiW2JFbmQgLSAxXSAmJiBiW2JTdGFydF0gPT09IGEyW2FFbmQgLSAxXSkge1xuICAgICAgY29uc3Qgbm9kZSA9IGEyWy0tYUVuZF0ubmV4dFNpYmxpbmc7XG4gICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShiW2JTdGFydCsrXSwgYTJbYVN0YXJ0KytdLm5leHRTaWJsaW5nKTtcbiAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbLS1iRW5kXSwgbm9kZSk7XG4gICAgICBhMlthRW5kXSA9IGJbYkVuZF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghbWFwKSB7XG4gICAgICAgIG1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG4gICAgICAgIGxldCBpMiA9IGJTdGFydDtcbiAgICAgICAgd2hpbGUgKGkyIDwgYkVuZClcbiAgICAgICAgICBtYXAuc2V0KGJbaTJdLCBpMisrKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ID0gbWFwLmdldChhMlthU3RhcnRdKTtcbiAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChiU3RhcnQgPCBpbmRleCAmJiBpbmRleCA8IGJFbmQpIHtcbiAgICAgICAgICBsZXQgaTIgPSBhU3RhcnQsIHNlcXVlbmNlID0gMSwgdDI7XG4gICAgICAgICAgd2hpbGUgKCsraTIgPCBhRW5kICYmIGkyIDwgYkVuZCkge1xuICAgICAgICAgICAgaWYgKCh0MiA9IG1hcC5nZXQoYTJbaTJdKSkgPT0gbnVsbCB8fCB0MiAhPT0gaW5kZXggKyBzZXF1ZW5jZSlcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzZXF1ZW5jZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2VxdWVuY2UgPiBpbmRleCAtIGJTdGFydCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGEyW2FTdGFydF07XG4gICAgICAgICAgICB3aGlsZSAoYlN0YXJ0IDwgaW5kZXgpXG4gICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGJbYlN0YXJ0KytdLCBub2RlKTtcbiAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgIHBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGJbYlN0YXJ0KytdLCBhMlthU3RhcnQrK10pO1xuICAgICAgICB9IGVsc2VcbiAgICAgICAgICBhU3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAgICBhMlthU3RhcnQrK10ucmVtb3ZlKCk7XG4gICAgfVxuICB9XG59XG5jb25zdCAkJEVWRU5UUyA9IFwiXyREWF9ERUxFR0FURVwiO1xuZnVuY3Rpb24gcmVuZGVyKGNvZGUsIGVsZW1lbnQsIGluaXQsIG9wdGlvbnMgPSB7fSkge1xuICBsZXQgZGlzcG9zZXI7XG4gIGNyZWF0ZVJvb3QoKGRpc3Bvc2UyKSA9PiB7XG4gICAgZGlzcG9zZXIgPSBkaXNwb3NlMjtcbiAgICBlbGVtZW50ID09PSBkb2N1bWVudCA/IGNvZGUoKSA6IGluc2VydChlbGVtZW50LCBjb2RlKCksIGVsZW1lbnQuZmlyc3RDaGlsZCA/IG51bGwgOiB2b2lkIDAsIGluaXQpO1xuICB9LCBvcHRpb25zLm93bmVyKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBkaXNwb3NlcigpO1xuICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuICB9O1xufVxuZnVuY3Rpb24gdGVtcGxhdGUkMShodG1sLCBjaGVjaywgaXNTVkcpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB0MiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgdDIuaW5uZXJIVE1MID0gaHRtbDtcbiAgbGV0IG5vZGUgPSB0Mi5jb250ZW50LmZpcnN0Q2hpbGQ7XG4gIGlmIChpc1NWRylcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGRlbGVnYXRlRXZlbnRzKGV2ZW50TmFtZXMsIGRvY3VtZW50MiA9IHdpbmRvdy5kb2N1bWVudCkge1xuICBjb25zdCBlMiA9IGRvY3VtZW50MlskJEVWRU5UU10gfHwgKGRvY3VtZW50MlskJEVWRU5UU10gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgZm9yIChsZXQgaTIgPSAwLCBsMiA9IGV2ZW50TmFtZXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgY29uc3QgbmFtZSA9IGV2ZW50TmFtZXNbaTJdO1xuICAgIGlmICghZTIuaGFzKG5hbWUpKSB7XG4gICAgICBlMi5hZGQobmFtZSk7XG4gICAgICBkb2N1bWVudDIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBldmVudEhhbmRsZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICBlbHNlXG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gc2V0QXR0cmlidXRlTlMobm9kZSwgbmFtZXNwYWNlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSk7XG4gIGVsc2VcbiAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgbmFtZSwgdmFsdWUpO1xufVxuZnVuY3Rpb24gY2xhc3NOYW1lKG5vZGUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKVxuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKFwiY2xhc3NcIik7XG4gIGVsc2VcbiAgICBub2RlLmNsYXNzTmFtZSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCBoYW5kbGVyLCBkZWxlZ2F0ZSkge1xuICBpZiAoZGVsZWdhdGUpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgICAgbm9kZVtgJCQke25hbWV9YF0gPSBoYW5kbGVyWzBdO1xuICAgICAgbm9kZVtgJCQke25hbWV9RGF0YWBdID0gaGFuZGxlclsxXTtcbiAgICB9IGVsc2VcbiAgICAgIG5vZGVbYCQkJHtuYW1lfWBdID0gaGFuZGxlcjtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgY29uc3QgaGFuZGxlckZuID0gaGFuZGxlclswXTtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgaGFuZGxlclswXSA9IChlMikgPT4gaGFuZGxlckZuLmNhbGwobm9kZSwgaGFuZGxlclsxXSwgZTIpKTtcbiAgfSBlbHNlXG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gY2xhc3NMaXN0KG5vZGUsIHZhbHVlLCBwcmV2ID0ge30pIHtcbiAgY29uc3QgY2xhc3NLZXlzID0gT2JqZWN0LmtleXModmFsdWUgfHwge30pLCBwcmV2S2V5cyA9IE9iamVjdC5rZXlzKHByZXYpO1xuICBsZXQgaTIsIGxlbjtcbiAgZm9yIChpMiA9IDAsIGxlbiA9IHByZXZLZXlzLmxlbmd0aDsgaTIgPCBsZW47IGkyKyspIHtcbiAgICBjb25zdCBrZXkgPSBwcmV2S2V5c1tpMl07XG4gICAgaWYgKCFrZXkgfHwga2V5ID09PSBcInVuZGVmaW5lZFwiIHx8IHZhbHVlW2tleV0pXG4gICAgICBjb250aW51ZTtcbiAgICB0b2dnbGVDbGFzc0tleShub2RlLCBrZXksIGZhbHNlKTtcbiAgICBkZWxldGUgcHJldltrZXldO1xuICB9XG4gIGZvciAoaTIgPSAwLCBsZW4gPSBjbGFzc0tleXMubGVuZ3RoOyBpMiA8IGxlbjsgaTIrKykge1xuICAgIGNvbnN0IGtleSA9IGNsYXNzS2V5c1tpMl0sIGNsYXNzVmFsdWUgPSAhIXZhbHVlW2tleV07XG4gICAgaWYgKCFrZXkgfHwga2V5ID09PSBcInVuZGVmaW5lZFwiIHx8IHByZXZba2V5XSA9PT0gY2xhc3NWYWx1ZSB8fCAhY2xhc3NWYWx1ZSlcbiAgICAgIGNvbnRpbnVlO1xuICAgIHRvZ2dsZUNsYXNzS2V5KG5vZGUsIGtleSwgdHJ1ZSk7XG4gICAgcHJldltrZXldID0gY2xhc3NWYWx1ZTtcbiAgfVxuICByZXR1cm4gcHJldjtcbn1cbmZ1bmN0aW9uIHN0eWxlKG5vZGUsIHZhbHVlLCBwcmV2KSB7XG4gIGlmICghdmFsdWUpXG4gICAgcmV0dXJuIHByZXYgPyBzZXRBdHRyaWJ1dGUobm9kZSwgXCJzdHlsZVwiKSA6IHZhbHVlO1xuICBjb25zdCBub2RlU3R5bGUgPSBub2RlLnN0eWxlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgIHJldHVybiBub2RlU3R5bGUuY3NzVGV4dCA9IHZhbHVlO1xuICB0eXBlb2YgcHJldiA9PT0gXCJzdHJpbmdcIiAmJiAobm9kZVN0eWxlLmNzc1RleHQgPSBwcmV2ID0gdm9pZCAwKTtcbiAgcHJldiB8fCAocHJldiA9IHt9KTtcbiAgdmFsdWUgfHwgKHZhbHVlID0ge30pO1xuICBsZXQgdiwgczI7XG4gIGZvciAoczIgaW4gcHJldikge1xuICAgIHZhbHVlW3MyXSA9PSBudWxsICYmIG5vZGVTdHlsZS5yZW1vdmVQcm9wZXJ0eShzMik7XG4gICAgZGVsZXRlIHByZXZbczJdO1xuICB9XG4gIGZvciAoczIgaW4gdmFsdWUpIHtcbiAgICB2ID0gdmFsdWVbczJdO1xuICAgIGlmICh2ICE9PSBwcmV2W3MyXSkge1xuICAgICAgbm9kZVN0eWxlLnNldFByb3BlcnR5KHMyLCB2KTtcbiAgICAgIHByZXZbczJdID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBzcHJlYWQobm9kZSwgcHJvcHMgPSB7fSwgaXNTVkcsIHNraXBDaGlsZHJlbikge1xuICBjb25zdCBwcmV2UHJvcHMgPSB7fTtcbiAgaWYgKCFza2lwQ2hpbGRyZW4pIHtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gcHJldlByb3BzLmNoaWxkcmVuID0gaW5zZXJ0RXhwcmVzc2lvbihub2RlLCBwcm9wcy5jaGlsZHJlbiwgcHJldlByb3BzLmNoaWxkcmVuKSk7XG4gIH1cbiAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHByb3BzLnJlZiAmJiBwcm9wcy5yZWYobm9kZSkpO1xuICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gYXNzaWduKG5vZGUsIHByb3BzLCBpc1NWRywgdHJ1ZSwgcHJldlByb3BzLCB0cnVlKSk7XG4gIHJldHVybiBwcmV2UHJvcHM7XG59XG5mdW5jdGlvbiB1c2UoZm4sIGVsZW1lbnQsIGFyZykge1xuICByZXR1cm4gdW50cmFjaygoKSA9PiBmbihlbGVtZW50LCBhcmcpKTtcbn1cbmZ1bmN0aW9uIGluc2VydChwYXJlbnQsIGFjY2Vzc29yLCBtYXJrZXIsIGluaXRpYWwpIHtcbiAgaWYgKG1hcmtlciAhPT0gdm9pZCAwICYmICFpbml0aWFsKVxuICAgIGluaXRpYWwgPSBbXTtcbiAgaWYgKHR5cGVvZiBhY2Nlc3NvciAhPT0gXCJmdW5jdGlvblwiKVxuICAgIHJldHVybiBpbnNlcnRFeHByZXNzaW9uKHBhcmVudCwgYWNjZXNzb3IsIGluaXRpYWwsIG1hcmtlcik7XG4gIGNyZWF0ZVJlbmRlckVmZmVjdCgoY3VycmVudCkgPT4gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIGFjY2Vzc29yKCksIGN1cnJlbnQsIG1hcmtlciksIGluaXRpYWwpO1xufVxuZnVuY3Rpb24gYXNzaWduKG5vZGUsIHByb3BzLCBpc1NWRywgc2tpcENoaWxkcmVuLCBwcmV2UHJvcHMgPSB7fSwgc2tpcFJlZiA9IGZhbHNlKSB7XG4gIHByb3BzIHx8IChwcm9wcyA9IHt9KTtcbiAgZm9yIChjb25zdCBwcm9wIGluIHByZXZQcm9wcykge1xuICAgIGlmICghKHByb3AgaW4gcHJvcHMpKSB7XG4gICAgICBpZiAocHJvcCA9PT0gXCJjaGlsZHJlblwiKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHByZXZQcm9wc1twcm9wXSA9IGFzc2lnblByb3Aobm9kZSwgcHJvcCwgbnVsbCwgcHJldlByb3BzW3Byb3BdLCBpc1NWRywgc2tpcFJlZik7XG4gICAgfVxuICB9XG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgIGlmIChwcm9wID09PSBcImNoaWxkcmVuXCIpIHtcbiAgICAgIGlmICghc2tpcENoaWxkcmVuKVxuICAgICAgICBpbnNlcnRFeHByZXNzaW9uKG5vZGUsIHByb3BzLmNoaWxkcmVuKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZSA9IHByb3BzW3Byb3BdO1xuICAgIHByZXZQcm9wc1twcm9wXSA9IGFzc2lnblByb3Aobm9kZSwgcHJvcCwgdmFsdWUsIHByZXZQcm9wc1twcm9wXSwgaXNTVkcsIHNraXBSZWYpO1xuICB9XG59XG5mdW5jdGlvbiBnZXROZXh0RWxlbWVudCh0ZW1wbGF0ZTIpIHtcbiAgbGV0IG5vZGUsIGtleTtcbiAgaWYgKCFzaGFyZWRDb25maWcuY29udGV4dCB8fCAhKG5vZGUgPSBzaGFyZWRDb25maWcucmVnaXN0cnkuZ2V0KGtleSA9IGdldEh5ZHJhdGlvbktleSgpKSkpIHtcbiAgICByZXR1cm4gdGVtcGxhdGUyLmNsb25lTm9kZSh0cnVlKTtcbiAgfVxuICBpZiAoc2hhcmVkQ29uZmlnLmNvbXBsZXRlZClcbiAgICBzaGFyZWRDb25maWcuY29tcGxldGVkLmFkZChub2RlKTtcbiAgc2hhcmVkQ29uZmlnLnJlZ2lzdHJ5LmRlbGV0ZShrZXkpO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIHRvUHJvcGVydHlOYW1lKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC8tKFthLXpdKS9nLCAoXywgdykgPT4gdy50b1VwcGVyQ2FzZSgpKTtcbn1cbmZ1bmN0aW9uIHRvZ2dsZUNsYXNzS2V5KG5vZGUsIGtleSwgdmFsdWUpIHtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IGtleS50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgZm9yIChsZXQgaTIgPSAwLCBuYW1lTGVuID0gY2xhc3NOYW1lcy5sZW5ndGg7IGkyIDwgbmFtZUxlbjsgaTIrKylcbiAgICBub2RlLmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lc1tpMl0sIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGFzc2lnblByb3Aobm9kZSwgcHJvcCwgdmFsdWUsIHByZXYsIGlzU1ZHLCBza2lwUmVmKSB7XG4gIGxldCBpc0NFLCBpc1Byb3AsIGlzQ2hpbGRQcm9wO1xuICBpZiAocHJvcCA9PT0gXCJzdHlsZVwiKVxuICAgIHJldHVybiBzdHlsZShub2RlLCB2YWx1ZSwgcHJldik7XG4gIGlmIChwcm9wID09PSBcImNsYXNzTGlzdFwiKVxuICAgIHJldHVybiBjbGFzc0xpc3Qobm9kZSwgdmFsdWUsIHByZXYpO1xuICBpZiAodmFsdWUgPT09IHByZXYpXG4gICAgcmV0dXJuIHByZXY7XG4gIGlmIChwcm9wID09PSBcInJlZlwiKSB7XG4gICAgaWYgKCFza2lwUmVmKVxuICAgICAgdmFsdWUobm9kZSk7XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCAzKSA9PT0gXCJvbjpcIikge1xuICAgIGNvbnN0IGUyID0gcHJvcC5zbGljZSgzKTtcbiAgICBwcmV2ICYmIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihlMiwgcHJldik7XG4gICAgdmFsdWUgJiYgbm9kZS5hZGRFdmVudExpc3RlbmVyKGUyLCB2YWx1ZSk7XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCAxMCkgPT09IFwib25jYXB0dXJlOlwiKSB7XG4gICAgY29uc3QgZTIgPSBwcm9wLnNsaWNlKDEwKTtcbiAgICBwcmV2ICYmIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihlMiwgcHJldiwgdHJ1ZSk7XG4gICAgdmFsdWUgJiYgbm9kZS5hZGRFdmVudExpc3RlbmVyKGUyLCB2YWx1ZSwgdHJ1ZSk7XG4gIH0gZWxzZSBpZiAocHJvcC5zbGljZSgwLCAyKSA9PT0gXCJvblwiKSB7XG4gICAgY29uc3QgbmFtZSA9IHByb3Auc2xpY2UoMikudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBkZWxlZ2F0ZSA9IERlbGVnYXRlZEV2ZW50cy5oYXMobmFtZSk7XG4gICAgaWYgKCFkZWxlZ2F0ZSAmJiBwcmV2KSB7XG4gICAgICBjb25zdCBoMiA9IEFycmF5LmlzQXJyYXkocHJldikgPyBwcmV2WzBdIDogcHJldjtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBoMik7XG4gICAgfVxuICAgIGlmIChkZWxlZ2F0ZSB8fCB2YWx1ZSkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBuYW1lLCB2YWx1ZSwgZGVsZWdhdGUpO1xuICAgICAgZGVsZWdhdGUgJiYgZGVsZWdhdGVFdmVudHMoW25hbWVdKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoKGlzQ2hpbGRQcm9wID0gQ2hpbGRQcm9wZXJ0aWVzLmhhcyhwcm9wKSkgfHwgIWlzU1ZHICYmIChQcm9wQWxpYXNlc1twcm9wXSB8fCAoaXNQcm9wID0gUHJvcGVydGllcy5oYXMocHJvcCkpKSB8fCAoaXNDRSA9IG5vZGUubm9kZU5hbWUuaW5jbHVkZXMoXCItXCIpKSkge1xuICAgIGlmIChwcm9wID09PSBcImNsYXNzXCIgfHwgcHJvcCA9PT0gXCJjbGFzc05hbWVcIilcbiAgICAgIGNsYXNzTmFtZShub2RlLCB2YWx1ZSk7XG4gICAgZWxzZSBpZiAoaXNDRSAmJiAhaXNQcm9wICYmICFpc0NoaWxkUHJvcClcbiAgICAgIG5vZGVbdG9Qcm9wZXJ0eU5hbWUocHJvcCldID0gdmFsdWU7XG4gICAgZWxzZVxuICAgICAgbm9kZVtQcm9wQWxpYXNlc1twcm9wXSB8fCBwcm9wXSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5zID0gaXNTVkcgJiYgcHJvcC5pbmRleE9mKFwiOlwiKSA+IC0xICYmIFNWR05hbWVzcGFjZVtwcm9wLnNwbGl0KFwiOlwiKVswXV07XG4gICAgaWYgKG5zKVxuICAgICAgc2V0QXR0cmlidXRlTlMobm9kZSwgbnMsIHByb3AsIHZhbHVlKTtcbiAgICBlbHNlXG4gICAgICBzZXRBdHRyaWJ1dGUobm9kZSwgQWxpYXNlc1twcm9wXSB8fCBwcm9wLCB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gZXZlbnRIYW5kbGVyKGUyKSB7XG4gIGNvbnN0IGtleSA9IGAkJCR7ZTIudHlwZX1gO1xuICBsZXQgbm9kZSA9IGUyLmNvbXBvc2VkUGF0aCAmJiBlMi5jb21wb3NlZFBhdGgoKVswXSB8fCBlMi50YXJnZXQ7XG4gIGlmIChlMi50YXJnZXQgIT09IG5vZGUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZTIsIFwidGFyZ2V0XCIsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBub2RlXG4gICAgfSk7XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUyLCBcImN1cnJlbnRUYXJnZXRcIiwge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gbm9kZSB8fCBkb2N1bWVudDtcbiAgICB9XG4gIH0pO1xuICBpZiAoc2hhcmVkQ29uZmlnLnJlZ2lzdHJ5ICYmICFzaGFyZWRDb25maWcuZG9uZSkge1xuICAgIHNoYXJlZENvbmZpZy5kb25lID0gdHJ1ZTtcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkXj1wbC1dXCIpLmZvckVhY2goKGVsZW0pID0+IHtcbiAgICAgIHdoaWxlIChlbGVtICYmIGVsZW0ubm9kZVR5cGUgIT09IDggJiYgZWxlbS5ub2RlVmFsdWUgIT09IFwicGwtXCIgKyBlMikge1xuICAgICAgICBsZXQgeCA9IGVsZW0ubmV4dFNpYmxpbmc7XG4gICAgICAgIGVsZW0ucmVtb3ZlKCk7XG4gICAgICAgIGVsZW0gPSB4O1xuICAgICAgfVxuICAgICAgZWxlbSAmJiBlbGVtLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG4gIHdoaWxlIChub2RlKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IG5vZGVba2V5XTtcbiAgICBpZiAoaGFuZGxlciAmJiAhbm9kZS5kaXNhYmxlZCkge1xuICAgICAgY29uc3QgZGF0YSA9IG5vZGVbYCR7a2V5fURhdGFgXTtcbiAgICAgIGRhdGEgIT09IHZvaWQgMCA/IGhhbmRsZXIuY2FsbChub2RlLCBkYXRhLCBlMikgOiBoYW5kbGVyLmNhbGwobm9kZSwgZTIpO1xuICAgICAgaWYgKGUyLmNhbmNlbEJ1YmJsZSlcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5fJGhvc3QgfHwgbm9kZS5wYXJlbnROb2RlIHx8IG5vZGUuaG9zdDtcbiAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIHZhbHVlLCBjdXJyZW50LCBtYXJrZXIsIHVud3JhcEFycmF5KSB7XG4gIGlmIChzaGFyZWRDb25maWcuY29udGV4dCAmJiAhY3VycmVudClcbiAgICBjdXJyZW50ID0gWy4uLnBhcmVudC5jaGlsZE5vZGVzXTtcbiAgd2hpbGUgKHR5cGVvZiBjdXJyZW50ID09PSBcImZ1bmN0aW9uXCIpXG4gICAgY3VycmVudCA9IGN1cnJlbnQoKTtcbiAgaWYgKHZhbHVlID09PSBjdXJyZW50KVxuICAgIHJldHVybiBjdXJyZW50O1xuICBjb25zdCB0MiA9IHR5cGVvZiB2YWx1ZSwgbXVsdGkgPSBtYXJrZXIgIT09IHZvaWQgMDtcbiAgcGFyZW50ID0gbXVsdGkgJiYgY3VycmVudFswXSAmJiBjdXJyZW50WzBdLnBhcmVudE5vZGUgfHwgcGFyZW50O1xuICBpZiAodDIgPT09IFwic3RyaW5nXCIgfHwgdDIgPT09IFwibnVtYmVyXCIpIHtcbiAgICBpZiAoc2hhcmVkQ29uZmlnLmNvbnRleHQpXG4gICAgICByZXR1cm4gY3VycmVudDtcbiAgICBpZiAodDIgPT09IFwibnVtYmVyXCIpXG4gICAgICB2YWx1ZSA9IHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgaWYgKG11bHRpKSB7XG4gICAgICBsZXQgbm9kZSA9IGN1cnJlbnRbMF07XG4gICAgICBpZiAobm9kZSAmJiBub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICAgIG5vZGUuZGF0YSA9IHZhbHVlO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSk7XG4gICAgICBjdXJyZW50ID0gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlciwgbm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyZW50ICE9PSBcIlwiICYmIHR5cGVvZiBjdXJyZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGN1cnJlbnQgPSBwYXJlbnQuZmlyc3RDaGlsZC5kYXRhID0gdmFsdWU7XG4gICAgICB9IGVsc2VcbiAgICAgICAgY3VycmVudCA9IHBhcmVudC50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHQyID09PSBcImJvb2xlYW5cIikge1xuICAgIGlmIChzaGFyZWRDb25maWcuY29udGV4dClcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIGN1cnJlbnQgPSBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbWFya2VyKTtcbiAgfSBlbHNlIGlmICh0MiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHtcbiAgICAgIGxldCB2ID0gdmFsdWUoKTtcbiAgICAgIHdoaWxlICh0eXBlb2YgdiA9PT0gXCJmdW5jdGlvblwiKVxuICAgICAgICB2ID0gdigpO1xuICAgICAgY3VycmVudCA9IGluc2VydEV4cHJlc3Npb24ocGFyZW50LCB2LCBjdXJyZW50LCBtYXJrZXIpO1xuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiBjdXJyZW50O1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBjb25zdCBjdXJyZW50QXJyYXkgPSBjdXJyZW50ICYmIEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG4gICAgaWYgKG5vcm1hbGl6ZUluY29taW5nQXJyYXkoYXJyYXksIHZhbHVlLCBjdXJyZW50LCB1bndyYXBBcnJheSkpIHtcbiAgICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBjdXJyZW50ID0gaW5zZXJ0RXhwcmVzc2lvbihwYXJlbnQsIGFycmF5LCBjdXJyZW50LCBtYXJrZXIsIHRydWUpKTtcbiAgICAgIHJldHVybiAoKSA9PiBjdXJyZW50O1xuICAgIH1cbiAgICBpZiAoc2hhcmVkQ29uZmlnLmNvbnRleHQpIHtcbiAgICAgIGlmICghYXJyYXkubGVuZ3RoKVxuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBhcnJheS5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2kyXS5wYXJlbnROb2RlKVxuICAgICAgICAgIHJldHVybiBjdXJyZW50ID0gYXJyYXk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhcnJheS5sZW5ndGggPT09IDApIHtcbiAgICAgIGN1cnJlbnQgPSBjbGVhbkNoaWxkcmVuKHBhcmVudCwgY3VycmVudCwgbWFya2VyKTtcbiAgICAgIGlmIChtdWx0aSlcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50QXJyYXkpIHtcbiAgICAgIGlmIChjdXJyZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBhcHBlbmROb2RlcyhwYXJlbnQsIGFycmF5LCBtYXJrZXIpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHJlY29uY2lsZUFycmF5cyhwYXJlbnQsIGN1cnJlbnQsIGFycmF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudCAmJiBjbGVhbkNoaWxkcmVuKHBhcmVudCk7XG4gICAgICBhcHBlbmROb2RlcyhwYXJlbnQsIGFycmF5KTtcbiAgICB9XG4gICAgY3VycmVudCA9IGFycmF5O1xuICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgIGlmIChzaGFyZWRDb25maWcuY29udGV4dCAmJiB2YWx1ZS5wYXJlbnROb2RlKVxuICAgICAgcmV0dXJuIGN1cnJlbnQgPSBtdWx0aSA/IFt2YWx1ZV0gOiB2YWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50KSkge1xuICAgICAgaWYgKG11bHRpKVxuICAgICAgICByZXR1cm4gY3VycmVudCA9IGNsZWFuQ2hpbGRyZW4ocGFyZW50LCBjdXJyZW50LCBtYXJrZXIsIHZhbHVlKTtcbiAgICAgIGNsZWFuQ2hpbGRyZW4ocGFyZW50LCBjdXJyZW50LCBudWxsLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50ID09IG51bGwgfHwgY3VycmVudCA9PT0gXCJcIiB8fCAhcGFyZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHBhcmVudC5hcHBlbmRDaGlsZCh2YWx1ZSk7XG4gICAgfSBlbHNlXG4gICAgICBwYXJlbnQucmVwbGFjZUNoaWxkKHZhbHVlLCBwYXJlbnQuZmlyc3RDaGlsZCk7XG4gICAgY3VycmVudCA9IHZhbHVlO1xuICB9IGVsc2VcbiAgICA7XG4gIHJldHVybiBjdXJyZW50O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplSW5jb21pbmdBcnJheShub3JtYWxpemVkLCBhcnJheSwgY3VycmVudCwgdW53cmFwMikge1xuICBsZXQgZHluYW1pYyA9IGZhbHNlO1xuICBmb3IgKGxldCBpMiA9IDAsIGxlbiA9IGFycmF5Lmxlbmd0aDsgaTIgPCBsZW47IGkyKyspIHtcbiAgICBsZXQgaXRlbSA9IGFycmF5W2kyXSwgcHJldiA9IGN1cnJlbnQgJiYgY3VycmVudFtpMl07XG4gICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICBub3JtYWxpemVkLnB1c2goaXRlbSk7XG4gICAgfSBlbHNlIGlmIChpdGVtID09IG51bGwgfHwgaXRlbSA9PT0gdHJ1ZSB8fCBpdGVtID09PSBmYWxzZSlcbiAgICAgIDtcbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGl0ZW0pKSB7XG4gICAgICBkeW5hbWljID0gbm9ybWFsaXplSW5jb21pbmdBcnJheShub3JtYWxpemVkLCBpdGVtLCBwcmV2KSB8fCBkeW5hbWljO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGl0ZW0gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKHVud3JhcDIpIHtcbiAgICAgICAgd2hpbGUgKHR5cGVvZiBpdGVtID09PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgaXRlbSA9IGl0ZW0oKTtcbiAgICAgICAgZHluYW1pYyA9IG5vcm1hbGl6ZUluY29taW5nQXJyYXkobm9ybWFsaXplZCwgQXJyYXkuaXNBcnJheShpdGVtKSA/IGl0ZW0gOiBbaXRlbV0sIEFycmF5LmlzQXJyYXkocHJldikgPyBwcmV2IDogW3ByZXZdKSB8fCBkeW5hbWljO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKGl0ZW0pO1xuICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdmFsdWUgPSBTdHJpbmcoaXRlbSk7XG4gICAgICBpZiAocHJldiAmJiBwcmV2Lm5vZGVUeXBlID09PSAzICYmIHByZXYuZGF0YSA9PT0gdmFsdWUpIHtcbiAgICAgICAgbm9ybWFsaXplZC5wdXNoKHByZXYpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIG5vcm1hbGl6ZWQucHVzaChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZHluYW1pYztcbn1cbmZ1bmN0aW9uIGFwcGVuZE5vZGVzKHBhcmVudCwgYXJyYXksIG1hcmtlciA9IG51bGwpIHtcbiAgZm9yIChsZXQgaTIgPSAwLCBsZW4gPSBhcnJheS5sZW5ndGg7IGkyIDwgbGVuOyBpMisrKVxuICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoYXJyYXlbaTJdLCBtYXJrZXIpO1xufVxuZnVuY3Rpb24gY2xlYW5DaGlsZHJlbihwYXJlbnQsIGN1cnJlbnQsIG1hcmtlciwgcmVwbGFjZW1lbnQpIHtcbiAgaWYgKG1hcmtlciA9PT0gdm9pZCAwKVxuICAgIHJldHVybiBwYXJlbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuICBjb25zdCBub2RlID0gcmVwbGFjZW1lbnQgfHwgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7XG4gIGlmIChjdXJyZW50Lmxlbmd0aCkge1xuICAgIGxldCBpbnNlcnRlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkyID0gY3VycmVudC5sZW5ndGggLSAxOyBpMiA+PSAwOyBpMi0tKSB7XG4gICAgICBjb25zdCBlbCA9IGN1cnJlbnRbaTJdO1xuICAgICAgaWYgKG5vZGUgIT09IGVsKSB7XG4gICAgICAgIGNvbnN0IGlzUGFyZW50ID0gZWwucGFyZW50Tm9kZSA9PT0gcGFyZW50O1xuICAgICAgICBpZiAoIWluc2VydGVkICYmICFpMilcbiAgICAgICAgICBpc1BhcmVudCA/IHBhcmVudC5yZXBsYWNlQ2hpbGQobm9kZSwgZWwpIDogcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBtYXJrZXIpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgaXNQYXJlbnQgJiYgZWwucmVtb3ZlKCk7XG4gICAgICB9IGVsc2VcbiAgICAgICAgaW5zZXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlXG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShub2RlLCBtYXJrZXIpO1xuICByZXR1cm4gW25vZGVdO1xufVxuZnVuY3Rpb24gZ2V0SHlkcmF0aW9uS2V5KCkge1xuICBjb25zdCBoeWRyYXRlID0gc2hhcmVkQ29uZmlnLmNvbnRleHQ7XG4gIHJldHVybiBgJHtoeWRyYXRlLmlkfSR7aHlkcmF0ZS5jb3VudCsrfWA7XG59XG5jb25zdCBTVkdfTkFNRVNQQUNFID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBpc1NWRyA9IGZhbHNlKSB7XG4gIHJldHVybiBpc1NWRyA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTkFNRVNQQUNFLCB0YWdOYW1lKSA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnTmFtZSk7XG59XG5mdW5jdGlvbiBQb3J0YWwocHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIHVzZVNoYWRvd1xuICB9ID0gcHJvcHMsIG1hcmtlciA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpLCBtb3VudCA9IHByb3BzLm1vdW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIGZ1bmN0aW9uIHJlbmRlclBvcnRhbCgpIHtcbiAgICBpZiAoc2hhcmVkQ29uZmlnLmNvbnRleHQpIHtcbiAgICAgIGNvbnN0IFtzMiwgc2V0XSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiBzZXQodHJ1ZSkpO1xuICAgICAgcmV0dXJuICgpID0+IHMyKCkgJiYgcHJvcHMuY2hpbGRyZW47XG4gICAgfSBlbHNlXG4gICAgICByZXR1cm4gKCkgPT4gcHJvcHMuY2hpbGRyZW47XG4gIH1cbiAgaWYgKG1vdW50IGluc3RhbmNlb2YgSFRNTEhlYWRFbGVtZW50KSB7XG4gICAgY29uc3QgW2NsZWFuLCBzZXRDbGVhbl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiBzZXRDbGVhbih0cnVlKTtcbiAgICBjcmVhdGVSb290KChkaXNwb3NlMikgPT4gaW5zZXJ0KG1vdW50LCAoKSA9PiAhY2xlYW4oKSA/IHJlbmRlclBvcnRhbCgpKCkgOiBkaXNwb3NlMigpLCBudWxsKSk7XG4gICAgb25DbGVhbnVwKCgpID0+IHtcbiAgICAgIGlmIChzaGFyZWRDb25maWcuY29udGV4dClcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soY2xlYW51cCk7XG4gICAgICBlbHNlXG4gICAgICAgIGNsZWFudXAoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBjcmVhdGVFbGVtZW50KHByb3BzLmlzU1ZHID8gXCJnXCIgOiBcImRpdlwiLCBwcm9wcy5pc1NWRyksIHJlbmRlclJvb3QgPSB1c2VTaGFkb3cgJiYgY29udGFpbmVyLmF0dGFjaFNoYWRvdyA/IGNvbnRhaW5lci5hdHRhY2hTaGFkb3coe1xuICAgICAgbW9kZTogXCJvcGVuXCJcbiAgICB9KSA6IGNvbnRhaW5lcjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29udGFpbmVyLCBcIl8kaG9zdFwiLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXIucGFyZW50Tm9kZTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBpbnNlcnQocmVuZGVyUm9vdCwgcmVuZGVyUG9ydGFsKCkpO1xuICAgIG1vdW50LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgcHJvcHMucmVmICYmIHByb3BzLnJlZihjb250YWluZXIpO1xuICAgIG9uQ2xlYW51cCgoKSA9PiBtb3VudC5yZW1vdmVDaGlsZChjb250YWluZXIpKTtcbiAgfVxuICByZXR1cm4gbWFya2VyO1xufVxuZnVuY3Rpb24gRHluYW1pYyhwcm9wcykge1xuICBjb25zdCBbcDIsIG90aGVyc10gPSBzcGxpdFByb3BzKHByb3BzLCBbXCJjb21wb25lbnRcIl0pO1xuICBjb25zdCBjYWNoZWQgPSBjcmVhdGVNZW1vKCgpID0+IHAyLmNvbXBvbmVudCk7XG4gIHJldHVybiBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjb21wb25lbnQgPSBjYWNoZWQoKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBjb21wb25lbnQpIHtcbiAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICByZXR1cm4gdW50cmFjaygoKSA9PiBjb21wb25lbnQob3RoZXJzKSk7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGNvbnN0IGlzU3ZnID0gU1ZHRWxlbWVudHMuaGFzKGNvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IGVsID0gc2hhcmVkQ29uZmlnLmNvbnRleHQgPyBnZXROZXh0RWxlbWVudCgpIDogY3JlYXRlRWxlbWVudChjb21wb25lbnQsIGlzU3ZnKTtcbiAgICAgICAgc3ByZWFkKGVsLCBvdGhlcnMsIGlzU3ZnKTtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgIH1cbiAgfSk7XG59XG5jb25zdCBbd2FsbGV0c01vZGFsT3Blbiwgc2V0V2FsbGV0c01vZGFsT3Blbl0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuY29uc3QgW2xhc3RTZWxlY3RlZFdhbGxldEluZm8sIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm9dID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuY29uc3QgW2FjdGlvbiwgc2V0QWN0aW9uXSA9IGNyZWF0ZVNpZ25hbChudWxsKTtcbmxldCBlID0geyBkYXRhOiBcIlwiIH0sIHQgPSAodDIpID0+IFwib2JqZWN0XCIgPT0gdHlwZW9mIHdpbmRvdyA/ICgodDIgPyB0Mi5xdWVyeVNlbGVjdG9yKFwiI19nb29iZXJcIikgOiB3aW5kb3cuX2dvb2JlcikgfHwgT2JqZWN0LmFzc2lnbigodDIgfHwgZG9jdW1lbnQuaGVhZCkuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpKSwgeyBpbm5lckhUTUw6IFwiIFwiLCBpZDogXCJfZ29vYmVyXCIgfSkpLmZpcnN0Q2hpbGQgOiB0MiB8fCBlLCBsID0gLyg/OihbXFx1MDA4MC1cXHVGRkZGXFx3LSVAXSspICo6PyAqKFteeztdKz8pO3woW147fXtdKj8pICp7KXwofVxccyopL2csIGEgPSAvXFwvXFwqW15dKj9cXCpcXC98ICArL2csIG4gPSAvXFxuKy9nLCBvID0gKGUyLCB0MikgPT4ge1xuICBsZXQgciA9IFwiXCIsIGwyID0gXCJcIiwgYTIgPSBcIlwiO1xuICBmb3IgKGxldCBuMiBpbiBlMikge1xuICAgIGxldCBjMiA9IGUyW24yXTtcbiAgICBcIkBcIiA9PSBuMlswXSA/IFwiaVwiID09IG4yWzFdID8gciA9IG4yICsgXCIgXCIgKyBjMiArIFwiO1wiIDogbDIgKz0gXCJmXCIgPT0gbjJbMV0gPyBvKGMyLCBuMikgOiBuMiArIFwie1wiICsgbyhjMiwgXCJrXCIgPT0gbjJbMV0gPyBcIlwiIDogdDIpICsgXCJ9XCIgOiBcIm9iamVjdFwiID09IHR5cGVvZiBjMiA/IGwyICs9IG8oYzIsIHQyID8gdDIucmVwbGFjZSgvKFteLF0pKy9nLCAoZTMpID0+IG4yLnJlcGxhY2UoLyheOi4qKXwoW14sXSkrL2csICh0MykgPT4gLyYvLnRlc3QodDMpID8gdDMucmVwbGFjZSgvJi9nLCBlMykgOiBlMyA/IGUzICsgXCIgXCIgKyB0MyA6IHQzKSkgOiBuMikgOiBudWxsICE9IGMyICYmIChuMiA9IC9eLS0vLnRlc3QobjIpID8gbjIgOiBuMi5yZXBsYWNlKC9bQS1aXS9nLCBcIi0kJlwiKS50b0xvd2VyQ2FzZSgpLCBhMiArPSBvLnAgPyBvLnAobjIsIGMyKSA6IG4yICsgXCI6XCIgKyBjMiArIFwiO1wiKTtcbiAgfVxuICByZXR1cm4gciArICh0MiAmJiBhMiA/IHQyICsgXCJ7XCIgKyBhMiArIFwifVwiIDogYTIpICsgbDI7XG59LCBjID0ge30sIHMgPSAoZTIpID0+IHtcbiAgaWYgKFwib2JqZWN0XCIgPT0gdHlwZW9mIGUyKSB7XG4gICAgbGV0IHQyID0gXCJcIjtcbiAgICBmb3IgKGxldCByIGluIGUyKVxuICAgICAgdDIgKz0gciArIHMoZTJbcl0pO1xuICAgIHJldHVybiB0MjtcbiAgfVxuICByZXR1cm4gZTI7XG59LCBpID0gKGUyLCB0MiwgciwgaTIsIHAyKSA9PiB7XG4gIGxldCB1MiA9IHMoZTIpLCBkID0gY1t1Ml0gfHwgKGNbdTJdID0gKChlMykgPT4ge1xuICAgIGxldCB0MyA9IDAsIHIyID0gMTE7XG4gICAgZm9yICg7IHQzIDwgZTMubGVuZ3RoOyApXG4gICAgICByMiA9IDEwMSAqIHIyICsgZTMuY2hhckNvZGVBdCh0MysrKSA+Pj4gMDtcbiAgICByZXR1cm4gXCJnb1wiICsgcjI7XG4gIH0pKHUyKSk7XG4gIGlmICghY1tkXSkge1xuICAgIGxldCB0MyA9IHUyICE9PSBlMiA/IGUyIDogKChlMykgPT4ge1xuICAgICAgbGV0IHQ0LCByMiwgbzIgPSBbe31dO1xuICAgICAgZm9yICg7IHQ0ID0gbC5leGVjKGUzLnJlcGxhY2UoYSwgXCJcIikpOyApXG4gICAgICAgIHQ0WzRdID8gbzIuc2hpZnQoKSA6IHQ0WzNdID8gKHIyID0gdDRbM10ucmVwbGFjZShuLCBcIiBcIikudHJpbSgpLCBvMi51bnNoaWZ0KG8yWzBdW3IyXSA9IG8yWzBdW3IyXSB8fCB7fSkpIDogbzJbMF1bdDRbMV1dID0gdDRbMl0ucmVwbGFjZShuLCBcIiBcIikudHJpbSgpO1xuICAgICAgcmV0dXJuIG8yWzBdO1xuICAgIH0pKGUyKTtcbiAgICBjW2RdID0gbyhwMiA/IHsgW1wiQGtleWZyYW1lcyBcIiArIGRdOiB0MyB9IDogdDMsIHIgPyBcIlwiIDogXCIuXCIgKyBkKTtcbiAgfVxuICBsZXQgZiA9IHIgJiYgYy5nID8gYy5nIDogbnVsbDtcbiAgcmV0dXJuIHIgJiYgKGMuZyA9IGNbZF0pLCAoKGUzLCB0MywgcjIsIGwyKSA9PiB7XG4gICAgbDIgPyB0My5kYXRhID0gdDMuZGF0YS5yZXBsYWNlKGwyLCBlMykgOiAtMSA9PT0gdDMuZGF0YS5pbmRleE9mKGUzKSAmJiAodDMuZGF0YSA9IHIyID8gZTMgKyB0My5kYXRhIDogdDMuZGF0YSArIGUzKTtcbiAgfSkoY1tkXSwgdDIsIGkyLCBmKSwgZDtcbn0sIHAgPSAoZTIsIHQyLCByKSA9PiBlMi5yZWR1Y2UoKGUzLCBsMiwgYTIpID0+IHtcbiAgbGV0IG4yID0gdDJbYTJdO1xuICBpZiAobjIgJiYgbjIuY2FsbCkge1xuICAgIGxldCBlNCA9IG4yKHIpLCB0MyA9IGU0ICYmIGU0LnByb3BzICYmIGU0LnByb3BzLmNsYXNzTmFtZSB8fCAvXmdvLy50ZXN0KGU0KSAmJiBlNDtcbiAgICBuMiA9IHQzID8gXCIuXCIgKyB0MyA6IGU0ICYmIFwib2JqZWN0XCIgPT0gdHlwZW9mIGU0ID8gZTQucHJvcHMgPyBcIlwiIDogbyhlNCwgXCJcIikgOiBmYWxzZSA9PT0gZTQgPyBcIlwiIDogZTQ7XG4gIH1cbiAgcmV0dXJuIGUzICsgbDIgKyAobnVsbCA9PSBuMiA/IFwiXCIgOiBuMik7XG59LCBcIlwiKTtcbmZ1bmN0aW9uIHUoZTIpIHtcbiAgbGV0IHIgPSB0aGlzIHx8IHt9LCBsMiA9IGUyLmNhbGwgPyBlMihyLnApIDogZTI7XG4gIHJldHVybiBpKGwyLnVuc2hpZnQgPyBsMi5yYXcgPyBwKGwyLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksIHIucCkgOiBsMi5yZWR1Y2UoKGUzLCB0MikgPT4gT2JqZWN0LmFzc2lnbihlMywgdDIgJiYgdDIuY2FsbCA/IHQyKHIucCkgOiB0MiksIHt9KSA6IGwyLCB0KHIudGFyZ2V0KSwgci5nLCByLm8sIHIuayk7XG59XG51LmJpbmQoeyBnOiAxIH0pO1xubGV0IGggPSB1LmJpbmQoeyBrOiAxIH0pO1xuY29uc3QgVGhlbWVDb250ZXh0ID0gY3JlYXRlQ29udGV4dCgpO1xuZnVuY3Rpb24gVGhlbWVQcm92aWRlcihwcm9wcykge1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRoZW1lQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBwcm9wcy50aGVtZSxcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHVzZVRoZW1lKCkge1xuICByZXR1cm4gdXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xufVxuZnVuY3Rpb24gbWFrZVN0eWxlZCh0YWcpIHtcbiAgbGV0IF9jdHggPSB0aGlzIHx8IHt9O1xuICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICBjb25zdCBTdHlsZWQgPSAocHJvcHMpID0+IHtcbiAgICAgIGNvbnN0IHRoZW1lID0gdXNlQ29udGV4dChUaGVtZUNvbnRleHQpO1xuICAgICAgY29uc3Qgd2l0aFRoZW1lID0gbWVyZ2VQcm9wcyhwcm9wcywgeyB0aGVtZSB9KTtcbiAgICAgIGNvbnN0IGNsb25lID0gbWVyZ2VQcm9wcyh3aXRoVGhlbWUsIHtcbiAgICAgICAgZ2V0IGNsYXNzKCkge1xuICAgICAgICAgIGNvbnN0IHBDbGFzcyA9IHdpdGhUaGVtZS5jbGFzcywgYXBwZW5kID0gXCJjbGFzc1wiIGluIHdpdGhUaGVtZSAmJiAvXmdvWzAtOV0rLy50ZXN0KHBDbGFzcyk7XG4gICAgICAgICAgbGV0IGNsYXNzTmFtZTIgPSB1LmFwcGx5KFxuICAgICAgICAgICAgeyB0YXJnZXQ6IF9jdHgudGFyZ2V0LCBvOiBhcHBlbmQsIHA6IHdpdGhUaGVtZSwgZzogX2N0eC5nIH0sXG4gICAgICAgICAgICBhcmdzXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm4gW3BDbGFzcywgY2xhc3NOYW1lMl0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCIgXCIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IFtsb2NhbCwgbmV3UHJvcHNdID0gc3BsaXRQcm9wcyhjbG9uZSwgW1wiYXNcIiwgXCJ0aGVtZVwiXSk7XG4gICAgICBjb25zdCBodG1sUHJvcHMgPSBuZXdQcm9wcztcbiAgICAgIGNvbnN0IGNyZWF0ZVRhZyA9IGxvY2FsLmFzIHx8IHRhZztcbiAgICAgIGxldCBlbDtcbiAgICAgIGlmICh0eXBlb2YgY3JlYXRlVGFnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgZWwgPSBjcmVhdGVUYWcoaHRtbFByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoX2N0eC5nID09IDEpIHtcbiAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjcmVhdGVUYWcpO1xuICAgICAgICAgICAgc3ByZWFkKGVsLCBodG1sUHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbCA9IER5bmFtaWMobWVyZ2VQcm9wcyh7IGNvbXBvbmVudDogY3JlYXRlVGFnIH0sIGh0bWxQcm9wcykpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsO1xuICAgIH07XG4gICAgU3R5bGVkLmNsYXNzID0gKHByb3BzKSA9PiB7XG4gICAgICByZXR1cm4gdW50cmFjaygoKSA9PiB7XG4gICAgICAgIHJldHVybiB1LmFwcGx5KHsgdGFyZ2V0OiBfY3R4LnRhcmdldCwgcDogcHJvcHMsIGc6IF9jdHguZyB9LCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIFN0eWxlZDtcbiAgfTtcbn1cbmNvbnN0IHN0eWxlZCA9IG5ldyBQcm94eShtYWtlU3R5bGVkLCB7XG4gIGdldCh0YXJnZXQsIHRhZykge1xuICAgIHJldHVybiB0YXJnZXQodGFnKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxTdHlsZXMoKSB7XG4gIGNvbnN0IGZuID0gbWFrZVN0eWxlZC5jYWxsKHsgZzogMSB9LCBcImRpdlwiKS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gZnVuY3Rpb24gR2xvYmFsU3R5bGVzMihwcm9wcykge1xuICAgIGZuKHByb3BzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cbmNvbnN0IGNvbW1vbiQxID0ge1xuICBjbG9zZTogXCJDbG9zZVwiLFxuICBvcGVuV2FsbGV0OiBcIk9wZW4gd2FsbGV0XCIsXG4gIGdldDogXCJHRVRcIixcbiAgbGVhcm5Nb3JlOiBcIkxlYXJuIG1vcmVcIixcbiAgb3BlbkV4dGVuc2lvbjogXCJPcGVuIEV4dGVuc2lvblwiLFxuICBjb3B5TGluazogXCJDb3B5IExpbmtcIixcbiAgY29waWVkOiBcIkNvcGllZCFcIixcbiAgeW91cldhbGxldDogXCJ5b3VyIHdhbGxldFwiXG59O1xuY29uc3QgYnV0dG9uJDEgPSB7XG4gIGNvbm5lY3RXYWxsZXQ6IFwiQ29ubmVjdCBXYWxsZXRcIixcbiAgZHJvcGRvd246IHtcbiAgICBjb3B5OiBcIkNvcHkgYWRkcmVzc1wiLFxuICAgIGNvcGllZDogXCJBZGRyZXNzIGNvcGllZCFcIixcbiAgICBkaXNjb25uZWN0OiBcIkRpc2Nvbm5lY3RcIlxuICB9XG59O1xuY29uc3Qgbm90aWZpY2F0aW9ucyQxID0ge1xuICBjb25maXJtOiB7XG4gICAgaGVhZGVyOiBcIk9wZW4ge3sgbmFtZSB9fSB0b1xceEEwY29uZmlybSB0aGVcXHhBMHRyYW5zYWN0aW9uLlwiXG4gIH0sXG4gIHRyYW5zYWN0aW9uU2VudDoge1xuICAgIGhlYWRlcjogXCJUcmFuc2FjdGlvbiBzZW50XCIsXG4gICAgdGV4dDogXCJZb3VyIHRyYW5zYWN0aW9uXFx4QTB3aWxsIGJlXFx4QTBwcm9jZXNzZWQgaW5cXHhBMGFcXHhBMGZldyBzZWNvbmRzLlwiXG4gIH0sXG4gIHRyYW5zYWN0aW9uQ2FuY2VsZWQ6IHtcbiAgICBoZWFkZXI6IFwiVHJhbnNhY3Rpb24gY2FuY2VsZWRcIixcbiAgICB0ZXh0OiBcIlRoZXJlIHdpbGwgYmUgbm8gY2hhbmdlcyB0byB5b3VyIGFjY291bnQuXCJcbiAgfVxufTtcbmNvbnN0IHdhbGxldE1vZGFsJDEgPSB7XG4gIGxvYWRpbmc6IFwiTG9hZGluZyB3YWxsZXRzXCIsXG4gIHFyQ29kZTogXCJRUiBDb2RlXCIsXG4gIHdhbGxldHM6IFwiV2FsbGV0c1wiLFxuICB1bml2ZXJzYWxRUk1vZGFsOiB7XG4gICAgc2NhblFSOiBcIlNjYW4gdGhlXFx4QTBjb2RlIGJlbG93IHdpdGggYSBjYW1lcmEgaW4geW91ciBUT04gd2FsbGV0LlwiLFxuICAgIG9wZW5XYWxsZXQ6IFwiT3BlbiBXYWxsZXRcIixcbiAgICBvcGVuSW5zdGFsbGVkV2FsbGV0OiBcIk9wZW4gV2FsbGV0XCIsXG4gICAgZG9udEhhdmU6IFwiRXhwbG9yZSBUT04gd2FsbGV0c1wiXG4gIH0sXG4gIGRlc2t0b3BTZWxlY3RXYWxsZXRNb2RhbDoge1xuICAgIHNlbGVjdFdhbGxldDogXCJTZWxlY3QgYVxceEEwd2FsbGV0IHRvXFx4QTBjb25uZWN0LlwiXG4gIH0sXG4gIG1vYmlsZVNlbGVjdFdhbGxldE1vZGFsOiB7XG4gICAgY29ubmVjdFdhbGxldDogXCJDb25uZWN0IGFcXHhBMFdhbGxldFwiLFxuICAgIHNlbGVjdFdhbGxldDogXCIkd2FsbGV0TW9kYWwuZGVza3RvcFNlbGVjdFdhbGxldE1vZGFsLnNlbGVjdFdhbGxldFwiLFxuICAgIGluc3RhbGxlZFdhbGxldDogXCJJbnN0YWxsZWQgV2FsbGV0XCJcbiAgfSxcbiAgcXJDb2RlTW9kYWw6IHtcbiAgICBjb25uZWN0V2l0aDogXCJDb25uZWN0IHdpdGhcXHhBMHt7IG5hbWUgfX1cIixcbiAgICBzY2FuOiBcIlNjYW4gdGhlXFx4QTBjb2RlIGJlbG93LlwiLFxuICAgIG9wZW5XYWxsZXQ6IFwiT3BlbiB7eyBuYW1lIH19XCIsXG4gICAgb3BlbkV4dGVuc2lvbjogXCJPcGVuIEV4dGVuc2lvblwiLFxuICAgIGRvbnRIYXZlOiBcIkRvbid0IGhhdmUge3sgbmFtZSB9fT9cIlxuICB9XG59O1xuY29uc3QgYWN0aW9uTW9kYWwkMSA9IHtcbiAgY29uZmlybVRyYW5zYWN0aW9uOiB7XG4gICAgaGVhZGVyOiBcIkNvbmZpcm0gdGhlXFx4QTB0cmFuc2FjdGlvbiBpblxceEEwe3sgbmFtZSB9fVwiLFxuICAgIHRleHQ6IFwiSXQgd2lsbCBvbmx5IHRha2UgYVxceEEwbW9tZW50LlwiXG4gIH0sXG4gIHRyYW5zYWN0aW9uU2VudDogXCIkbm90aWZpY2F0aW9ucy50cmFuc2FjdGlvblNlbnRcIixcbiAgdHJhbnNhY3Rpb25DYW5jZWxlZDogXCIkbm90aWZpY2F0aW9ucy50cmFuc2FjdGlvbkNhbmNlbGVkXCJcbn07XG5jb25zdCBlbiA9IHtcbiAgY29tbW9uOiBjb21tb24kMSxcbiAgYnV0dG9uOiBidXR0b24kMSxcbiAgbm90aWZpY2F0aW9uczogbm90aWZpY2F0aW9ucyQxLFxuICB3YWxsZXRNb2RhbDogd2FsbGV0TW9kYWwkMSxcbiAgYWN0aW9uTW9kYWw6IGFjdGlvbk1vZGFsJDFcbn07XG5jb25zdCBjb21tb24gPSB7XG4gIGNsb3NlOiBcIlxcdTA0MTdcXHUwNDMwXFx1MDQzQVxcdTA0NDBcXHUwNDRCXFx1MDQ0MlxcdTA0NENcIixcbiAgb3BlbldhbGxldDogXCJcXHUwNDFFXFx1MDQ0MlxcdTA0M0FcXHUwNDQwXFx1MDQ0QlxcdTA0NDJcXHUwNDRDIFxcdTA0M0FcXHUwNDNFXFx1MDQ0OFxcdTA0MzVcXHUwNDNCXFx1MDQzNVxcdTA0M0FcIixcbiAgZ2V0OiBcIlxcdTA0MjFcXHUwNDNBXFx1MDQzMFxcdTA0NDdcXHUwNDMwXFx1MDQ0MlxcdTA0NENcIixcbiAgbGVhcm5Nb3JlOiBcIlxcdTA0MUZcXHUwNDNFXFx1MDQzNFxcdTA0NDBcXHUwNDNFXFx1MDQzMVxcdTA0M0RcXHUwNDM1XFx1MDQzNVwiLFxuICBvcGVuRXh0ZW5zaW9uOiBcIlxcdTA0MjBcXHUwNDMwXFx1MDQ0MVxcdTA0NDhcXHUwNDM4XFx1MDQ0MFxcdTA0MzVcXHUwNDNEXFx1MDQzOFxcdTA0MzVcIixcbiAgY29weUxpbms6IFwiXFx1MDQxQVxcdTA0M0VcXHUwNDNGXFx1MDQzOFxcdTA0NDBcXHUwNDNFXFx1MDQzMlxcdTA0MzBcXHUwNDQyXFx1MDQ0QyBcXHUwNDQxXFx1MDQ0MVxcdTA0NEJcXHUwNDNCXFx1MDQzQVxcdTA0NDNcIixcbiAgY29waWVkOiBcIlxcdTA0MjFcXHUwNDNBXFx1MDQzRVxcdTA0M0ZcXHUwNDM4XFx1MDQ0MFxcdTA0M0VcXHUwNDMyXFx1MDQzMFxcdTA0M0RcXHUwNDNFIVwiLFxuICB5b3VyV2FsbGV0OiBcIlxcdTA0MzJcXHUwNDMwXFx1MDQ0OFxcdTA0MzVcXHUwNDNDIFxcdTA0M0FcXHUwNDNFXFx1MDQ0OFxcdTA0MzVcXHUwNDNCXFx1MDQ0Q1xcdTA0M0FcXHUwNDM1XCJcbn07XG5jb25zdCBidXR0b24gPSB7XG4gIGNvbm5lY3RXYWxsZXQ6IFwiXFx1MDQxRlxcdTA0M0VcXHUwNDM0XFx1MDQzQVxcdTA0M0JcXHUwNDRFXFx1MDQ0N1xcdTA0MzhcXHUwNDQyXFx1MDQ0QyBcXHUwNDNBXFx1MDQzRVxcdTA0NDhcXHUwNDM1XFx1MDQzQlxcdTA0NTFcXHUwNDNBXCIsXG4gIGRyb3Bkb3duOiB7XG4gICAgY29weTogXCJcXHUwNDIxXFx1MDQzQVxcdTA0M0VcXHUwNDNGXFx1MDQzOFxcdTA0NDBcXHUwNDNFXFx1MDQzMlxcdTA0MzBcXHUwNDQyXFx1MDQ0QyBcXHUwNDMwXFx1MDQzNFxcdTA0NDBcXHUwNDM1XFx1MDQ0MVwiLFxuICAgIGNvcGllZDogXCJcXHUwNDEwXFx1MDQzNFxcdTA0NDBcXHUwNDM1XFx1MDQ0MSBcXHUwNDQxXFx1MDQzQVxcdTA0M0VcXHUwNDNGXFx1MDQzOFxcdTA0NDBcXHUwNDNFXFx1MDQzMlxcdTA0MzBcXHUwNDNEIVwiLFxuICAgIGRpc2Nvbm5lY3Q6IFwiXFx1MDQxRVxcdTA0NDJcXHUwNDNBXFx1MDQzQlxcdTA0NEVcXHUwNDQ3XFx1MDQzOFxcdTA0NDJcXHUwNDRDIFxcdTA0M0FcXHUwNDNFXFx1MDQ0OFxcdTA0MzVcXHUwNDNCXFx1MDQ1MVxcdTA0M0FcIlxuICB9XG59O1xuY29uc3Qgbm90aWZpY2F0aW9ucyA9IHtcbiAgY29uZmlybToge1xuICAgIGhlYWRlcjogXCJcXHUwNDFFXFx1MDQ0MlxcdTA0M0FcXHUwNDQwXFx1MDQzRVxcdTA0MzlcXHUwNDQyXFx1MDQzNSB7eyBuYW1lIH19LCBcXHUwNDQ3XFx1MDQ0MlxcdTA0M0VcXHUwNDMxXFx1MDQ0QiBcXHUwNDNGXFx1MDQzRVxcdTA0MzRcXHUwNDQyXFx1MDQzMlxcdTA0MzVcXHUwNDQwXFx1MDQzNFxcdTA0MzhcXHUwNDQyXFx1MDQ0QyBcXHUwNDQyXFx1MDQ0MFxcdTA0MzBcXHUwNDNEXFx1MDQzN1xcdTA0MzBcXHUwNDNBXFx1MDQ0NlxcdTA0MzhcXHUwNDRFLlwiXG4gIH0sXG4gIHRyYW5zYWN0aW9uU2VudDoge1xuICAgIGhlYWRlcjogXCJcXHUwNDIyXFx1MDQ0MFxcdTA0MzBcXHUwNDNEXFx1MDQzN1xcdTA0MzBcXHUwNDNBXFx1MDQ0NlxcdTA0MzhcXHUwNDRGIFxcdTA0M0VcXHUwNDQyXFx1MDQzRlxcdTA0NDBcXHUwNDMwXFx1MDQzMlxcdTA0M0JcXHUwNDM1XFx1MDQzRFxcdTA0MzBcIixcbiAgICB0ZXh0OiBcIlxcdTA0MTJcXHUwNDMwXFx1MDQ0OFxcdTA0MzAgXFx1MDQ0MlxcdTA0NDBcXHUwNDMwXFx1MDQzRFxcdTA0MzdcXHUwNDMwXFx1MDQzQVxcdTA0NDZcXHUwNDM4XFx1MDQ0RlxceEEwXFx1MDQzMVxcdTA0NDNcXHUwNDM0XFx1MDQzNVxcdTA0NDIgXFx1MDQzRVxcdTA0MzFcXHUwNDQwXFx1MDQzMFxcdTA0MzFcXHUwNDNFXFx1MDQ0MlxcdTA0MzBcXHUwNDNEXFx1MDQzMCBcXHUwNDQ3XFx1MDQzNVxcdTA0NDBcXHUwNDM1XFx1MDQzN1xceEEwXFx1MDQzRFxcdTA0MzVcXHUwNDQxXFx1MDQzQVxcdTA0M0VcXHUwNDNCXFx1MDQ0Q1xcdTA0M0FcXHUwNDNFIFxcdTA0NDFcXHUwNDM1XFx1MDQzQVxcdTA0NDNcXHUwNDNEXFx1MDQzNC5cIlxuICB9LFxuICB0cmFuc2FjdGlvbkNhbmNlbGVkOiB7XG4gICAgaGVhZGVyOiBcIlxcdTA0MjJcXHUwNDQwXFx1MDQzMFxcdTA0M0RcXHUwNDM3XFx1MDQzMFxcdTA0M0FcXHUwNDQ2XFx1MDQzOFxcdTA0NEYgXFx1MDQzRVxcdTA0NDJcXHUwNDNDXFx1MDQzNVxcdTA0M0RcXHUwNDM1XFx1MDQzRFxcdTA0MzBcIixcbiAgICB0ZXh0OiBcIlxcdTA0MjFcXHUwNDNFXFx1MDQ0MVxcdTA0NDJcXHUwNDNFXFx1MDQ0RlxcdTA0M0RcXHUwNDM4XFx1MDQzNSBcXHUwNDMyXFx1MDQzMFxcdTA0NDhcXHUwNDM1XFx1MDQzM1xcdTA0M0UgXFx1MDQ0MVxcdTA0NDdcXHUwNDUxXFx1MDQ0MlxcdTA0MzAgXFx1MDQzRFxcdTA0MzUgXFx1MDQzOFxcdTA0MzdcXHUwNDNDXFx1MDQzNVxcdTA0M0RcXHUwNDM4XFx1MDQ0MlxcdTA0NDFcXHUwNDRGLlwiXG4gIH1cbn07XG5jb25zdCB3YWxsZXRNb2RhbCA9IHtcbiAgbG9hZGluZzogXCJcXHUwNDIxXFx1MDQzRlxcdTA0MzhcXHUwNDQxXFx1MDQzRVxcdTA0M0EgXFx1MDQzQVxcdTA0M0VcXHUwNDQ4XFx1MDQzNVxcdTA0M0JcXHUwNDRDXFx1MDQzQVxcdTA0M0VcXHUwNDMyIFxcdTA0MzdcXHUwNDMwXFx1MDQzM1xcdTA0NDBcXHUwNDQzXFx1MDQzNlxcdTA0MzBcXHUwNDM1XFx1MDQ0MlxcdTA0NDFcXHUwNDRGXCIsXG4gIHFyQ29kZTogXCJRUi1cXHUwNDNBXFx1MDQzRVxcdTA0MzRcIixcbiAgd2FsbGV0czogXCJcXHUwNDFBXFx1MDQzRVxcdTA0NDhcXHUwNDM1XFx1MDQzQlxcdTA0NENcXHUwNDNBXFx1MDQzOFwiLFxuICB1bml2ZXJzYWxRUk1vZGFsOiB7XG4gICAgc2NhblFSOiBcIlxcdTA0MUVcXHUwNDQyXFx1MDQ0MVxcdTA0M0FcXHUwNDMwXFx1MDQzRFxcdTA0MzhcXHUwNDQwXFx1MDQ0M1xcdTA0MzlcXHUwNDQyXFx1MDQzNSBcXHUwNDNBXFx1MDQzRVxcdTA0MzQgXFx1MDQzRFxcdTA0MzhcXHUwNDM2XFx1MDQzNSBcXHUwNDQxXFx4QTBcXHUwNDNGXFx1MDQzRVxcdTA0M0NcXHUwNDNFXFx1MDQ0OVxcdTA0NENcXHUwNDRFIFxcdTA0M0FcXHUwNDMwXFx1MDQzQ1xcdTA0MzVcXHUwNDQwXFx1MDQ0QiBcXHUwNDMyIFxcdTA0MzJcXHUwNDMwXFx1MDQ0OFxcdTA0MzVcXHUwNDNDIFRPTi1cXHUwNDNBXFx1MDQzRVxcdTA0NDhcXHUwNDM1XFx1MDQzQlxcdTA0NENcXHUwNDNBXFx1MDQzNS5cIixcbiAgICBvcGVuV2FsbGV0OiBcIlxcdTA0MUVcXHUwNDQyXFx1MDQzQVxcdTA0NDBcXHUwNDRCXFx1MDQ0MlxcdTA0NEMgXFx1MDQzQVxcdTA0M0VcXHUwNDQ4XFx1MDQzNVxcdTA0M0JcXHUwNDUxXFx1MDQzQVwiLFxuICAgIG9wZW5JbnN0YWxsZWRXYWxsZXQ6IFwiXFx1MDQxRVxcdTA0NDJcXHUwNDNBXFx1MDQ0MFxcdTA0NEJcXHUwNDQyXFx1MDQ0QyBcXHUwNDNBXFx1MDQzRVxcdTA0NDhcXHUwNDM1XFx1MDQzQlxcdTA0NTFcXHUwNDNBXCIsXG4gICAgZG9udEhhdmU6IFwiXFx1MDQxRlxcdTA0M0VcXHUwNDM0XFx1MDQ0MFxcdTA0M0VcXHUwNDMxXFx1MDQzRFxcdTA0MzVcXHUwNDM1IFxcdTA0M0VcXHhBMFRPTlxceEEwXFx1MDQzQVxcdTA0M0VcXHUwNDQ4XFx1MDQzNVxcdTA0M0JcXHUwNDRDXFx1MDQzQVxcdTA0MzBcXHUwNDQ1XCJcbiAgfSxcbiAgZGVza3RvcFNlbGVjdFdhbGxldE1vZGFsOiB7XG4gICAgc2VsZWN0V2FsbGV0OiBcIlxcdTA0MTJcXHUwNDRCXFx1MDQzMVxcdTA0MzVcXHUwNDQwXFx1MDQzOFxcdTA0NDJcXHUwNDM1IFxcdTA0M0FcXHUwNDNFXFx1MDQ0OFxcdTA0MzVcXHUwNDNCXFx1MDQ1MVxcdTA0M0EgXFx1MDQzNFxcdTA0M0JcXHUwNDRGXFx4QTBcXHUwNDNGXFx1MDQzRVxcdTA0MzRcXHUwNDNBXFx1MDQzQlxcdTA0NEVcXHUwNDQ3XFx1MDQzNVxcdTA0M0RcXHUwNDM4XFx1MDQ0Ri5cIlxuICB9LFxuICBtb2JpbGVTZWxlY3RXYWxsZXRNb2RhbDoge1xuICAgIGNvbm5lY3RXYWxsZXQ6IFwiXFx1MDQxRlxcdTA0M0VcXHUwNDM0XFx1MDQzQVxcdTA0M0JcXHUwNDRFXFx1MDQ0N1xcdTA0MzhcXHUwNDQyXFx1MDQzNSBcXHUwNDNBXFx1MDQzRVxcdTA0NDhcXHUwNDM1XFx1MDQzQlxcdTA0NTFcXHUwNDNBXCIsXG4gICAgc2VsZWN0V2FsbGV0OiBcIiR3YWxsZXRNb2RhbC5kZXNrdG9wU2VsZWN0V2FsbGV0TW9kYWwuc2VsZWN0V2FsbGV0XCIsXG4gICAgaW5zdGFsbGVkV2FsbGV0OiBcIlxcdTA0MUVcXHUwNDQyXFx1MDQzQVxcdTA0NDBcXHUwNDRCXFx1MDQ0MlxcdTA0NEMgXFx1MDQzQVxcdTA0M0VcXHUwNDQ4XFx1MDQzNVxcdTA0M0JcXHUwNDUxXFx1MDQzQVwiXG4gIH0sXG4gIHFyQ29kZU1vZGFsOiB7XG4gICAgY29ubmVjdFdpdGg6IFwiXFx1MDQxRlxcdTA0M0VcXHUwNDM0XFx1MDQzQVxcdTA0M0JcXHUwNDRFXFx1MDQ0N1xcdTA0MzhcXHUwNDQyXFx1MDQ0Q1xcdTA0NDFcXHUwNDRGIFxcdTA0NDdcXHUwNDM1XFx1MDQ0MFxcdTA0MzVcXHUwNDM3XFx4QTB7eyBuYW1lIH19XCIsXG4gICAgc2NhbjogXCJcXHUwNDFFXFx1MDQ0MlxcdTA0NDFcXHUwNDNBXFx1MDQzMFxcdTA0M0RcXHUwNDM4XFx1MDQ0MFxcdTA0NDNcXHUwNDM5XFx1MDQ0MlxcdTA0MzUgXFx1MDQzQVxcdTA0M0VcXHUwNDM0IFxcdTA0M0RcXHUwNDM4XFx1MDQzNlxcdTA0MzUuXCIsXG4gICAgb3BlbldhbGxldDogXCJcXHUwNDFFXFx1MDQ0MlxcdTA0M0FcXHUwNDQwXFx1MDQ0QlxcdTA0NDJcXHUwNDRDIHt7IG5hbWUgfX1cIixcbiAgICBvcGVuRXh0ZW5zaW9uOiBcIlxcdTA0MjBcXHUwNDMwXFx1MDQ0MVxcdTA0NDhcXHUwNDM4XFx1MDQ0MFxcdTA0MzVcXHUwNDNEXFx1MDQzOFxcdTA0MzVcIixcbiAgICBkb250SGF2ZTogXCJcXHUwNDIzIFxcdTA0MzJcXHUwNDMwXFx1MDQ0MSBcXHUwNDNEXFx1MDQzNVxcdTA0NDIge3sgbmFtZSB9fT9cIlxuICB9XG59O1xuY29uc3QgYWN0aW9uTW9kYWwgPSB7XG4gIGNvbmZpcm1UcmFuc2FjdGlvbjoge1xuICAgIGhlYWRlcjogXCJcXHUwNDFGXFx1MDQzRVxcdTA0MzRcXHUwNDQyXFx1MDQzMlxcdTA0MzVcXHUwNDQwXFx1MDQzNFxcdTA0MzhcXHUwNDQyXFx1MDQzNSBcXHUwNDM0XFx1MDQzNVxcdTA0MzlcXHUwNDQxXFx1MDQ0MlxcdTA0MzJcXHUwNDM4XFx1MDQzNSBcXHUwNDMyXFx4QTB7eyBuYW1lIH19XCIsXG4gICAgdGV4dDogXCJcXHUwNDJEXFx1MDQ0MlxcdTA0M0UgXFx1MDQzN1xcdTA0MzBcXHUwNDM5XFx1MDQzQ1xcdTA0MzVcXHUwNDQyIFxcdTA0M0ZcXHUwNDMwXFx1MDQ0MFxcdTA0NDMgXFx1MDQ0MVxcdTA0MzVcXHUwNDNBXFx1MDQ0M1xcdTA0M0RcXHUwNDM0LlwiXG4gIH0sXG4gIHRyYW5zYWN0aW9uU2VudDogXCIkbm90aWZpY2F0aW9ucy50cmFuc2FjdGlvblNlbnRcIixcbiAgdHJhbnNhY3Rpb25DYW5jZWxlZDogXCIkbm90aWZpY2F0aW9ucy50cmFuc2FjdGlvbkNhbmNlbGVkXCJcbn07XG5jb25zdCBydSA9IHtcbiAgY29tbW9uLFxuICBidXR0b24sXG4gIG5vdGlmaWNhdGlvbnMsXG4gIHdhbGxldE1vZGFsLFxuICBhY3Rpb25Nb2RhbFxufTtcbmNvbnN0IGkxOG5EaWN0aW9uYXJ5ID0ge1xuICBlbjogcGFyc2VEaWN0aW9uYXJ5KGVuKSxcbiAgcnU6IHBhcnNlRGljdGlvbmFyeShydSlcbn07XG5mdW5jdGlvbiBwYXJzZURpY3Rpb25hcnkoZGljdGlvbmFyeSkge1xuICBjb25zdCByZWZTeW1ib2wgPSBcIiRcIjtcbiAgY29uc3QgaXRlcmF0ZSA9IChzdWJEaWN0aW9uYXJ5KSA9PiB7XG4gICAgT2JqZWN0LmVudHJpZXMoc3ViRGljdGlvbmFyeSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlKHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKHZhbHVlWzBdID09PSByZWZTeW1ib2wpIHtcbiAgICAgICAgICBjb25zdCBwYXRoID0gdmFsdWUuc2xpY2UoMSkuc3BsaXQoXCIuXCIpO1xuICAgICAgICAgIGxldCBvYmogPSBkaWN0aW9uYXJ5O1xuICAgICAgICAgIHBhdGguZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGl0ZW0gaW4gb2JqKSB7XG4gICAgICAgICAgICAgIG9iaiA9IG9ialtpdGVtXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBgQ2Fubm90IHBhcnNlIHRyYW5zbGF0aW9uczogdGhlcmUgaXMgbm8gcHJvcGVydHkgJHtpdGVtfSBpbiB0cmFuc2xhdGlvbmBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBzdWJEaWN0aW9uYXJ5W2tleV0gPSBvYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnNsaWNlKDAsIDIpID09PSBgXFxcXCR7cmVmU3ltYm9sfWApIHtcbiAgICAgICAgICBzdWJEaWN0aW9uYXJ5W2tleV0gPSB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBpdGVyYXRlKGRpY3Rpb25hcnkpO1xuICByZXR1cm4gZGljdGlvbmFyeTtcbn1cbmNvbnN0IENvbm5lY3RvckNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG5jb25zdCAkUkFXID0gU3ltYm9sKFwic3RvcmUtcmF3XCIpLCAkTk9ERSA9IFN5bWJvbChcInN0b3JlLW5vZGVcIiksICROQU1FID0gU3ltYm9sKFwic3RvcmUtbmFtZVwiKTtcbmZ1bmN0aW9uIHdyYXAkMSh2YWx1ZSwgbmFtZSkge1xuICBsZXQgcDIgPSB2YWx1ZVskUFJPWFldO1xuICBpZiAoIXAyKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbHVlLCAkUFJPWFksIHtcbiAgICAgIHZhbHVlOiBwMiA9IG5ldyBQcm94eSh2YWx1ZSwgcHJveHlUcmFwcyQxKVxuICAgIH0pO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSksIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh2YWx1ZSk7XG4gICAgICBmb3IgKGxldCBpMiA9IDAsIGwyID0ga2V5cy5sZW5ndGg7IGkyIDwgbDI7IGkyKyspIHtcbiAgICAgICAgY29uc3QgcHJvcCA9IGtleXNbaTJdO1xuICAgICAgICBpZiAoZGVzY1twcm9wXS5nZXQpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWUsIHByb3AsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGRlc2NbcHJvcF0uZW51bWVyYWJsZSxcbiAgICAgICAgICAgIGdldDogZGVzY1twcm9wXS5nZXQuYmluZChwMilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcDI7XG59XG5mdW5jdGlvbiBpc1dyYXBwYWJsZShvYmopIHtcbiAgbGV0IHByb3RvO1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiAmJiAob2JqWyRQUk9YWV0gfHwgIShwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopKSB8fCBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSB8fCBBcnJheS5pc0FycmF5KG9iaikpO1xufVxuZnVuY3Rpb24gdW53cmFwKGl0ZW0sIHNldCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpIHtcbiAgbGV0IHJlc3VsdCwgdW53cmFwcGVkLCB2LCBwcm9wO1xuICBpZiAocmVzdWx0ID0gaXRlbSAhPSBudWxsICYmIGl0ZW1bJFJBV10pXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgaWYgKCFpc1dyYXBwYWJsZShpdGVtKSB8fCBzZXQuaGFzKGl0ZW0pKVxuICAgIHJldHVybiBpdGVtO1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgIGlmIChPYmplY3QuaXNGcm96ZW4oaXRlbSkpXG4gICAgICBpdGVtID0gaXRlbS5zbGljZSgwKTtcbiAgICBlbHNlXG4gICAgICBzZXQuYWRkKGl0ZW0pO1xuICAgIGZvciAobGV0IGkyID0gMCwgbDIgPSBpdGVtLmxlbmd0aDsgaTIgPCBsMjsgaTIrKykge1xuICAgICAgdiA9IGl0ZW1baTJdO1xuICAgICAgaWYgKCh1bndyYXBwZWQgPSB1bndyYXAodiwgc2V0KSkgIT09IHYpXG4gICAgICAgIGl0ZW1baTJdID0gdW53cmFwcGVkO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoT2JqZWN0LmlzRnJvemVuKGl0ZW0pKVxuICAgICAgaXRlbSA9IE9iamVjdC5hc3NpZ24oe30sIGl0ZW0pO1xuICAgIGVsc2VcbiAgICAgIHNldC5hZGQoaXRlbSk7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGl0ZW0pLCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoaXRlbSk7XG4gICAgZm9yIChsZXQgaTIgPSAwLCBsMiA9IGtleXMubGVuZ3RoOyBpMiA8IGwyOyBpMisrKSB7XG4gICAgICBwcm9wID0ga2V5c1tpMl07XG4gICAgICBpZiAoZGVzY1twcm9wXS5nZXQpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdiA9IGl0ZW1bcHJvcF07XG4gICAgICBpZiAoKHVud3JhcHBlZCA9IHVud3JhcCh2LCBzZXQpKSAhPT0gdilcbiAgICAgICAgaXRlbVtwcm9wXSA9IHVud3JhcHBlZDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGl0ZW07XG59XG5mdW5jdGlvbiBnZXREYXRhTm9kZXModGFyZ2V0KSB7XG4gIGxldCBub2RlcyA9IHRhcmdldFskTk9ERV07XG4gIGlmICghbm9kZXMpXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgJE5PREUsIHtcbiAgICAgIHZhbHVlOiBub2RlcyA9IHt9XG4gICAgfSk7XG4gIHJldHVybiBub2Rlcztcbn1cbmZ1bmN0aW9uIGdldERhdGFOb2RlKG5vZGVzLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgcmV0dXJuIG5vZGVzW3Byb3BlcnR5XSB8fCAobm9kZXNbcHJvcGVydHldID0gY3JlYXRlRGF0YU5vZGUodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHByb3h5RGVzY3JpcHRvciQxKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgY29uc3QgZGVzYyA9IFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHkpO1xuICBpZiAoIWRlc2MgfHwgZGVzYy5nZXQgfHwgIWRlc2MuY29uZmlndXJhYmxlIHx8IHByb3BlcnR5ID09PSAkUFJPWFkgfHwgcHJvcGVydHkgPT09ICROT0RFIHx8IHByb3BlcnR5ID09PSAkTkFNRSlcbiAgICByZXR1cm4gZGVzYztcbiAgZGVsZXRlIGRlc2MudmFsdWU7XG4gIGRlbGV0ZSBkZXNjLndyaXRhYmxlO1xuICBkZXNjLmdldCA9ICgpID0+IHRhcmdldFskUFJPWFldW3Byb3BlcnR5XTtcbiAgcmV0dXJuIGRlc2M7XG59XG5mdW5jdGlvbiB0cmFja1NlbGYodGFyZ2V0KSB7XG4gIGlmIChnZXRMaXN0ZW5lcigpKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBnZXREYXRhTm9kZXModGFyZ2V0KTtcbiAgICAobm9kZXMuXyB8fCAobm9kZXMuXyA9IGNyZWF0ZURhdGFOb2RlKCkpKSgpO1xuICB9XG59XG5mdW5jdGlvbiBvd25LZXlzKHRhcmdldCkge1xuICB0cmFja1NlbGYodGFyZ2V0KTtcbiAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xufVxuZnVuY3Rpb24gY3JlYXRlRGF0YU5vZGUodmFsdWUpIHtcbiAgY29uc3QgW3MyLCBzZXRdID0gY3JlYXRlU2lnbmFsKHZhbHVlLCB7XG4gICAgZXF1YWxzOiBmYWxzZSxcbiAgICBpbnRlcm5hbDogdHJ1ZVxuICB9KTtcbiAgczIuJCA9IHNldDtcbiAgcmV0dXJuIHMyO1xufVxuY29uc3QgcHJveHlUcmFwcyQxID0ge1xuICBnZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICRSQVcpXG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJFBST1hZKVxuICAgICAgcmV0dXJuIHJlY2VpdmVyO1xuICAgIGlmIChwcm9wZXJ0eSA9PT0gJFRSQUNLKSB7XG4gICAgICB0cmFja1NlbGYodGFyZ2V0KTtcbiAgICAgIHJldHVybiByZWNlaXZlcjtcbiAgICB9XG4gICAgY29uc3Qgbm9kZXMgPSBnZXREYXRhTm9kZXModGFyZ2V0KTtcbiAgICBjb25zdCB0cmFja2VkID0gbm9kZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHkpO1xuICAgIGxldCB2YWx1ZSA9IHRyYWNrZWQgPyBub2Rlc1twcm9wZXJ0eV0oKSA6IHRhcmdldFtwcm9wZXJ0eV07XG4gICAgaWYgKHByb3BlcnR5ID09PSAkTk9ERSB8fCBwcm9wZXJ0eSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICBpZiAoIXRyYWNrZWQpIHtcbiAgICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKGdldExpc3RlbmVyKCkgJiYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJmdW5jdGlvblwiIHx8IHRhcmdldC5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkpICYmICEoZGVzYyAmJiBkZXNjLmdldCkpXG4gICAgICAgIHZhbHVlID0gZ2V0RGF0YU5vZGUobm9kZXMsIHByb3BlcnR5LCB2YWx1ZSkoKTtcbiAgICB9XG4gICAgcmV0dXJuIGlzV3JhcHBhYmxlKHZhbHVlKSA/IHdyYXAkMSh2YWx1ZSkgOiB2YWx1ZTtcbiAgfSxcbiAgaGFzKHRhcmdldCwgcHJvcGVydHkpIHtcbiAgICBpZiAocHJvcGVydHkgPT09ICRSQVcgfHwgcHJvcGVydHkgPT09ICRQUk9YWSB8fCBwcm9wZXJ0eSA9PT0gJFRSQUNLIHx8IHByb3BlcnR5ID09PSAkTk9ERSB8fCBwcm9wZXJ0eSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIHRoaXMuZ2V0KHRhcmdldCwgcHJvcGVydHksIHRhcmdldCk7XG4gICAgcmV0dXJuIHByb3BlcnR5IGluIHRhcmdldDtcbiAgfSxcbiAgc2V0KCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9LFxuICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcbiAgb3duS2V5cyxcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiBwcm94eURlc2NyaXB0b3IkMVxufTtcbmZ1bmN0aW9uIHNldFByb3BlcnR5KHN0YXRlLCBwcm9wZXJ0eSwgdmFsdWUsIGRlbGV0aW5nID0gZmFsc2UpIHtcbiAgaWYgKCFkZWxldGluZyAmJiBzdGF0ZVtwcm9wZXJ0eV0gPT09IHZhbHVlKVxuICAgIHJldHVybjtcbiAgY29uc3QgcHJldiA9IHN0YXRlW3Byb3BlcnR5XSwgbGVuID0gc3RhdGUubGVuZ3RoO1xuICBpZiAodmFsdWUgPT09IHZvaWQgMClcbiAgICBkZWxldGUgc3RhdGVbcHJvcGVydHldO1xuICBlbHNlXG4gICAgc3RhdGVbcHJvcGVydHldID0gdmFsdWU7XG4gIGxldCBub2RlcyA9IGdldERhdGFOb2RlcyhzdGF0ZSksIG5vZGU7XG4gIGlmIChub2RlID0gZ2V0RGF0YU5vZGUobm9kZXMsIHByb3BlcnR5LCBwcmV2KSlcbiAgICBub2RlLiQoKCkgPT4gdmFsdWUpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdGF0ZSkgJiYgc3RhdGUubGVuZ3RoICE9PSBsZW4pXG4gICAgKG5vZGUgPSBnZXREYXRhTm9kZShub2RlcywgXCJsZW5ndGhcIiwgbGVuKSkgJiYgbm9kZS4kKHN0YXRlLmxlbmd0aCk7XG4gIChub2RlID0gbm9kZXMuXykgJiYgbm9kZS4kKCk7XG59XG5mdW5jdGlvbiBtZXJnZVN0b3JlTm9kZShzdGF0ZSwgdmFsdWUpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHZhbHVlKTtcbiAgZm9yIChsZXQgaTIgPSAwOyBpMiA8IGtleXMubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgY29uc3Qga2V5ID0ga2V5c1tpMl07XG4gICAgc2V0UHJvcGVydHkoc3RhdGUsIGtleSwgdmFsdWVba2V5XSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUFycmF5KGN1cnJlbnQsIG5leHQpIHtcbiAgaWYgKHR5cGVvZiBuZXh0ID09PSBcImZ1bmN0aW9uXCIpXG4gICAgbmV4dCA9IG5leHQoY3VycmVudCk7XG4gIG5leHQgPSB1bndyYXAobmV4dCk7XG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG5leHQpXG4gICAgICByZXR1cm47XG4gICAgbGV0IGkyID0gMCwgbGVuID0gbmV4dC5sZW5ndGg7XG4gICAgZm9yICg7IGkyIDwgbGVuOyBpMisrKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IG5leHRbaTJdO1xuICAgICAgaWYgKGN1cnJlbnRbaTJdICE9PSB2YWx1ZSlcbiAgICAgICAgc2V0UHJvcGVydHkoY3VycmVudCwgaTIsIHZhbHVlKTtcbiAgICB9XG4gICAgc2V0UHJvcGVydHkoY3VycmVudCwgXCJsZW5ndGhcIiwgbGVuKTtcbiAgfSBlbHNlXG4gICAgbWVyZ2VTdG9yZU5vZGUoY3VycmVudCwgbmV4dCk7XG59XG5mdW5jdGlvbiB1cGRhdGVQYXRoKGN1cnJlbnQsIHBhdGgsIHRyYXZlcnNlZCA9IFtdKSB7XG4gIGxldCBwYXJ0LCBwcmV2ID0gY3VycmVudDtcbiAgaWYgKHBhdGgubGVuZ3RoID4gMSkge1xuICAgIHBhcnQgPSBwYXRoLnNoaWZ0KCk7XG4gICAgY29uc3QgcGFydFR5cGUgPSB0eXBlb2YgcGFydCwgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocGFydCkpIHtcbiAgICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBwYXJ0Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICB1cGRhdGVQYXRoKGN1cnJlbnQsIFtwYXJ0W2kyXV0uY29uY2F0KHBhdGgpLCB0cmF2ZXJzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSAmJiBwYXJ0VHlwZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBmb3IgKGxldCBpMiA9IDA7IGkyIDwgY3VycmVudC5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgaWYgKHBhcnQoY3VycmVudFtpMl0sIGkyKSlcbiAgICAgICAgICB1cGRhdGVQYXRoKGN1cnJlbnQsIFtpMl0uY29uY2F0KHBhdGgpLCB0cmF2ZXJzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheSAmJiBwYXJ0VHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qge1xuICAgICAgICBmcm9tID0gMCxcbiAgICAgICAgdG8gPSBjdXJyZW50Lmxlbmd0aCAtIDEsXG4gICAgICAgIGJ5ID0gMVxuICAgICAgfSA9IHBhcnQ7XG4gICAgICBmb3IgKGxldCBpMiA9IGZyb207IGkyIDw9IHRvOyBpMiArPSBieSkge1xuICAgICAgICB1cGRhdGVQYXRoKGN1cnJlbnQsIFtpMl0uY29uY2F0KHBhdGgpLCB0cmF2ZXJzZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAocGF0aC5sZW5ndGggPiAxKSB7XG4gICAgICB1cGRhdGVQYXRoKGN1cnJlbnRbcGFydF0sIHBhdGgsIFtwYXJ0XS5jb25jYXQodHJhdmVyc2VkKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHByZXYgPSBjdXJyZW50W3BhcnRdO1xuICAgIHRyYXZlcnNlZCA9IFtwYXJ0XS5jb25jYXQodHJhdmVyc2VkKTtcbiAgfVxuICBsZXQgdmFsdWUgPSBwYXRoWzBdO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICB2YWx1ZSA9IHZhbHVlKHByZXYsIHRyYXZlcnNlZCk7XG4gICAgaWYgKHZhbHVlID09PSBwcmV2KVxuICAgICAgcmV0dXJuO1xuICB9XG4gIGlmIChwYXJ0ID09PSB2b2lkIDAgJiYgdmFsdWUgPT0gdm9pZCAwKVxuICAgIHJldHVybjtcbiAgdmFsdWUgPSB1bndyYXAodmFsdWUpO1xuICBpZiAocGFydCA9PT0gdm9pZCAwIHx8IGlzV3JhcHBhYmxlKHByZXYpICYmIGlzV3JhcHBhYmxlKHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBtZXJnZVN0b3JlTm9kZShwcmV2LCB2YWx1ZSk7XG4gIH0gZWxzZVxuICAgIHNldFByb3BlcnR5KGN1cnJlbnQsIHBhcnQsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKC4uLltzdG9yZSwgb3B0aW9uc10pIHtcbiAgY29uc3QgdW53cmFwcGVkU3RvcmUgPSB1bndyYXAoc3RvcmUgfHwge30pO1xuICBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh1bndyYXBwZWRTdG9yZSk7XG4gIGNvbnN0IHdyYXBwZWRTdG9yZSA9IHdyYXAkMSh1bndyYXBwZWRTdG9yZSk7XG4gIGZ1bmN0aW9uIHNldFN0b3JlKC4uLmFyZ3MpIHtcbiAgICBiYXRjaCgoKSA9PiB7XG4gICAgICBpc0FycmF5ICYmIGFyZ3MubGVuZ3RoID09PSAxID8gdXBkYXRlQXJyYXkodW53cmFwcGVkU3RvcmUsIGFyZ3NbMF0pIDogdXBkYXRlUGF0aCh1bndyYXBwZWRTdG9yZSwgYXJncyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIFt3cmFwcGVkU3RvcmUsIHNldFN0b3JlXTtcbn1cbnZhciBUSEVNRSA9IC8qIEBfX1BVUkVfXyAqLyAoKFRIRU1FMikgPT4ge1xuICBUSEVNRTJbXCJEQVJLXCJdID0gXCJEQVJLXCI7XG4gIFRIRU1FMltcIkxJR0hUXCJdID0gXCJMSUdIVFwiO1xuICByZXR1cm4gVEhFTUUyO1xufSkoVEhFTUUgfHwge30pO1xuY29uc3QgZGVmYXVsdExpZ2h0Q29sb3JzU2V0ID0ge1xuICBjb25zdGFudDoge1xuICAgIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgICB3aGl0ZTogXCIjRkZGRkZGXCJcbiAgfSxcbiAgY29ubmVjdEJ1dHRvbjoge1xuICAgIGJhY2tncm91bmQ6IFwiIzMxQTZGNVwiLFxuICAgIGZvcmVncm91bmQ6IFwiI0ZGRkZGRlwiXG4gIH0sXG4gIGFjY2VudDogXCIjMzFBNkY1XCIsXG4gIGljb246IHtcbiAgICBwcmltYXJ5OiBcIiMwRjBGMEZcIixcbiAgICBzZWNvbmRhcnk6IFwiIzdBODk5OVwiLFxuICAgIHRlcnRpYXJ5OiBcIiNDMUNBRDJcIixcbiAgICBzdWNjZXNzOiBcIiMyOUNDNkFcIixcbiAgICBlcnJvcjogXCIjRjVBNzNCXCJcbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIHByaW1hcnk6IFwiI0ZGRkZGRlwiLFxuICAgIHNlY29uZGFyeTogXCIjRjFGM0Y1XCIsXG4gICAgc2VnbWVudDogXCIjRkZGRkZGXCJcbiAgfSxcbiAgdGV4dDoge1xuICAgIHByaW1hcnk6IFwiIzBGMEYwRlwiLFxuICAgIHNlY29uZGFyeTogXCIjNkE3Nzg1XCJcbiAgfVxufTtcbmNvbnN0IGRlZmF1bHREYXJrQ29sb3JzU2V0ID0ge1xuICBjb25zdGFudDoge1xuICAgIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgICB3aGl0ZTogXCIjRkZGRkZGXCJcbiAgfSxcbiAgY29ubmVjdEJ1dHRvbjoge1xuICAgIGJhY2tncm91bmQ6IFwiIzMxQTZGNVwiLFxuICAgIGZvcmVncm91bmQ6IFwiI0ZGRkZGRlwiXG4gIH0sXG4gIGFjY2VudDogXCIjRTVFNUVBXCIsXG4gIGljb246IHtcbiAgICBwcmltYXJ5OiBcIiNFNUU1RUFcIixcbiAgICBzZWNvbmRhcnk6IFwiIzkwOTA5OVwiLFxuICAgIHRlcnRpYXJ5OiBcIiM0MzQzNDdcIixcbiAgICBzdWNjZXNzOiBcIiMyOUNDNkFcIixcbiAgICBlcnJvcjogXCIjRjVBNzNCXCJcbiAgfSxcbiAgYmFja2dyb3VuZDoge1xuICAgIHByaW1hcnk6IFwiIzEyMTIxNFwiLFxuICAgIHNlY29uZGFyeTogXCIjMTgxODFBXCIsXG4gICAgc2VnbWVudDogXCIjMjYyNjI5XCJcbiAgfSxcbiAgdGV4dDoge1xuICAgIHByaW1hcnk6IFwiI0U1RTVFQVwiLFxuICAgIHNlY29uZGFyeTogXCIjN0Q3RDg1XCJcbiAgfVxufTtcbi8qIVxuICogaXMtcGxhaW4tb2JqZWN0IDxodHRwczovL2dpdGh1Yi5jb20vam9uc2NobGlua2VydC9pcy1wbGFpbi1vYmplY3Q+XG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTcsIEpvbiBTY2hsaW5rZXJ0LlxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG5mdW5jdGlvbiBpc09iamVjdChvMikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8yKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIjtcbn1cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QobzIpIHtcbiAgdmFyIGN0b3IsIHByb3Q7XG4gIGlmIChpc09iamVjdChvMikgPT09IGZhbHNlKVxuICAgIHJldHVybiBmYWxzZTtcbiAgY3RvciA9IG8yLmNvbnN0cnVjdG9yO1xuICBpZiAoY3RvciA9PT0gdm9pZCAwKVxuICAgIHJldHVybiB0cnVlO1xuICBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gIGlmIChpc09iamVjdChwcm90KSA9PT0gZmFsc2UpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocHJvdC5oYXNPd25Qcm9wZXJ0eShcImlzUHJvdG90eXBlT2ZcIikgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gbWVyZ2VPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRPcHRpb25zKSB7XG4gIGlmICghb3B0aW9ucykge1xuICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgfVxuICBjb25zdCBvdmVyd3JpdGVNZXJnZSA9IChfLCBzb3VyY2VBcnJheSwgX18pID0+IHNvdXJjZUFycmF5O1xuICByZXR1cm4gZGVlcG1lcmdlKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zLCB7XG4gICAgYXJyYXlNZXJnZTogb3ZlcndyaXRlTWVyZ2UsXG4gICAgaXNNZXJnZWFibGVPYmplY3Q6IGlzUGxhaW5PYmplY3RcbiAgfSk7XG59XG5jb25zdCBbdGhlbWVTdGF0ZSwgc2V0VGhlbWVTdGF0ZV0gPSBjcmVhdGVTdG9yZSh7XG4gIHRoZW1lOiBUSEVNRS5MSUdIVCxcbiAgY29sb3JzOiBkZWZhdWx0TGlnaHRDb2xvcnNTZXQsXG4gIGJvcmRlclJhZGl1czogXCJtXCJcbn0pO1xuY29uc3QgdGhlbWVDb2xvcnNNYXBwaW5nRGVmYXVsdCA9IHtcbiAgW1RIRU1FLkxJR0hUXTogZGVmYXVsdExpZ2h0Q29sb3JzU2V0LFxuICBbVEhFTUUuREFSS106IGRlZmF1bHREYXJrQ29sb3JzU2V0XG59O1xuY29uc3QgdGhlbWVDdXN0b21Db2xvcnMgPSB7XG4gIFtUSEVNRS5MSUdIVF06IHZvaWQgMCxcbiAgW1RIRU1FLkRBUktdOiB2b2lkIDBcbn07XG5mdW5jdGlvbiBzZXRUaGVtZSh0aGVtZSwgY29sb3JzU2V0KSB7XG4gIGlmIChjb2xvcnNTZXQpIHtcbiAgICB0aGVtZUN1c3RvbUNvbG9yc1tUSEVNRS5EQVJLXSA9IG1lcmdlT3B0aW9ucyhcbiAgICAgIGNvbG9yc1NldFtUSEVNRS5EQVJLXSxcbiAgICAgIHRoZW1lQ3VzdG9tQ29sb3JzW1RIRU1FLkRBUktdXG4gICAgKTtcbiAgICB0aGVtZUN1c3RvbUNvbG9yc1tUSEVNRS5MSUdIVF0gPSBtZXJnZU9wdGlvbnMoXG4gICAgICBjb2xvcnNTZXRbVEhFTUUuTElHSFRdLFxuICAgICAgdGhlbWVDdXN0b21Db2xvcnNbVEhFTUUuTElHSFRdXG4gICAgKTtcbiAgfVxuICBzZXRUaGVtZVN0YXRlKHtcbiAgICB0aGVtZSxcbiAgICBjb2xvcnM6IG1lcmdlT3B0aW9ucyh0aGVtZUN1c3RvbUNvbG9yc1t0aGVtZV0sIHRoZW1lQ29sb3JzTWFwcGluZ0RlZmF1bHRbdGhlbWVdKVxuICB9KTtcbn1cbmZ1bmN0aW9uIHNldEJvcmRlclJhZGl1cyhib3JkZXJSYWRpdXMpIHtcbiAgc2V0VGhlbWVTdGF0ZSh7IGJvcmRlclJhZGl1cyB9KTtcbn1cbmZ1bmN0aW9uIHNldENvbG9ycyhjb2xvcnNTZXQpIHtcbiAgdGhlbWVDdXN0b21Db2xvcnNbVEhFTUUuREFSS10gPSBtZXJnZU9wdGlvbnMoXG4gICAgY29sb3JzU2V0W1RIRU1FLkRBUktdLFxuICAgIHRoZW1lQ3VzdG9tQ29sb3JzW1RIRU1FLkRBUktdXG4gICk7XG4gIHRoZW1lQ3VzdG9tQ29sb3JzW1RIRU1FLkxJR0hUXSA9IG1lcmdlT3B0aW9ucyhcbiAgICBjb2xvcnNTZXRbVEhFTUUuTElHSFRdLFxuICAgIHRoZW1lQ3VzdG9tQ29sb3JzW1RIRU1FLkxJR0hUXVxuICApO1xuICBzZXRUaGVtZVN0YXRlKChzdGF0ZSkgPT4gKHtcbiAgICBjb2xvcnM6IG1lcmdlT3B0aW9ucyhcbiAgICAgIHRoZW1lQ3VzdG9tQ29sb3JzW3N0YXRlLnRoZW1lXSxcbiAgICAgIHRoZW1lQ29sb3JzTWFwcGluZ0RlZmF1bHRbc3RhdGUudGhlbWVdXG4gICAgKVxuICB9KSk7XG59XG5jb25zdCBnbG9iYWxTdHlsZXNUYWcgPSBcInRjLXJvb3RcIjtcbmNvbnN0IGRpc2FibGVTY3JvbGxDbGFzcyA9IFwidGMtZGlzYWJsZS1zY3JvbGxcIjtcbmNvbnN0IHVzaW5nTW91c2VDbGFzcyA9IFwidGMtdXNpbmctbW91c2VcIjtcbmNvbnN0IEdsb2JhbFN0eWxlcyA9ICgpID0+IHtcbiAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsICgpID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCh1c2luZ01vdXNlQ2xhc3MpKTtcbiAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUodXNpbmdNb3VzZUNsYXNzKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBTdHlsZXMgPSBjcmVhdGVHbG9iYWxTdHlsZXNgXG4gICAgJHtnbG9iYWxTdHlsZXNUYWd9ICoge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIFxuICAgICAgICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnUm9ib3RvJywgJ0hlbHZldGljYSBOZXVlJywgQXJpYWwsIFRhaG9tYSwgVmVyZGFuYSwgc2Fucy1zZXJpZjtcbiAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gICAgICAgIC1tb3otb3N4LWZvbnQtc21vb3RoaW5nOiBncmF5c2NhbGU7ICAgICAgICBcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICB9XG4gICAgXG4gICAgJHtnbG9iYWxTdHlsZXNUYWd9IGltZyB7XG4gICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xuICAgIH0gICBcbiBcbiAgICAke2dsb2JhbFN0eWxlc1RhZ30gKjpmb2N1cyB7XG4gICAgICAgIG91dGxpbmU6ICMwOGYgYXV0byAycHg7XG4gICAgfVxuICAgIFxuICAgICR7Z2xvYmFsU3R5bGVzVGFnfSBsaSB7XG4gICAgICAgIGxpc3Qtc3R5bGU6IG5vbmU7XG4gICAgfVxuICAgIFxuICAgICR7Z2xvYmFsU3R5bGVzVGFnfSBidXR0b24ge1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgIH1cbiAgICBcbiAgICBib2R5LiR7ZGlzYWJsZVNjcm9sbENsYXNzfSB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDsgXG4gICAgICAgIG92ZXJmbG93LXk6IHNjcm9sbDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgfVxuICAgIFxuICAgIGJvZHkuJHt1c2luZ01vdXNlQ2xhc3N9ICR7Z2xvYmFsU3R5bGVzVGFnfSAqOmZvY3VzIHtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICB9XG5gO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN0eWxlcywge30pO1xufTtcbmNvbnN0IEltYWdlUGxhY2Vob2xkZXIgPSBzdHlsZWQuZGl2YFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnl9O1xuYDtcbmNvbnN0IEltYWdlID0gKHByb3BzKSA9PiB7XG4gIGxldCBpbWdSZWY7XG4gIGNvbnN0IFtpbWFnZSwgc2V0SW1hZ2VdID0gY3JlYXRlU2lnbmFsKG51bGwpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGltZyA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICBpbWcuc3JjID0gcHJvcHMuc3JjO1xuICAgIGltZy5hbHQgPSBwcm9wcy5hbHQgfHwgXCJcIjtcbiAgICBpbWcuc2V0QXR0cmlidXRlKFwiZHJhZ2dhYmxlXCIsIFwiZmFsc2VcIik7XG4gICAgaWYgKHByb3BzLmNsYXNzKSB7XG4gICAgICBpbWcuY2xhc3NMaXN0LmFkZChwcm9wcy5jbGFzcyk7XG4gICAgfVxuICAgIGlmIChpbWcuY29tcGxldGUpIHtcbiAgICAgIHJldHVybiBzZXRJbWFnZShpbWcpO1xuICAgIH1cbiAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgKCkgPT4gc2V0SW1hZ2UoaW1nKSk7XG4gICAgcmV0dXJuICgpID0+IGltZy5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCAoKSA9PiBzZXRJbWFnZShpbWcpKTtcbiAgfSk7XG4gIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICBnZXQgd2hlbigpIHtcbiAgICAgIHJldHVybiBpbWFnZSgpO1xuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGltYWdlKCk7XG4gICAgfVxuICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICBnZXQgd2hlbigpIHtcbiAgICAgIHJldHVybiAhaW1hZ2UoKTtcbiAgICB9LFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoSW1hZ2VQbGFjZWhvbGRlciwge1xuICAgICAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgICAgICB9LFxuICAgICAgICByZWYociQpIHtcbiAgICAgICAgICBjb25zdCBfcmVmJCA9IGltZ1JlZjtcbiAgICAgICAgICB0eXBlb2YgX3JlZiQgPT09IFwiZnVuY3Rpb25cIiA/IF9yZWYkKHIkKSA6IGltZ1JlZiA9IHIkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pXTtcbn07XG5mdW5jdGlvbiBoZXhUb1JnYihoZXgpIHtcbiAgaWYgKGhleFswXSA9PT0gXCIjXCIpIHtcbiAgICBoZXggPSBoZXguc2xpY2UoMSk7XG4gIH1cbiAgY29uc3QgYmlnaW50ID0gcGFyc2VJbnQoaGV4LCAxNik7XG4gIGNvbnN0IHIgPSBiaWdpbnQgPj4gMTYgJiAyNTU7XG4gIGNvbnN0IGcgPSBiaWdpbnQgPj4gOCAmIDI1NTtcbiAgY29uc3QgYiA9IGJpZ2ludCAmIDI1NTtcbiAgcmV0dXJuIFtyLCBnLCBiXS5qb2luKFwiLFwiKTtcbn1cbmZ1bmN0aW9uIHJnYmEoY29sb3IsIG9wYWNpdHkpIHtcbiAgaWYgKGNvbG9yWzBdID09PSBcIiNcIikge1xuICAgIGNvbG9yID0gaGV4VG9SZ2IoY29sb3IpO1xuICB9XG4gIHJldHVybiBgcmdiYSgke2NvbG9yfSwgJHtvcGFjaXR5fSlgO1xufVxuZnVuY3Rpb24gdG9QeCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIFwicHhcIjtcbn1cbmNsYXNzIFRvbkNvbm5lY3RVSUVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBUb25Db25uZWN0VUlFcnJvci5wcm90b3R5cGUpO1xuICB9XG59XG5mdW5jdGlvbiBvcGVuTGluayhocmVmLCB0YXJnZXQgPSBcIl9zZWxmXCIpIHtcbiAgcmV0dXJuIHdpbmRvdy5vcGVuKGhyZWYsIHRhcmdldCwgXCJub3JlZmVycmVyIG5vb3BlbmVyXCIpO1xufVxuZnVuY3Rpb24gb3BlbkxpbmtCbGFuayhocmVmKSB7XG4gIG9wZW5MaW5rKGhyZWYsIFwiX2JsYW5rXCIpO1xufVxuZnVuY3Rpb24gZ2V0U3lzdGVtVGhlbWUoKSB7XG4gIGlmICh3aW5kb3cubWF0Y2hNZWRpYSAmJiB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogbGlnaHQpXCIpLm1hdGNoZXMpIHtcbiAgICByZXR1cm4gVEhFTUUuTElHSFQ7XG4gIH1cbiAgcmV0dXJuIFRIRU1FLkRBUks7XG59XG5mdW5jdGlvbiBzdWJzY3JpYmVUb1RoZW1lQ2hhbmdlKGNhbGxiYWNrKSB7XG4gIGNvbnN0IGhhbmRsZXIgPSAoZXZlbnQpID0+IGNhbGxiYWNrKGV2ZW50Lm1hdGNoZXMgPyBUSEVNRS5EQVJLIDogVEhFTUUuTElHSFQpO1xuICB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyaylcIikuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBoYW5kbGVyKTtcbiAgcmV0dXJuICgpID0+IHdpbmRvdy5tYXRjaE1lZGlhKFwiKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKVwiKS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGhhbmRsZXIpO1xufVxuZnVuY3Rpb24gYWRkUXVlcnlQYXJhbWV0ZXIodXJsLCBrZXksIHZhbHVlKSB7XG4gIGNvbnN0IHBhcnNlZCA9IG5ldyBVUkwodXJsKTtcbiAgcGFyc2VkLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gIHJldHVybiBwYXJzZWQudG9TdHJpbmcoKTtcbn1cbmZ1bmN0aW9uIGFkZFJldHVyblN0cmF0ZWd5KHVybCwgcmV0dXJuU3RyYXRlZ3kpIHtcbiAgcmV0dXJuIGFkZFF1ZXJ5UGFyYW1ldGVyKHVybCwgXCJyZXRcIiwgcmV0dXJuU3RyYXRlZ3kpO1xufVxuZnVuY3Rpb24gZGlzYWJsZVNjcm9sbCgpIHtcbiAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSB0b1B4KC1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wKTtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGRpc2FibGVTY3JvbGxDbGFzcyk7XG59XG5mdW5jdGlvbiBlbmFibGVTY3JvbGwoKSB7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShkaXNhYmxlU2Nyb2xsQ2xhc3MpO1xuICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG8oeyB0b3A6IC1wYXJzZUZsb2F0KGdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQuYm9keSkudG9wKSB9KTtcbiAgZG9jdW1lbnQuYm9keS5zdHlsZS50b3AgPSBcImF1dG9cIjtcbn1cbmZ1bmN0aW9uIGZpeE1vYmlsZVNhZmFyaUFjdGl2ZVRyYW5zaXRpb24oKSB7XG4gIGlmICghZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoXCJvbnRvdWNoc3RhcnRcIikpIHtcbiAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZShcIm9udG91Y2hzdGFydFwiLCBcIlwiKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVmaW5lU3R5bGVzUm9vdCgpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKGdsb2JhbFN0eWxlc1RhZywgY2xhc3MgVGNSb290RWxlbWVudCBleHRlbmRzIEhUTUxEaXZFbGVtZW50IHtcbiAgfSwge1xuICAgIGV4dGVuZHM6IFwiZGl2XCJcbiAgfSk7XG59XG5mdW5jdGlvbiBwcmVsb2FkSW1hZ2VzKGltYWdlcykge1xuICBpbWFnZXMuZm9yRWFjaCgoaW1nKSA9PiB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyB3aW5kb3cuSW1hZ2UoKTtcbiAgICBub2RlLnNyYyA9IGltZztcbiAgfSk7XG59XG5mdW5jdGlvbiBjaGVja0xvY2FsU3RvcmFnZUV4aXN0cygpIHtcbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXG4gICAgICBcIndpbmRvdy5sb2NhbFN0b3JhZ2UgaXMgdW5kZWZpbmVkLiBsb2NhbFN0b3JhZ2UgaXMgcmVxdWlyZWQgZm9yIFRvbkNvbm5lY3RVSVwiXG4gICAgKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0V2luZG93JDEoKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHdpbmRvdztcbiAgfVxuICByZXR1cm4gdm9pZCAwO1xufVxuZnVuY3Rpb24gaXNNb2JpbGVVc2VyQWdlbnQoKSB7XG4gIGxldCBjaGVjayA9IGZhbHNlO1xuICAoZnVuY3Rpb24oYTIpIHtcbiAgICBpZiAoLyhhbmRyb2lkfGJiXFxkK3xtZWVnbykuK21vYmlsZXxhdmFudGdvfGJhZGFcXC98YmxhY2tiZXJyeXxibGF6ZXJ8Y29tcGFsfGVsYWluZXxmZW5uZWN8aGlwdG9wfGllbW9iaWxlfGlwKGhvbmV8b2QpfGlyaXN8a2luZGxlfGxnZSB8bWFlbW98bWlkcHxtbXB8bW9iaWxlLitmaXJlZm94fG5ldGZyb250fG9wZXJhIG0ob2J8aW4paXxwYWxtKCBvcyk/fHBob25lfHAoaXhpfHJlKVxcL3xwbHVja2VyfHBvY2tldHxwc3B8c2VyaWVzKDR8NikwfHN5bWJpYW58dHJlb3x1cFxcLihicm93c2VyfGxpbmspfHZvZGFmb25lfHdhcHx3aW5kb3dzIGNlfHhkYXx4aWluby9pLnRlc3QoXG4gICAgICBhMlxuICAgICkgfHwgLzEyMDd8NjMxMHw2NTkwfDNnc298NHRocHw1MFsxLTZdaXw3NzBzfDgwMnN8YSB3YXxhYmFjfGFjKGVyfG9vfHNcXC0pfGFpKGtvfHJuKXxhbChhdnxjYXxjbyl8YW1vaXxhbihleHxueXx5dyl8YXB0dXxhcihjaHxnbyl8YXModGV8dXMpfGF0dHd8YXUoZGl8XFwtbXxyIHxzICl8YXZhbnxiZShja3xsbHxucSl8YmkobGJ8cmQpfGJsKGFjfGF6KXxicihlfHYpd3xidW1ifGJ3XFwtKG58dSl8YzU1XFwvfGNhcGl8Y2N3YXxjZG1cXC18Y2VsbHxjaHRtfGNsZGN8Y21kXFwtfGNvKG1wfG5kKXxjcmF3fGRhKGl0fGxsfG5nKXxkYnRlfGRjXFwtc3xkZXZpfGRpY2F8ZG1vYnxkbyhjfHApb3xkcygxMnxcXC1kKXxlbCg0OXxhaSl8ZW0obDJ8dWwpfGVyKGljfGswKXxlc2w4fGV6KFs0LTddMHxvc3x3YXx6ZSl8ZmV0Y3xmbHkoXFwtfF8pfGcxIHV8ZzU2MHxnZW5lfGdmXFwtNXxnXFwtbW98Z28oXFwud3xvZCl8Z3IoYWR8dW4pfGhhaWV8aGNpdHxoZFxcLShtfHB8dCl8aGVpXFwtfGhpKHB0fHRhKXxocCggaXxpcCl8aHNcXC1jfGh0KGMoXFwtfCB8X3xhfGd8cHxzfHQpfHRwKXxodShhd3x0Yyl8aVxcLSgyMHxnb3xtYSl8aTIzMHxpYWMoIHxcXC18XFwvKXxpYnJvfGlkZWF8aWcwMXxpa29tfGltMWt8aW5ub3xpcGFxfGlyaXN8amEodHx2KWF8amJyb3xqZW11fGppZ3N8a2RkaXxrZWppfGtndCggfFxcLyl8a2xvbnxrcHQgfGt3Y1xcLXxreW8oY3xrKXxsZShub3x4aSl8bGcoIGd8XFwvKGt8bHx1KXw1MHw1NHxcXC1bYS13XSl8bGlid3xseW54fG0xXFwtd3xtM2dhfG01MFxcL3xtYSh0ZXx1aXx4byl8bWMoMDF8MjF8Y2EpfG1cXC1jcnxtZShyY3xyaSl8bWkobzh8b2F8dHMpfG1tZWZ8bW8oMDF8MDJ8Yml8ZGV8ZG98dChcXC18IHxvfHYpfHp6KXxtdCg1MHxwMXx2ICl8bXdicHxteXdhfG4xMFswLTJdfG4yMFsyLTNdfG4zMCgwfDIpfG41MCgwfDJ8NSl8bjcoMCgwfDEpfDEwKXxuZSgoY3xtKVxcLXxvbnx0Znx3Znx3Z3x3dCl8bm9rKDZ8aSl8bnpwaHxvMmltfG9wKHRpfHd2KXxvcmFufG93ZzF8cDgwMHxwYW4oYXxkfHQpfHBkeGd8cGcoMTN8XFwtKFsxLThdfGMpKXxwaGlsfHBpcmV8cGwoYXl8dWMpfHBuXFwtMnxwbyhja3xydHxzZSl8cHJveHxwc2lvfHB0XFwtZ3xxYVxcLWF8cWMoMDd8MTJ8MjF8MzJ8NjB8XFwtWzItN118aVxcLSl8cXRla3xyMzgwfHI2MDB8cmFrc3xyaW05fHJvKHZlfHpvKXxzNTVcXC98c2EoZ2V8bWF8bW18bXN8bnl8dmEpfHNjKDAxfGhcXC18b298cFxcLSl8c2RrXFwvfHNlKGMoXFwtfDB8MSl8NDd8bWN8bmR8cmkpfHNnaFxcLXxzaGFyfHNpZShcXC18bSl8c2tcXC0wfHNsKDQ1fGlkKXxzbShhbHxhcnxiM3xpdHx0NSl8c28oZnR8bnkpfHNwKDAxfGhcXC18dlxcLXx2ICl8c3koMDF8bWIpfHQyKDE4fDUwKXx0NigwMHwxMHwxOCl8dGEoZ3R8bGspfHRjbFxcLXx0ZGdcXC18dGVsKGl8bSl8dGltXFwtfHRcXC1tb3x0byhwbHxzaCl8dHMoNzB8bVxcLXxtM3xtNSl8dHhcXC05fHVwKFxcLmJ8ZzF8c2kpfHV0c3R8djQwMHx2NzUwfHZlcml8dmkocmd8dGUpfHZrKDQwfDVbMC0zXXxcXC12KXx2bTQwfHZvZGF8dnVsY3x2eCg1Mnw1M3w2MHw2MXw3MHw4MHw4MXw4M3w4NXw5OCl8dzNjKFxcLXwgKXx3ZWJjfHdoaXR8d2koZyB8bmN8bncpfHdtbGJ8d29udXx4NzAwfHlhc1xcLXx5b3VyfHpldG98enRlXFwtL2kudGVzdChcbiAgICAgIGEyLnNsaWNlKDAsIDQpXG4gICAgKSlcbiAgICAgIGNoZWNrID0gdHJ1ZTtcbiAgfSkobmF2aWdhdG9yLnVzZXJBZ2VudCB8fCBuYXZpZ2F0b3IudmVuZG9yIHx8IHdpbmRvdy5vcGVyYSk7XG4gIHJldHVybiBjaGVjaztcbn1cbmZ1bmN0aW9uIGdldFVzZXJBZ2VudCgpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgcmVzdWx0cyA9IG5ldyBVQVBhcnNlcigpLmdldFJlc3VsdCgpO1xuICBjb25zdCBvc05hbWUgPSAoX2EgPSByZXN1bHRzLm9zLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYS50b0xvd2VyQ2FzZSgpO1xuICBsZXQgb3M7XG4gIHN3aXRjaCAodHJ1ZSkge1xuICAgIGNhc2Ugb3NOYW1lID09PSBcImlvc1wiOlxuICAgICAgb3MgPSBcImlvc1wiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBvc05hbWUgPT09IFwiYW5kcm9pZFwiOlxuICAgICAgb3MgPSBcImFuZHJvaWRcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2Ugb3NOYW1lID09PSBcIm1hYyBvc1wiOlxuICAgICAgb3MgPSBcIm1hY29zXCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIG9zTmFtZSA9PT0gXCJsaW51eFwiOlxuICAgICAgb3MgPSBcImxpbnV4XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChvc05hbWUgPT0gbnVsbCA/IHZvaWQgMCA6IG9zTmFtZS5pbmNsdWRlcyhcIndpbmRvd3NcIikpOlxuICAgICAgb3MgPSBcIndpbmRvd3NcIjtcbiAgICAgIGJyZWFrO1xuICB9XG4gIGNvbnN0IGJyb3dzZXJOYW1lID0gKF9iID0gcmVzdWx0cy5icm93c2VyLm5hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYi50b0xvd2VyQ2FzZSgpO1xuICBsZXQgYnJvd3NlcjtcbiAgc3dpdGNoICh0cnVlKSB7XG4gICAgY2FzZSBicm93c2VyTmFtZSA9PT0gXCJjaHJvbWVcIjpcbiAgICAgIGJyb3dzZXIgPSBcImNocm9tZVwiO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBicm93c2VyTmFtZSA9PT0gXCJmaXJlZm94XCI6XG4gICAgICBicm93c2VyID0gXCJmaXJlZm94XCI7XG4gICAgICBicmVhaztcbiAgICBjYXNlIChicm93c2VyTmFtZSA9PSBudWxsID8gdm9pZCAwIDogYnJvd3Nlck5hbWUuaW5jbHVkZXMoXCJzYWZhcmlcIikpOlxuICAgICAgYnJvd3NlciA9IFwic2FmYXJpXCI7XG4gICAgICBicmVhaztcbiAgfVxuICByZXR1cm4ge1xuICAgIG9zLFxuICAgIGJyb3dzZXJcbiAgfTtcbn1cbmNvbnN0IG1heFdpZHRoID0ge1xuICBtb2JpbGU6IDQ0MCxcbiAgdGFibGV0OiAxMDIwXG59O1xuZnVuY3Rpb24gaXNEZXZpY2UoZGV2aWNlKSB7XG4gIGNvbnN0IHdpbmRvdzIgPSBnZXRXaW5kb3ckMSgpO1xuICBpZiAoIXdpbmRvdzIpIHtcbiAgICByZXR1cm4gZGV2aWNlID09PSBcImRlc2t0b3BcIjtcbiAgfVxuICBjb25zdCB3aWR0aCA9IHdpbmRvdzIuaW5uZXJXaWR0aDtcbiAgc3dpdGNoIChkZXZpY2UpIHtcbiAgICBjYXNlIFwiZGVza3RvcFwiOlxuICAgICAgcmV0dXJuIHdpZHRoID4gbWF4V2lkdGgudGFibGV0O1xuICAgIGNhc2UgXCJ0YWJsZXRcIjpcbiAgICAgIHJldHVybiB3aWR0aCA+IG1heFdpZHRoLm1vYmlsZTtcbiAgICBkZWZhdWx0OlxuICAgIGNhc2UgXCJtb2JpbGVcIjpcbiAgICAgIHJldHVybiB3aWR0aCA8PSBtYXhXaWR0aC5tb2JpbGU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1lZGlhKGRldmljZSkge1xuICBzd2l0Y2ggKGRldmljZSkge1xuICAgIGNhc2UgXCJtb2JpbGVcIjpcbiAgICAgIHJldHVybiBgQG1lZGlhIChtYXgtd2lkdGg6ICR7bWF4V2lkdGgubW9iaWxlfXB4KWA7XG4gICAgY2FzZSBcInRhYmxldFwiOlxuICAgICAgcmV0dXJuIGBAbWVkaWEgKG1heC13aWR0aDogJHttYXhXaWR0aC50YWJsZXR9cHgpIChtaW4td2lkdGg6ICR7bWF4V2lkdGgubW9iaWxlfXB4KWA7XG4gICAgZGVmYXVsdDpcbiAgICBjYXNlIFwiZGVza3RvcFwiOlxuICAgICAgcmV0dXJuIGBAbWVkaWEgKG1pbi13aWR0aDogJHttYXhXaWR0aC50YWJsZXR9cHgpYDtcbiAgfVxufVxuY29uc3QgbWVkaWFUb3VjaCA9IFwiQG1lZGlhIChob3Zlcjogbm9uZSlcIjtcbmNvbnN0IG1lZGlhTm90VG91Y2ggPSBcIkBtZWRpYSBub3QgYWxsIGFuZCAoaG92ZXI6IG5vbmUpXCI7XG5jb25zdCBib3JkZXJzJDUgPSB7XG4gIG06IFwiMTAwdmhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBzY2FsZVZhbHVlcyA9IHtcbiAgczogMC4wMixcbiAgbTogMC4wNFxufTtcbmNvbnN0IEJ1dHRvblN0eWxlZCQzID0gc3R5bGVkLmJ1dHRvbmBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMuYXBwZWFyYW5jZSA9PT0gXCJmbGF0XCIgPyBcInRyYW5zcGFyZW50XCIgOiByZ2JhKHByb3BzLnRoZW1lLmNvbG9ycy5hY2NlbnQsIDAuMTIpfTtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5hY2NlbnR9O1xuXG4gICAgcGFkZGluZzogJHsocHJvcHMpID0+IHByb3BzLmFwcGVhcmFuY2UgPT09IFwiZmxhdFwiID8gXCIwXCIgOiBcIjlweCAxNnB4XCJ9O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBib3JkZXItcmFkaXVzOiAkeyhwcm9wcykgPT4gYm9yZGVycyQ1W3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIGN1cnNvcjogJHsocHJvcHMpID0+IHByb3BzLmRpc2FibGVkID8gXCJub3QtYWxsb3dlZFwiIDogXCJwb2ludGVyXCJ9O1xuXG4gICAgZm9udC1zaXplOiAxNHB4O1xuICAgIGZvbnQtd2VpZ2h0OiA1OTA7XG4gICAgbGluZS1oZWlnaHQ6IDE4cHg7XG5cbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xMjVzIGVhc2UtaW4tb3V0O1xuXG4gICAgJHttZWRpYU5vdFRvdWNofSB7XG4gICAgICAgICY6aG92ZXIge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAkeyhwcm9wcykgPT4gcHJvcHMuZGlzYWJsZWQgPyBcInVuc2V0XCIgOiBgc2NhbGUoJHsxICsgc2NhbGVWYWx1ZXNbcHJvcHMuc2NhbGVdfSlgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiAkeyhwcm9wcykgPT4gcHJvcHMuZGlzYWJsZWQgPyBcInVuc2V0XCIgOiBgc2NhbGUoJHsxIC0gc2NhbGVWYWx1ZXNbcHJvcHMuc2NhbGVdfSlgfTtcbiAgICB9XG5cbiAgICAke21lZGlhVG91Y2h9IHtcbiAgICAgICAgJjphY3RpdmUge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAkeyhwcm9wcykgPT4gcHJvcHMuZGlzYWJsZWQgPyBcInVuc2V0XCIgOiBgc2NhbGUoJHsxIC0gc2NhbGVWYWx1ZXNbcHJvcHMuc2NhbGVdICogMn0pYH07XG4gICAgICAgIH1cbiAgICB9XG5gO1xuZnVuY3Rpb24gdXNlRGF0YUF0dHJpYnV0ZXMocHJvcHMpIHtcbiAgY29uc3Qga2V5cyA9IHVudHJhY2soKCkgPT4gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcigoa2V5KSA9PiBrZXkuc3RhcnRzV2l0aChcImRhdGEtXCIpKSk7XG4gIGNvbnN0IFtkYXRhQXR0cnNdID0gc3BsaXRQcm9wcyhwcm9wcywga2V5cyk7XG4gIHJldHVybiBkYXRhQXR0cnM7XG59XG5jb25zdCBCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgY29uc3QgZGF0YUF0dHJzID0gdXNlRGF0YUF0dHJpYnV0ZXMocHJvcHMpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvblN0eWxlZCQzLCBtZXJnZVByb3BzKHtcbiAgICBnZXQgYXBwZWFyYW5jZSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5hcHBlYXJhbmNlIHx8IFwicHJpbWFyeVwiO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgb25DbGljazogKGUyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gcHJvcHMub25DbGljaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvcHMsIGUyKTtcbiAgICB9LFxuICAgIG9uTW91c2VFbnRlcjogKGUyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gcHJvcHMub25Nb3VzZUVudGVyKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChwcm9wcywgZTIpO1xuICAgIH0sXG4gICAgb25Nb3VzZUxlYXZlOiAoZTIpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSBwcm9wcy5vbk1vdXNlTGVhdmUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHByb3BzLCBlMik7XG4gICAgfSxcbiAgICByZWYociQpIHtcbiAgICAgIGNvbnN0IF9yZWYkID0gcHJvcHMucmVmO1xuICAgICAgdHlwZW9mIF9yZWYkID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJChyJCkgOiBwcm9wcy5yZWYgPSByJDtcbiAgICB9LFxuICAgIGdldCBkaXNhYmxlZCgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5kaXNhYmxlZDtcbiAgICB9LFxuICAgIGdldCBzY2FsZSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5zY2FsZSB8fCBcIm1cIjtcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1idXR0b25cIjogXCJ0cnVlXCJcbiAgfSwgZGF0YUF0dHJzLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfSkpO1xufTtcbmZ1bmN0aW9uIG5leHRGcmFtZShmbikge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gIH0pO1xufVxuY29uc3QgVHJhbnNpdGlvbiA9IChwcm9wcykgPT4ge1xuICBsZXQgZWw7XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGNvbnN0IFtzMSwgc2V0MV0gPSBjcmVhdGVTaWduYWwoKTtcbiAgY29uc3QgW3MyLCBzZXQyXSA9IGNyZWF0ZVNpZ25hbCgpO1xuICBjb25zdCByZXNvbHZlZCA9IGNoaWxkcmVuKCgpID0+IHByb3BzLmNoaWxkcmVuKTtcbiAgY29uc3Qge1xuICAgIG9uQmVmb3JlRW50ZXIsXG4gICAgb25FbnRlcixcbiAgICBvbkFmdGVyRW50ZXIsXG4gICAgb25CZWZvcmVFeGl0LFxuICAgIG9uRXhpdCxcbiAgICBvbkFmdGVyRXhpdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNsYXNzbmFtZXMgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBjb25zdCBuYW1lID0gcHJvcHMubmFtZSB8fCBcInNcIjtcbiAgICByZXR1cm4ge1xuICAgICAgZW50ZXJBY3RpdmVDbGFzczogcHJvcHMuZW50ZXJBY3RpdmVDbGFzcyB8fCBuYW1lICsgXCItZW50ZXItYWN0aXZlXCIsXG4gICAgICBlbnRlckNsYXNzOiBwcm9wcy5lbnRlckNsYXNzIHx8IG5hbWUgKyBcIi1lbnRlclwiLFxuICAgICAgZW50ZXJUb0NsYXNzOiBwcm9wcy5lbnRlclRvQ2xhc3MgfHwgbmFtZSArIFwiLWVudGVyLXRvXCIsXG4gICAgICBleGl0QWN0aXZlQ2xhc3M6IHByb3BzLmV4aXRBY3RpdmVDbGFzcyB8fCBuYW1lICsgXCItZXhpdC1hY3RpdmVcIixcbiAgICAgIGV4aXRDbGFzczogcHJvcHMuZXhpdENsYXNzIHx8IG5hbWUgKyBcIi1leGl0XCIsXG4gICAgICBleGl0VG9DbGFzczogcHJvcHMuZXhpdFRvQ2xhc3MgfHwgbmFtZSArIFwiLWV4aXQtdG9cIlxuICAgIH07XG4gIH0pO1xuICBmdW5jdGlvbiBlbnRlclRyYW5zaXRpb24oZWwyLCBwcmV2KSB7XG4gICAgaWYgKCFmaXJzdCB8fCBwcm9wcy5hcHBlYXIpIHtcbiAgICAgIGxldCBlbmRUcmFuc2l0aW9uID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgaWYgKGVsMiAmJiAoIWUyIHx8IGUyLnRhcmdldCA9PT0gZWwyKSkge1xuICAgICAgICAgIGVsMi5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgICAgICBlbDIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgICAgICBlbDIuY2xhc3NMaXN0LnJlbW92ZSguLi5lbnRlckFjdGl2ZUNsYXNzZXMpO1xuICAgICAgICAgIGVsMi5jbGFzc0xpc3QucmVtb3ZlKC4uLmVudGVyVG9DbGFzc2VzKTtcbiAgICAgICAgICBiYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICBzMSgpICE9PSBlbDIgJiYgc2V0MShlbDIpO1xuICAgICAgICAgICAgczIoKSA9PT0gZWwyICYmIHNldDIodm9pZCAwKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbkFmdGVyRW50ZXIgJiYgb25BZnRlckVudGVyKGVsMik7XG4gICAgICAgICAgaWYgKHByb3BzLm1vZGUgPT09IFwiaW5vdXRcIilcbiAgICAgICAgICAgIGV4aXRUcmFuc2l0aW9uKGVsMiwgcHJldik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdCBlbnRlckNsYXNzZXMgPSBjbGFzc25hbWVzKCkuZW50ZXJDbGFzcy5zcGxpdChcIiBcIik7XG4gICAgICBjb25zdCBlbnRlckFjdGl2ZUNsYXNzZXMgPSBjbGFzc25hbWVzKCkuZW50ZXJBY3RpdmVDbGFzcy5zcGxpdChcIiBcIik7XG4gICAgICBjb25zdCBlbnRlclRvQ2xhc3NlcyA9IGNsYXNzbmFtZXMoKS5lbnRlclRvQ2xhc3Muc3BsaXQoXCIgXCIpO1xuICAgICAgb25CZWZvcmVFbnRlciAmJiBvbkJlZm9yZUVudGVyKGVsMik7XG4gICAgICBlbDIuY2xhc3NMaXN0LmFkZCguLi5lbnRlckNsYXNzZXMpO1xuICAgICAgZWwyLmNsYXNzTGlzdC5hZGQoLi4uZW50ZXJBY3RpdmVDbGFzc2VzKTtcbiAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgIGVsMi5jbGFzc0xpc3QucmVtb3ZlKC4uLmVudGVyQ2xhc3Nlcyk7XG4gICAgICAgIGVsMi5jbGFzc0xpc3QuYWRkKC4uLmVudGVyVG9DbGFzc2VzKTtcbiAgICAgICAgb25FbnRlciAmJiBvbkVudGVyKGVsMiwgKCkgPT4gZW5kVHJhbnNpdGlvbigpKTtcbiAgICAgICAgaWYgKCFvbkVudGVyIHx8IG9uRW50ZXIubGVuZ3RoIDwgMikge1xuICAgICAgICAgIGVsMi5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgICAgICBlbDIuYWRkRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHByZXYgJiYgIXByb3BzLm1vZGUgPyBzZXQyKGVsMikgOiBzZXQxKGVsMik7XG4gIH1cbiAgZnVuY3Rpb24gZXhpdFRyYW5zaXRpb24oZWwyLCBwcmV2KSB7XG4gICAgY29uc3QgZXhpdENsYXNzZXMgPSBjbGFzc25hbWVzKCkuZXhpdENsYXNzLnNwbGl0KFwiIFwiKTtcbiAgICBjb25zdCBleGl0QWN0aXZlQ2xhc3NlcyA9IGNsYXNzbmFtZXMoKS5leGl0QWN0aXZlQ2xhc3Muc3BsaXQoXCIgXCIpO1xuICAgIGNvbnN0IGV4aXRUb0NsYXNzZXMgPSBjbGFzc25hbWVzKCkuZXhpdFRvQ2xhc3Muc3BsaXQoXCIgXCIpO1xuICAgIGlmICghcHJldi5wYXJlbnROb2RlKVxuICAgICAgcmV0dXJuIGVuZFRyYW5zaXRpb24oKTtcbiAgICBvbkJlZm9yZUV4aXQgJiYgb25CZWZvcmVFeGl0KHByZXYpO1xuICAgIHByZXYuY2xhc3NMaXN0LmFkZCguLi5leGl0Q2xhc3Nlcyk7XG4gICAgcHJldi5jbGFzc0xpc3QuYWRkKC4uLmV4aXRBY3RpdmVDbGFzc2VzKTtcbiAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgcHJldi5jbGFzc0xpc3QucmVtb3ZlKC4uLmV4aXRDbGFzc2VzKTtcbiAgICAgIHByZXYuY2xhc3NMaXN0LmFkZCguLi5leGl0VG9DbGFzc2VzKTtcbiAgICB9KTtcbiAgICBvbkV4aXQgJiYgb25FeGl0KHByZXYsICgpID0+IGVuZFRyYW5zaXRpb24oKSk7XG4gICAgaWYgKCFvbkV4aXQgfHwgb25FeGl0Lmxlbmd0aCA8IDIpIHtcbiAgICAgIHByZXYuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICBwcmV2LmFkZEV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuZFRyYW5zaXRpb24oZTIpIHtcbiAgICAgIGlmICghZTIgfHwgZTIudGFyZ2V0ID09PSBwcmV2KSB7XG4gICAgICAgIHByZXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICAgIHByZXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImFuaW1hdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgICAgcHJldi5jbGFzc0xpc3QucmVtb3ZlKC4uLmV4aXRBY3RpdmVDbGFzc2VzKTtcbiAgICAgICAgcHJldi5jbGFzc0xpc3QucmVtb3ZlKC4uLmV4aXRUb0NsYXNzZXMpO1xuICAgICAgICBzMSgpID09PSBwcmV2ICYmIHNldDEodm9pZCAwKTtcbiAgICAgICAgb25BZnRlckV4aXQgJiYgb25BZnRlckV4aXQocHJldik7XG4gICAgICAgIGlmIChwcm9wcy5tb2RlID09PSBcIm91dGluXCIpXG4gICAgICAgICAgZW50ZXJUcmFuc2l0aW9uKGVsMiwgcHJldik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNyZWF0ZUNvbXB1dGVkKChwcmV2KSA9PiB7XG4gICAgZWwgPSByZXNvbHZlZCgpO1xuICAgIHdoaWxlICh0eXBlb2YgZWwgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIGVsID0gZWwoKTtcbiAgICByZXR1cm4gdW50cmFjaygoKSA9PiB7XG4gICAgICBpZiAoZWwgJiYgZWwgIT09IHByZXYpIHtcbiAgICAgICAgaWYgKHByb3BzLm1vZGUgIT09IFwib3V0aW5cIilcbiAgICAgICAgICBlbnRlclRyYW5zaXRpb24oZWwsIHByZXYpO1xuICAgICAgICBlbHNlIGlmIChmaXJzdClcbiAgICAgICAgICBzZXQxKGVsKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2ICYmIHByZXYgIT09IGVsICYmIHByb3BzLm1vZGUgIT09IFwiaW5vdXRcIilcbiAgICAgICAgZXhpdFRyYW5zaXRpb24oZWwsIHByZXYpO1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlbDtcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBbczEsIHMyXTtcbn07XG5mdW5jdGlvbiBnZXRSZWN0KGVsZW1lbnQpIHtcbiAgY29uc3Qge1xuICAgIHRvcCxcbiAgICBib3R0b20sXG4gICAgbGVmdCxcbiAgICByaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IHBhcmVudFJlY3QgPSBlbGVtZW50LnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB0b3AgLSBwYXJlbnRSZWN0LnRvcCxcbiAgICBib3R0b20sXG4gICAgbGVmdDogbGVmdCAtIHBhcmVudFJlY3QubGVmdCxcbiAgICByaWdodCxcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfTtcbn1cbmNvbnN0IFRyYW5zaXRpb25Hcm91cCA9IChwcm9wcykgPT4ge1xuICBjb25zdCByZXNvbHZlZCA9IGNoaWxkcmVuKCgpID0+IHByb3BzLmNoaWxkcmVuKTtcbiAgY29uc3QgY2xhc3NuYW1lcyA9IGNyZWF0ZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBwcm9wcy5uYW1lIHx8IFwic1wiO1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckFjdGl2ZUNsYXNzOiBwcm9wcy5lbnRlckFjdGl2ZUNsYXNzIHx8IG5hbWUgKyBcIi1lbnRlci1hY3RpdmVcIixcbiAgICAgIGVudGVyQ2xhc3M6IHByb3BzLmVudGVyQ2xhc3MgfHwgbmFtZSArIFwiLWVudGVyXCIsXG4gICAgICBlbnRlclRvQ2xhc3M6IHByb3BzLmVudGVyVG9DbGFzcyB8fCBuYW1lICsgXCItZW50ZXItdG9cIixcbiAgICAgIGV4aXRBY3RpdmVDbGFzczogcHJvcHMuZXhpdEFjdGl2ZUNsYXNzIHx8IG5hbWUgKyBcIi1leGl0LWFjdGl2ZVwiLFxuICAgICAgZXhpdENsYXNzOiBwcm9wcy5leGl0Q2xhc3MgfHwgbmFtZSArIFwiLWV4aXRcIixcbiAgICAgIGV4aXRUb0NsYXNzOiBwcm9wcy5leGl0VG9DbGFzcyB8fCBuYW1lICsgXCItZXhpdC10b1wiLFxuICAgICAgbW92ZUNsYXNzOiBwcm9wcy5tb3ZlQ2xhc3MgfHwgbmFtZSArIFwiLW1vdmVcIlxuICAgIH07XG4gIH0pO1xuICBjb25zdCB7XG4gICAgb25CZWZvcmVFbnRlcixcbiAgICBvbkVudGVyLFxuICAgIG9uQWZ0ZXJFbnRlcixcbiAgICBvbkJlZm9yZUV4aXQsXG4gICAgb25FeGl0LFxuICAgIG9uQWZ0ZXJFeGl0XG4gIH0gPSBwcm9wcztcbiAgY29uc3QgW2NvbWJpbmVkLCBzZXRDb21iaW5lZF0gPSBjcmVhdGVTaWduYWwoKTtcbiAgbGV0IHAyID0gW107XG4gIGxldCBmaXJzdCA9IHRydWU7XG4gIGNyZWF0ZUNvbXB1dGVkKCgpID0+IHtcbiAgICBjb25zdCBjMiA9IHJlc29sdmVkKCk7XG4gICAgY29uc3QgY29tYiA9IFsuLi5jMl07XG4gICAgY29uc3QgbmV4dCA9IG5ldyBTZXQoYzIpO1xuICAgIGNvbnN0IHByZXYgPSBuZXcgU2V0KHAyKTtcbiAgICBjb25zdCBlbnRlckNsYXNzZXMgPSBjbGFzc25hbWVzKCkuZW50ZXJDbGFzcy5zcGxpdChcIiBcIik7XG4gICAgY29uc3QgZW50ZXJBY3RpdmVDbGFzc2VzID0gY2xhc3NuYW1lcygpLmVudGVyQWN0aXZlQ2xhc3Muc3BsaXQoXCIgXCIpO1xuICAgIGNvbnN0IGVudGVyVG9DbGFzc2VzID0gY2xhc3NuYW1lcygpLmVudGVyVG9DbGFzcy5zcGxpdChcIiBcIik7XG4gICAgY29uc3QgZXhpdENsYXNzZXMgPSBjbGFzc25hbWVzKCkuZXhpdENsYXNzLnNwbGl0KFwiIFwiKTtcbiAgICBjb25zdCBleGl0QWN0aXZlQ2xhc3NlcyA9IGNsYXNzbmFtZXMoKS5leGl0QWN0aXZlQ2xhc3Muc3BsaXQoXCIgXCIpO1xuICAgIGNvbnN0IGV4aXRUb0NsYXNzZXMgPSBjbGFzc25hbWVzKCkuZXhpdFRvQ2xhc3Muc3BsaXQoXCIgXCIpO1xuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBjMi5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGNvbnN0IGVsID0gYzJbaTJdO1xuICAgICAgaWYgKCFmaXJzdCAmJiAhcHJldi5oYXMoZWwpKSB7XG4gICAgICAgIGxldCBlbmRUcmFuc2l0aW9uID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgICBpZiAoZWwgJiYgKCFlMiB8fCBlMi50YXJnZXQgPT09IGVsKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5lbnRlckFjdGl2ZUNsYXNzZXMpO1xuICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSguLi5lbnRlclRvQ2xhc3Nlcyk7XG4gICAgICAgICAgICBvbkFmdGVyRW50ZXIgJiYgb25BZnRlckVudGVyKGVsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIG9uQmVmb3JlRW50ZXIgJiYgb25CZWZvcmVFbnRlcihlbCk7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4uZW50ZXJDbGFzc2VzKTtcbiAgICAgICAgZWwuY2xhc3NMaXN0LmFkZCguLi5lbnRlckFjdGl2ZUNsYXNzZXMpO1xuICAgICAgICBuZXh0RnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoLi4uZW50ZXJDbGFzc2VzKTtcbiAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKC4uLmVudGVyVG9DbGFzc2VzKTtcbiAgICAgICAgICBvbkVudGVyICYmIG9uRW50ZXIoZWwsICgpID0+IGVuZFRyYW5zaXRpb24oKSk7XG4gICAgICAgICAgaWYgKCFvbkVudGVyIHx8IG9uRW50ZXIubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihcInRyYW5zaXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGkyID0gMDsgaTIgPCBwMi5sZW5ndGg7IGkyKyspIHtcbiAgICAgIGNvbnN0IG9sZCA9IHAyW2kyXTtcbiAgICAgIGlmICghbmV4dC5oYXMob2xkKSAmJiBvbGQucGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgZW5kVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgaWYgKCFlMiB8fCBlMi50YXJnZXQgPT09IG9sZCkge1xuICAgICAgICAgICAgb2xkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgICAgICAgb2xkLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJhbmltYXRpb25lbmRcIiwgZW5kVHJhbnNpdGlvbik7XG4gICAgICAgICAgICBvbGQuY2xhc3NMaXN0LnJlbW92ZSguLi5leGl0QWN0aXZlQ2xhc3Nlcyk7XG4gICAgICAgICAgICBvbGQuY2xhc3NMaXN0LnJlbW92ZSguLi5leGl0VG9DbGFzc2VzKTtcbiAgICAgICAgICAgIG9uQWZ0ZXJFeGl0ICYmIG9uQWZ0ZXJFeGl0KG9sZCk7XG4gICAgICAgICAgICBwMiA9IHAyLmZpbHRlcigoaTMpID0+IGkzICE9PSBvbGQpO1xuICAgICAgICAgICAgc2V0Q29tYmluZWQocDIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29tYi5zcGxpY2UoaTIsIDAsIG9sZCk7XG4gICAgICAgIG9uQmVmb3JlRXhpdCAmJiBvbkJlZm9yZUV4aXQob2xkKTtcbiAgICAgICAgb2xkLmNsYXNzTGlzdC5hZGQoLi4uZXhpdENsYXNzZXMpO1xuICAgICAgICBvbGQuY2xhc3NMaXN0LmFkZCguLi5leGl0QWN0aXZlQ2xhc3Nlcyk7XG4gICAgICAgIG5leHRGcmFtZSgoKSA9PiB7XG4gICAgICAgICAgb2xkLmNsYXNzTGlzdC5yZW1vdmUoLi4uZXhpdENsYXNzZXMpO1xuICAgICAgICAgIG9sZC5jbGFzc0xpc3QuYWRkKC4uLmV4aXRUb0NsYXNzZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgb25FeGl0ICYmIG9uRXhpdChvbGQsICgpID0+IGVuZFRyYW5zaXRpb24oKSk7XG4gICAgICAgIGlmICghb25FeGl0IHx8IG9uRXhpdC5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgb2xkLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgICAgIG9sZC5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHAyID0gY29tYjtcbiAgICBzZXRDb21iaW5lZChjb21iKTtcbiAgfSk7XG4gIGNyZWF0ZUVmZmVjdCgobm9kZXMpID0+IHtcbiAgICBjb25zdCBjMiA9IGNvbWJpbmVkKCk7XG4gICAgYzIuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGxldCBuMjtcbiAgICAgIGlmICghKG4yID0gbm9kZXMuZ2V0KGNoaWxkKSkpIHtcbiAgICAgICAgbm9kZXMuc2V0KGNoaWxkLCBuMiA9IHtcbiAgICAgICAgICBwb3M6IGdldFJlY3QoY2hpbGQpLFxuICAgICAgICAgIG5ldzogIWZpcnN0XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmIChuMi5uZXcpIHtcbiAgICAgICAgbjIubmV3ID0gZmFsc2U7XG4gICAgICAgIG4yLm5ld1BvcyA9IGdldFJlY3QoY2hpbGQpO1xuICAgICAgfVxuICAgICAgaWYgKG4yLm5ldykge1xuICAgICAgICBjaGlsZC5hZGRFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCAoKSA9PiB7XG4gICAgICAgICAgbjIubmV3ID0gZmFsc2U7XG4gICAgICAgICAgY2hpbGQucGFyZW50Tm9kZSAmJiAobjIubmV3UG9zID0gZ2V0UmVjdChjaGlsZCkpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIG4yLm5ld1BvcyAmJiAobjIucG9zID0gbjIubmV3UG9zKTtcbiAgICAgIG4yLm5ld1BvcyA9IGdldFJlY3QoY2hpbGQpO1xuICAgIH0pO1xuICAgIGlmIChmaXJzdCkge1xuICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9XG4gICAgYzIuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IGMzID0gbm9kZXMuZ2V0KGNoaWxkKTtcbiAgICAgIGNvbnN0IG9sZFBvcyA9IGMzLnBvcztcbiAgICAgIGNvbnN0IG5ld1BvcyA9IGMzLm5ld1BvcztcbiAgICAgIGNvbnN0IGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgICAgIGNvbnN0IGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gICAgICBpZiAoZHggfHwgZHkpIHtcbiAgICAgICAgYzMubW92ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBzMiA9IGNoaWxkLnN0eWxlO1xuICAgICAgICBzMi50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlKCR7ZHh9cHgsJHtkeX1weClgO1xuICAgICAgICBzMi50cmFuc2l0aW9uRHVyYXRpb24gPSBcIjBzXCI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG4gICAgYzIuZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgIGNvbnN0IGMzID0gbm9kZXMuZ2V0KGNoaWxkKTtcbiAgICAgIGlmIChjMy5tb3ZlZCkge1xuICAgICAgICBsZXQgZW5kVHJhbnNpdGlvbiA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgICAgaWYgKGUyICYmIGUyLnRhcmdldCAhPT0gY2hpbGQgfHwgIWNoaWxkLnBhcmVudE5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgaWYgKCFlMiB8fCAvdHJhbnNmb3JtJC8udGVzdChlMi5wcm9wZXJ0eU5hbWUpKSB7XG4gICAgICAgICAgICBjaGlsZC5yZW1vdmVFdmVudExpc3RlbmVyKFwidHJhbnNpdGlvbmVuZFwiLCBlbmRUcmFuc2l0aW9uKTtcbiAgICAgICAgICAgIGNoaWxkLmNsYXNzTGlzdC5yZW1vdmUoLi4ubW92ZUNsYXNzZXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYzMubW92ZWQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgczIgPSBjaGlsZC5zdHlsZTtcbiAgICAgICAgY29uc3QgbW92ZUNsYXNzZXMgPSBjbGFzc25hbWVzKCkubW92ZUNsYXNzLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgY2hpbGQuY2xhc3NMaXN0LmFkZCguLi5tb3ZlQ2xhc3Nlcyk7XG4gICAgICAgIHMyLnRyYW5zZm9ybSA9IHMyLnRyYW5zaXRpb25EdXJhdGlvbiA9IFwiXCI7XG4gICAgICAgIGNoaWxkLmFkZEV2ZW50TGlzdGVuZXIoXCJ0cmFuc2l0aW9uZW5kXCIsIGVuZFRyYW5zaXRpb24pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBub2RlcztcbiAgfSwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSk7XG4gIHJldHVybiBjb21iaW5lZDtcbn07XG5mdW5jdGlvbiBjbGlja091dHNpZGUkMShlbCwgYWNjZXNzb3IpIHtcbiAgY29uc3Qgb25DbGljayA9IChlMikgPT4ge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gIWVsLmNvbnRhaW5zKGUyLnRhcmdldCkgJiYgKChfYSA9IGFjY2Vzc29yKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYSgpKTtcbiAgfTtcbiAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljayk7XG4gIG9uQ2xlYW51cCgoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrKSk7XG59XG5mdW5jdGlvbiBlc2NQcmVzc2VkKF8sIGFjY2Vzc29yKSB7XG4gIGNvbnN0IG9uS2V5UHJlc3MgPSAoZTIpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChlMi5rZXkgPT09IFwiRXNjYXBlXCIpIHtcbiAgICAgIChfYSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5ibHVyKCk7XG4gICAgICAoX2IgPSBhY2Nlc3NvcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2IoKTtcbiAgICB9XG4gIH07XG4gIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgb25LZXlQcmVzcyk7XG4gIG9uQ2xlYW51cCgoKSA9PiBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIG9uS2V5UHJlc3MpKTtcbn1cbmNvbnN0IF90bXBsJCRnID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmc+PHBhdGggZD1cIk05LjEgMy40MDAxMkw1LjUgOC4wMDAxTDkuMSAxMi42MDAxXCIgc3Ryb2tlLXdpZHRoPVwiMS44XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PC9wYXRoPjwvc3ZnPmAsIDQsIHRydWUpO1xuY29uc3Qgcm90YXRpb25EZWdyZWVzID0ge1xuICBsZWZ0OiAwLFxuICB0b3A6IDkwLFxuICByaWdodDogMTgwLFxuICBib3R0b206IDI3MFxufTtcbmNvbnN0IEFycm93SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbiAgY29uc3QgZGlyZWN0aW9uID0gKCkgPT4gcHJvcHMuZGlyZWN0aW9uIHx8IFwibGVmdFwiO1xuICBjb25zdCBTdmcgPSBzdHlsZWQoXCJzdmdcIilgXG4gICAgICAgIHRyYW5zZm9ybTogcm90YXRlKCR7KHByb3BzMikgPT4gcm90YXRpb25EZWdyZWVzW3Byb3BzMi5zdmdEaXJlY3Rpb25dfWRlZyk7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjFzIGVhc2UtaW4tb3V0O1xuICAgIGA7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3ZnLCB7XG4gICAgd2lkdGg6IFwiMTZcIixcbiAgICBoZWlnaHQ6IFwiMTZcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAxNiAxNlwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgZ2V0IHN2Z0RpcmVjdGlvbigpIHtcbiAgICAgIHJldHVybiBkaXJlY3Rpb24oKTtcbiAgICB9LFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIGNvbnN0IF9lbCQgPSBfdG1wbCQkZy5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQsIFwic3Ryb2tlXCIsIGZpbGwoKSkpO1xuICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBfdG1wbCQkZiA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTMuOTAwMDMgMy44OTk5MUw4LjAwMDAyIDcuOTk5OU04LjAwMDAyIDcuOTk5OUwxMi4xIDEyLjA5OTlNOC4wMDAwMiA3Ljk5OTlMMTIuMSAzLjg5OTlNOC4wMDAwMiA3Ljk5OTlMMy45MDAwMiAxMi4wOTk5XCIgc3Ryb2tlLXdpZHRoPVwiMS44XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PC9wYXRoPjwvc3ZnPmApO1xuY29uc3QgQ2xvc2VJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24uc2Vjb25kYXJ5O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICBjb25zdCBfZWwkID0gX3RtcGwkJGYuY2xvbmVOb2RlKHRydWUpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZDtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gc2V0QXR0cmlidXRlKF9lbCQyLCBcInN0cm9rZVwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG5jb25zdCBJY29uQnV0dG9uU3R5bGVkID0gc3R5bGVkLmJ1dHRvbmBcbiAgICBwYWRkaW5nOiAwO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICB3aWR0aDogMzJweDtcbiAgICBoZWlnaHQ6IDMycHg7XG4gICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnl9O1xuICAgIGJvcmRlcjogbm9uZTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4xMjVzIGVhc2UtaW4tb3V0O1xuXG4gICAgJHttZWRpYU5vdFRvdWNofSB7XG4gICAgICAgICY6aG92ZXIge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjA0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk2KTtcbiAgICB9XG5cbiAgICAke21lZGlhVG91Y2h9IHtcbiAgICAgICAgJjphY3RpdmUge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjkyKTtcbiAgICAgICAgfVxuICAgIH1cbmA7XG5jb25zdCBJY29uQnV0dG9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IGRhdGFBdHRycyA9IHVzZURhdGFBdHRyaWJ1dGVzKHByb3BzKTtcbiAgY29uc3QgaWNvbiA9ICgpID0+IHByb3BzLmljb24gfHwgXCJjbG9zZVwiO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEljb25CdXR0b25TdHlsZWQsIG1lcmdlUHJvcHMoe1xuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIG9uQ2xpY2s6ICgpID0+IHByb3BzLm9uQ2xpY2soKSxcbiAgICBcImRhdGEtdGMtaWNvbi1idXR0b25cIjogXCJ0cnVlXCJcbiAgfSwgZGF0YUF0dHJzLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gISFwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiAhcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGljb24oKSA9PT0gXCJjbG9zZVwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDbG9zZUljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmZpbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGljb24oKSA9PT0gXCJhcnJvd1wiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBcnJvd0ljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGZpbGwoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmZpbGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgTW9kYWxCYWNrZ3JvdW5kU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgcG9zaXRpb246IGZpeGVkO1xuICAgIHotaW5kZXg6IDEwMDA7XG4gICAgbGVmdDogMDtcbiAgICB0b3A6IDA7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMC40KTtcblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuICAgIH1cblxuICAgIEBtZWRpYSAobWluLXdpZHRoOiAke21heFdpZHRoLm1vYmlsZS50b1N0cmluZygpfXB4KSBhbmQgKG1heC1oZWlnaHQ6IDYwMHB4KSB7XG4gICAgICAgIHBhZGRpbmc6IDQ4cHggMDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgICAgIG92ZXJmbG93OiBzY3JvbGw7XG4gICAgfVxuYDtcbmNvbnN0IE1vZGFsV3JhcHBlckNsYXNzID0gdWBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgYm94LXNoYWRvdzogMCA0cHggMTZweCByZ2JhKDAsIDAsIDAsIDAuMDgpLCAwIDE2cHggNjRweCByZ2JhKDAsIDAsIDAsIDAuMTYpO1xuICAgIG1pbi1oZWlnaHQ6IDEwMHB4O1xuICAgIHdpZHRoOiA0NDBweDtcbiAgICBwYWRkaW5nOiA0NHB4IDU2cHggMjRweDtcblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuYDtcbmNvbnN0IENsb3NlQnV0dG9uU3R5bGVkID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICByaWdodDogMTZweDtcbiAgICB0b3A6IDE2cHg7XG5gO1xuY29uc3QgX3RtcGwkJGUgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGRpdj48L2Rpdj5gKTtcbmNvbnN0IGNsaWNrT3V0c2lkZSA9IGNsaWNrT3V0c2lkZSQxO1xuY29uc3Qga2V5UHJlc3NlZCA9IGVzY1ByZXNzZWQ7XG5jb25zdCBib3JkZXJzJDQgPSB7XG4gIG06IFwiMjRweFwiLFxuICBzOiBcIjE2cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBNb2RhbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGRhdGFBdHRycyA9IHVzZURhdGFBdHRyaWJ1dGVzKHByb3BzKTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAocHJvcHMub3BlbmVkKSB7XG4gICAgICBkaXNhYmxlU2Nyb2xsKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuYWJsZVNjcm9sbCgpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNpdGlvbiwge1xuICAgIG9uQmVmb3JlRW50ZXI6IChlbCkgPT4ge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBpc0RldmljZShcIm1vYmlsZVwiKSA/IDIwMCA6IDEwMDtcbiAgICAgIGVsLmFuaW1hdGUoW3tcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfSwge1xuICAgICAgICBvcGFjaXR5OiAxXG4gICAgICB9XSwge1xuICAgICAgICBkdXJhdGlvblxuICAgICAgfSk7XG4gICAgICBpZiAoaXNEZXZpY2UoXCJtb2JpbGVcIikpIHtcbiAgICAgICAgZWwuZmlyc3RFbGVtZW50Q2hpbGQuYW5pbWF0ZShbe1xuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKDM5MHB4KVwiXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgwKVwiXG4gICAgICAgIH1dLCB7XG4gICAgICAgICAgZHVyYXRpb25cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBvbkV4aXQ6IChlbCwgZG9uZSkgPT4ge1xuICAgICAgY29uc3QgZHVyYXRpb24gPSBpc0RldmljZShcIm1vYmlsZVwiKSA/IDIwMCA6IDEwMDtcbiAgICAgIGNvbnN0IGJhY2tncm91bmRBbmltYXRpb24gPSBlbC5hbmltYXRlKFt7XG4gICAgICAgIG9wYWNpdHk6IDFcbiAgICAgIH0sIHtcbiAgICAgICAgb3BhY2l0eTogMFxuICAgICAgfV0sIHtcbiAgICAgICAgZHVyYXRpb25cbiAgICAgIH0pO1xuICAgICAgaWYgKGlzRGV2aWNlKFwibW9iaWxlXCIpKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnRBbmltYXRpb24gPSBlbC5maXJzdEVsZW1lbnRDaGlsZC5hbmltYXRlKFt7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMzkwcHgpXCJcbiAgICAgICAgfV0sIHtcbiAgICAgICAgICBkdXJhdGlvblxuICAgICAgICB9KTtcbiAgICAgICAgUHJvbWlzZS5hbGwoW2JhY2tncm91bmRBbmltYXRpb24uZmluaXNoZWQsIGNvbnRlbnRBbmltYXRpb24uZmluaXNoZWRdKS50aGVuKGRvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFja2dyb3VuZEFuaW1hdGlvbi5maW5pc2hlZC50aGVuKGRvbmUpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5vcGVuZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KE1vZGFsQmFja2dyb3VuZFN0eWxlZCwgbWVyZ2VQcm9wcyh7XG4gICAgICAgICAgICBcImRhdGEtdGMtbW9kYWxcIjogXCJ0cnVlXCJcbiAgICAgICAgICB9LCBkYXRhQXR0cnMsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgY29uc3QgX2VsJCA9IF90bXBsJCRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgICAgICAgICAgdXNlKGtleVByZXNzZWQsIF9lbCQsICgpID0+ICgpID0+IHByb3BzLm9uQ2xvc2UoKSk7XG4gICAgICAgICAgICAgIHVzZShjbGlja091dHNpZGUsIF9lbCQsICgpID0+ICgpID0+IHByb3BzLm9uQ2xvc2UoKSk7XG4gICAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoQ2xvc2VCdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBpY29uOiBcImNsb3NlXCIsXG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25DbG9zZSgpXG4gICAgICAgICAgICAgIH0pLCBudWxsKTtcbiAgICAgICAgICAgICAgaW5zZXJ0KF9lbCQsICgpID0+IHByb3BzLmNoaWxkcmVuLCBudWxsKTtcbiAgICAgICAgICAgICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IGNsYXNzTmFtZShfZWwkLCBjbihNb2RhbFdyYXBwZXJDbGFzcywgcHJvcHMuY2xhc3MsIHVgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7dGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6ICR7Ym9yZGVycyQ0W3RoZW1lLmJvcmRlclJhZGl1c119O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvcmRlci1yYWRpdXM6ICR7Ym9yZGVycyQ0W3RoZW1lLmJvcmRlclJhZGl1c119XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtib3JkZXJzJDRbdGhlbWUuYm9yZGVyUmFkaXVzXX0gMCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYCkpKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IHdyYXBwZXJCb3JkZXJSYWRpdXMgPSB7XG4gIG06IFwiMjJweFwiLFxuICBzOiBcIjEycHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBzbGlkZXJCb3JkZXJSYWRpdXMgPSB7XG4gIG06IFwiMThweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IFRhYkJhclN0eWxlZCQxID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBncmlkO1xuICAgIGdyaWQtdGVtcGxhdGU6IDFmciAvIDFmciAxZnI7XG4gICAgd2lkdGg6IGZpdC1jb250ZW50O1xuICAgIGp1c3RpZnktaXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IDRweDtcblxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBwYWRkaW5nOiA0cHg7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IHdyYXBwZXJCb3JkZXJSYWRpdXNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2Vjb25kYXJ5fTtcbmA7XG5jb25zdCBTbGlkZXJTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDRweDtcbiAgICBsZWZ0OiA0cHg7XG5cbiAgICBoZWlnaHQ6IGNhbGMoMTAwJSAtIDhweCk7XG4gICAgd2lkdGg6IGNhbGMoNTAlIC0gNHB4KTtcblxuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBzbGlkZXJCb3JkZXJSYWRpdXNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnNlZ21lbnR9O1xuXG4gICAgdHJhbnNmb3JtOiAkeyhwcm9wcykgPT4gcHJvcHMucmlnaHQgPyBcInRyYW5zbGF0ZVgoMTAwJSlcIiA6IFwidHJhbnNsYXRlWCgwKVwifTtcblxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjEzcyBlYXNlLWluLW91dDtcbmA7XG5jb25zdCBJbnB1dFN0eWxlZCA9IHN0eWxlZC5pbnB1dGBcbiAgICBkaXNwbGF5OiBub25lO1xuYDtcbmNvbnN0IExhYmVsU3R5bGVkID0gc3R5bGVkLmxhYmVsYFxuICAgIHBhZGRpbmc6IDlweCAxMnB4O1xuICAgIHotaW5kZXg6IDE7XG5cbiAgICBjdXJzb3I6ICR7KHByb3BzKSA9PiBwcm9wcy5pc0FjdGl2ZSA/IFwiZGVmYXVsdFwiIDogXCJwb2ludGVyXCJ9O1xuXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMTNzIGVhc2UtaW4tb3V0O1xuXG4gICAgJjpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogJHsocHJvcHMpID0+IHByb3BzLmlzQWN0aXZlID8gXCJub25lXCIgOiBcInNjYWxlKDEuMDI1KVwifTtcbiAgICB9XG5cbiAgICA+ICoge1xuICAgICAgICAkeyhwcm9wcykgPT4gIXByb3BzLmlzQWN0aXZlID8gYGNvbG9yOiAke3Byb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07YCA6IFwiXCJ9XG4gICAgfVxuYDtcbmNvbnN0IFRhYkJhciA9IChwcm9wcykgPT4ge1xuICBjb25zdCBncm91cE5hbWUgPSBcInRhYkJhclwiICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMWU0KTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUYWJCYXJTdHlsZWQkMSwge1xuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy10YWItYmFyXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNsaWRlclN0eWxlZCwge1xuICAgICAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnNlbGVjdGVkVGFiSW5kZXggPT09IDE7XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTGFiZWxTdHlsZWQsIHtcbiAgICAgICAgZ2V0IGlzQWN0aXZlKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5zZWxlY3RlZFRhYkluZGV4ID09PSAwO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSW5wdXRTdHlsZWQsIHtcbiAgICAgICAgICAgIHR5cGU6IFwicmFkaW9cIixcbiAgICAgICAgICAgIG5hbWU6IGdyb3VwTmFtZSxcbiAgICAgICAgICAgIGdldCBjaGVja2VkKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuc2VsZWN0ZWRUYWJJbmRleCA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbklucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgcmV0dXJuIChfYSA9IHByb3BzLm9uU2VsZWN0ZWRUYWJJbmRleENoYW5nZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvcHMsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVNZW1vKCgpID0+IHByb3BzLnRhYjEpXTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChMYWJlbFN0eWxlZCwge1xuICAgICAgICBnZXQgaXNBY3RpdmUoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnNlbGVjdGVkVGFiSW5kZXggPT09IDE7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChJbnB1dFN0eWxlZCwge1xuICAgICAgICAgICAgdHlwZTogXCJyYWRpb1wiLFxuICAgICAgICAgICAgZ2V0IGNoZWNrZWQoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5zZWxlY3RlZFRhYkluZGV4ID09PSAxO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5hbWU6IGdyb3VwTmFtZSxcbiAgICAgICAgICAgIG9uSW5wdXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gcHJvcHMub25TZWxlY3RlZFRhYkluZGV4Q2hhbmdlKSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChwcm9wcywgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMudGFiMildO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBib3JkZXJzJDMgPSB7XG4gIG06IFwiMTZweFwiLFxuICBzOiBcIjhweFwiLFxuICBub25lOiBcIjBcIlxufTtcbmNvbnN0IHFyTm9ybWFsU2l6ZSA9IDI1NjtcbmNvbnN0IGltZ1NpemVEZWZhdWx0ID0gNjA7XG5jb25zdCBwaWNTaXplRGVmYXVsdCA9IDQ4O1xuY29uc3QgcXJQYWRkaW5nVG9wID0gMjQ7XG5jb25zdCBRckNvZGVCYWNrZ3JvdW5kID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnl9O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzJDNbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG4gICAgcGFkZGluZzogJHt0b1B4KHFyUGFkZGluZ1RvcCl9IDA7XG4gICAgaGVpZ2h0OiAke3RvUHgocXJOb3JtYWxTaXplICsgcXJQYWRkaW5nVG9wICogMil9O1xuICAgIHdpZHRoOiAxMDAlO1xuXG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbmA7XG5jb25zdCBRckNvZGVXcmFwcGVyID0gc3R5bGVkLmRpdmBcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG5cbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XG4gICAgbWFyZ2luOiAwIGF1dG87XG5cbiAgICA+IGRpdjpmaXJzdC1jaGlsZCB7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIH1cblxuICAgIHJlY3Qge1xuICAgICAgICBmaWxsOiB0cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICBwYXRoIHtcbiAgICAgICAgZmlsbDogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnl9O1xuICAgIH1cbmA7XG5jb25zdCBJbWFnZUJhY2tncm91bmQgPSBzdHlsZWQuZGl2YFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB3aWR0aDogJHt0b1B4KGltZ1NpemVEZWZhdWx0KX07XG4gICAgaGVpZ2h0OiAke3RvUHgoaW1nU2l6ZURlZmF1bHQpfTtcbiAgICBiYWNrZ3JvdW5kOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2Vjb25kYXJ5fTtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbmA7XG5jb25zdCBJbWFnZVN0eWxlZCQyID0gc3R5bGVkKEltYWdlKWBcbiAgICB3aWR0aDogJHsocHJvcHMpID0+IHRvUHgocHJvcHMuc2l6ZSl9O1xuICAgIGhlaWdodDogJHsocHJvcHMpID0+IHRvUHgocHJvcHMuc2l6ZSl9O1xuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG5gO1xuY29uc3QgQ29weUJ1dHRvblN0eWxlZCA9IHN0eWxlZChCdXR0b24pYFxuICAgIGZpbHRlcjogZHJvcC1zaGFkb3coMHB4IDJweCA4cHggcmdiYSgwLCAwLCAwLCAwLjA4KSk7XG4gICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgIGJvdHRvbTogMTRweDtcbiAgICBsZWZ0OiA1MCU7XG5cbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAwKTtcblxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWdtZW50fTtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnl9O1xuXG4gICAgJjpob3ZlciB7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIDApIHNjYWxlKDEuMDQpO1xuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgMCkgc2NhbGUoMC45Nik7XG4gICAgfVxuYDtcbnZhciBxcmNvZGUkMSA9IHsgZXhwb3J0czoge30gfTtcbihmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcbiAgdmFyIHFyY29kZTIgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcXJjb2RlMyA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG4gICAgICB2YXIgUEFEMCA9IDIzNjtcbiAgICAgIHZhciBQQUQxID0gMTc7XG4gICAgICB2YXIgX3R5cGVOdW1iZXIgPSB0eXBlTnVtYmVyO1xuICAgICAgdmFyIF9lcnJvckNvcnJlY3Rpb25MZXZlbCA9IFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWxbZXJyb3JDb3JyZWN0aW9uTGV2ZWxdO1xuICAgICAgdmFyIF9tb2R1bGVzID0gbnVsbDtcbiAgICAgIHZhciBfbW9kdWxlQ291bnQgPSAwO1xuICAgICAgdmFyIF9kYXRhQ2FjaGUgPSBudWxsO1xuICAgICAgdmFyIF9kYXRhTGlzdCA9IFtdO1xuICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICB2YXIgbWFrZUltcGwgPSBmdW5jdGlvbih0ZXN0LCBtYXNrUGF0dGVybikge1xuICAgICAgICBfbW9kdWxlQ291bnQgPSBfdHlwZU51bWJlciAqIDQgKyAxNztcbiAgICAgICAgX21vZHVsZXMgPSBmdW5jdGlvbihtb2R1bGVDb3VudCkge1xuICAgICAgICAgIHZhciBtb2R1bGVzID0gbmV3IEFycmF5KG1vZHVsZUNvdW50KTtcbiAgICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICAgIG1vZHVsZXNbcm93XSA9IG5ldyBBcnJheShtb2R1bGVDb3VudCk7XG4gICAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgICAgbW9kdWxlc1tyb3ddW2NvbF0gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kdWxlcztcbiAgICAgICAgfShfbW9kdWxlQ291bnQpO1xuICAgICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIDApO1xuICAgICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKF9tb2R1bGVDb3VudCAtIDcsIDApO1xuICAgICAgICBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuKDAsIF9tb2R1bGVDb3VudCAtIDcpO1xuICAgICAgICBzZXR1cFBvc2l0aW9uQWRqdXN0UGF0dGVybigpO1xuICAgICAgICBzZXR1cFRpbWluZ1BhdHRlcm4oKTtcbiAgICAgICAgc2V0dXBUeXBlSW5mbyh0ZXN0LCBtYXNrUGF0dGVybik7XG4gICAgICAgIGlmIChfdHlwZU51bWJlciA+PSA3KSB7XG4gICAgICAgICAgc2V0dXBUeXBlTnVtYmVyKHRlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZGF0YUNhY2hlID09IG51bGwpIHtcbiAgICAgICAgICBfZGF0YUNhY2hlID0gY3JlYXRlRGF0YShfdHlwZU51bWJlciwgX2Vycm9yQ29ycmVjdGlvbkxldmVsLCBfZGF0YUxpc3QpO1xuICAgICAgICB9XG4gICAgICAgIG1hcERhdGEoX2RhdGFDYWNoZSwgbWFza1BhdHRlcm4pO1xuICAgICAgfTtcbiAgICAgIHZhciBzZXR1cFBvc2l0aW9uUHJvYmVQYXR0ZXJuID0gZnVuY3Rpb24ocm93LCBjb2wpIHtcbiAgICAgICAgZm9yICh2YXIgciA9IC0xOyByIDw9IDc7IHIgKz0gMSkge1xuICAgICAgICAgIGlmIChyb3cgKyByIDw9IC0xIHx8IF9tb2R1bGVDb3VudCA8PSByb3cgKyByKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgZm9yICh2YXIgYzIgPSAtMTsgYzIgPD0gNzsgYzIgKz0gMSkge1xuICAgICAgICAgICAgaWYgKGNvbCArIGMyIDw9IC0xIHx8IF9tb2R1bGVDb3VudCA8PSBjb2wgKyBjMilcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoMCA8PSByICYmIHIgPD0gNiAmJiAoYzIgPT0gMCB8fCBjMiA9PSA2KSB8fCAwIDw9IGMyICYmIGMyIDw9IDYgJiYgKHIgPT0gMCB8fCByID09IDYpIHx8IDIgPD0gciAmJiByIDw9IDQgJiYgMiA8PSBjMiAmJiBjMiA8PSA0KSB7XG4gICAgICAgICAgICAgIF9tb2R1bGVzW3JvdyArIHJdW2NvbCArIGMyXSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBfbW9kdWxlc1tyb3cgKyByXVtjb2wgKyBjMl0gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZ2V0QmVzdE1hc2tQYXR0ZXJuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtaW5Mb3N0UG9pbnQgPSAwO1xuICAgICAgICB2YXIgcGF0dGVybiA9IDA7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCA4OyBpMiArPSAxKSB7XG4gICAgICAgICAgbWFrZUltcGwodHJ1ZSwgaTIpO1xuICAgICAgICAgIHZhciBsb3N0UG9pbnQgPSBRUlV0aWwuZ2V0TG9zdFBvaW50KF90aGlzKTtcbiAgICAgICAgICBpZiAoaTIgPT0gMCB8fCBtaW5Mb3N0UG9pbnQgPiBsb3N0UG9pbnQpIHtcbiAgICAgICAgICAgIG1pbkxvc3RQb2ludCA9IGxvc3RQb2ludDtcbiAgICAgICAgICAgIHBhdHRlcm4gPSBpMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhdHRlcm47XG4gICAgICB9O1xuICAgICAgdmFyIHNldHVwVGltaW5nUGF0dGVybiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciByID0gODsgciA8IF9tb2R1bGVDb3VudCAtIDg7IHIgKz0gMSkge1xuICAgICAgICAgIGlmIChfbW9kdWxlc1tyXVs2XSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX21vZHVsZXNbcl1bNl0gPSByICUgMiA9PSAwO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGMyID0gODsgYzIgPCBfbW9kdWxlQ291bnQgLSA4OyBjMiArPSAxKSB7XG4gICAgICAgICAgaWYgKF9tb2R1bGVzWzZdW2MyXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX21vZHVsZXNbNl1bYzJdID0gYzIgJSAyID09IDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgc2V0dXBQb3NpdGlvbkFkanVzdFBhdHRlcm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHBvcyA9IFFSVXRpbC5nZXRQYXR0ZXJuUG9zaXRpb24oX3R5cGVOdW1iZXIpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcG9zLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9zLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YXIgcm93ID0gcG9zW2kyXTtcbiAgICAgICAgICAgIHZhciBjb2wgPSBwb3Nbal07XG4gICAgICAgICAgICBpZiAoX21vZHVsZXNbcm93XVtjb2xdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciByID0gLTI7IHIgPD0gMjsgciArPSAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGMyID0gLTI7IGMyIDw9IDI7IGMyICs9IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAociA9PSAtMiB8fCByID09IDIgfHwgYzIgPT0gLTIgfHwgYzIgPT0gMiB8fCByID09IDAgJiYgYzIgPT0gMCkge1xuICAgICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgYzJdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgX21vZHVsZXNbcm93ICsgcl1bY29sICsgYzJdID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIHNldHVwVHlwZU51bWJlciA9IGZ1bmN0aW9uKHRlc3QpIHtcbiAgICAgICAgdmFyIGJpdHMgPSBRUlV0aWwuZ2V0QkNIVHlwZU51bWJlcihfdHlwZU51bWJlcik7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCAxODsgaTIgKz0gMSkge1xuICAgICAgICAgIHZhciBtb2QgPSAhdGVzdCAmJiAoYml0cyA+PiBpMiAmIDEpID09IDE7XG4gICAgICAgICAgX21vZHVsZXNbTWF0aC5mbG9vcihpMiAvIDMpXVtpMiAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM10gPSBtb2Q7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDE4OyBpMiArPSAxKSB7XG4gICAgICAgICAgdmFyIG1vZCA9ICF0ZXN0ICYmIChiaXRzID4+IGkyICYgMSkgPT0gMTtcbiAgICAgICAgICBfbW9kdWxlc1tpMiAlIDMgKyBfbW9kdWxlQ291bnQgLSA4IC0gM11bTWF0aC5mbG9vcihpMiAvIDMpXSA9IG1vZDtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBzZXR1cFR5cGVJbmZvID0gZnVuY3Rpb24odGVzdCwgbWFza1BhdHRlcm4pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPDwgMyB8IG1hc2tQYXR0ZXJuO1xuICAgICAgICB2YXIgYml0cyA9IFFSVXRpbC5nZXRCQ0hUeXBlSW5mbyhkYXRhKTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDE1OyBpMiArPSAxKSB7XG4gICAgICAgICAgdmFyIG1vZCA9ICF0ZXN0ICYmIChiaXRzID4+IGkyICYgMSkgPT0gMTtcbiAgICAgICAgICBpZiAoaTIgPCA2KSB7XG4gICAgICAgICAgICBfbW9kdWxlc1tpMl1bOF0gPSBtb2Q7XG4gICAgICAgICAgfSBlbHNlIGlmIChpMiA8IDgpIHtcbiAgICAgICAgICAgIF9tb2R1bGVzW2kyICsgMV1bOF0gPSBtb2Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9tb2R1bGVzW19tb2R1bGVDb3VudCAtIDE1ICsgaTJdWzhdID0gbW9kO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgMTU7IGkyICs9IDEpIHtcbiAgICAgICAgICB2YXIgbW9kID0gIXRlc3QgJiYgKGJpdHMgPj4gaTIgJiAxKSA9PSAxO1xuICAgICAgICAgIGlmIChpMiA8IDgpIHtcbiAgICAgICAgICAgIF9tb2R1bGVzWzhdW19tb2R1bGVDb3VudCAtIGkyIC0gMV0gPSBtb2Q7XG4gICAgICAgICAgfSBlbHNlIGlmIChpMiA8IDkpIHtcbiAgICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaTIgLSAxICsgMV0gPSBtb2Q7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9tb2R1bGVzWzhdWzE1IC0gaTIgLSAxXSA9IG1vZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX21vZHVsZXNbX21vZHVsZUNvdW50IC0gOF1bOF0gPSAhdGVzdDtcbiAgICAgIH07XG4gICAgICB2YXIgbWFwRGF0YSA9IGZ1bmN0aW9uKGRhdGEsIG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgIHZhciBpbmMgPSAtMTtcbiAgICAgICAgdmFyIHJvdyA9IF9tb2R1bGVDb3VudCAtIDE7XG4gICAgICAgIHZhciBiaXRJbmRleCA9IDc7XG4gICAgICAgIHZhciBieXRlSW5kZXggPSAwO1xuICAgICAgICB2YXIgbWFza0Z1bmMgPSBRUlV0aWwuZ2V0TWFza0Z1bmN0aW9uKG1hc2tQYXR0ZXJuKTtcbiAgICAgICAgZm9yICh2YXIgY29sID0gX21vZHVsZUNvdW50IC0gMTsgY29sID4gMDsgY29sIC09IDIpIHtcbiAgICAgICAgICBpZiAoY29sID09IDYpXG4gICAgICAgICAgICBjb2wgLT0gMTtcbiAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgYzIgPSAwOyBjMiA8IDI7IGMyICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKF9tb2R1bGVzW3Jvd11bY29sIC0gYzJdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGFyayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChieXRlSW5kZXggPCBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZGFyayA9IChkYXRhW2J5dGVJbmRleF0gPj4+IGJpdEluZGV4ICYgMSkgPT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIG1hc2sgPSBtYXNrRnVuYyhyb3csIGNvbCAtIGMyKTtcbiAgICAgICAgICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgICAgICAgZGFyayA9ICFkYXJrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfbW9kdWxlc1tyb3ddW2NvbCAtIGMyXSA9IGRhcms7XG4gICAgICAgICAgICAgICAgYml0SW5kZXggLT0gMTtcbiAgICAgICAgICAgICAgICBpZiAoYml0SW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGJ5dGVJbmRleCArPSAxO1xuICAgICAgICAgICAgICAgICAgYml0SW5kZXggPSA3O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93ICs9IGluYztcbiAgICAgICAgICAgIGlmIChyb3cgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSByb3cpIHtcbiAgICAgICAgICAgICAgcm93IC09IGluYztcbiAgICAgICAgICAgICAgaW5jID0gLWluYztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGNyZWF0ZUJ5dGVzID0gZnVuY3Rpb24oYnVmZmVyLCByc0Jsb2Nrcykge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIG1heERjQ291bnQgPSAwO1xuICAgICAgICB2YXIgbWF4RWNDb3VudCA9IDA7XG4gICAgICAgIHZhciBkY2RhdGEgPSBuZXcgQXJyYXkocnNCbG9ja3MubGVuZ3RoKTtcbiAgICAgICAgdmFyIGVjZGF0YSA9IG5ldyBBcnJheShyc0Jsb2Nrcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgdmFyIGRjQ291bnQgPSByc0Jsb2Nrc1tyXS5kYXRhQ291bnQ7XG4gICAgICAgICAgdmFyIGVjQ291bnQgPSByc0Jsb2Nrc1tyXS50b3RhbENvdW50IC0gZGNDb3VudDtcbiAgICAgICAgICBtYXhEY0NvdW50ID0gTWF0aC5tYXgobWF4RGNDb3VudCwgZGNDb3VudCk7XG4gICAgICAgICAgbWF4RWNDb3VudCA9IE1hdGgubWF4KG1heEVjQ291bnQsIGVjQ291bnQpO1xuICAgICAgICAgIGRjZGF0YVtyXSA9IG5ldyBBcnJheShkY0NvdW50KTtcbiAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZGNkYXRhW3JdLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgICAgZGNkYXRhW3JdW2kyXSA9IDI1NSAmIGJ1ZmZlci5nZXRCdWZmZXIoKVtpMiArIG9mZnNldF07XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZnNldCArPSBkY0NvdW50O1xuICAgICAgICAgIHZhciByc1BvbHkgPSBRUlV0aWwuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbChlY0NvdW50KTtcbiAgICAgICAgICB2YXIgcmF3UG9seSA9IHFyUG9seW5vbWlhbChkY2RhdGFbcl0sIHJzUG9seS5nZXRMZW5ndGgoKSAtIDEpO1xuICAgICAgICAgIHZhciBtb2RQb2x5ID0gcmF3UG9seS5tb2QocnNQb2x5KTtcbiAgICAgICAgICBlY2RhdGFbcl0gPSBuZXcgQXJyYXkocnNQb2x5LmdldExlbmd0aCgpIC0gMSk7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGVjZGF0YVtyXS5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBtb2RJbmRleCA9IGkyICsgbW9kUG9seS5nZXRMZW5ndGgoKSAtIGVjZGF0YVtyXS5sZW5ndGg7XG4gICAgICAgICAgICBlY2RhdGFbcl1baTJdID0gbW9kSW5kZXggPj0gMCA/IG1vZFBvbHkuZ2V0QXQobW9kSW5kZXgpIDogMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRvdGFsQ29kZUNvdW50ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHJzQmxvY2tzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgIHRvdGFsQ29kZUNvdW50ICs9IHJzQmxvY2tzW2kyXS50b3RhbENvdW50O1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRhID0gbmV3IEFycmF5KHRvdGFsQ29kZUNvdW50KTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG1heERjQ291bnQ7IGkyICs9IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaTIgPCBkY2RhdGFbcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZGNkYXRhW3JdW2kyXTtcbiAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG1heEVjQ291bnQ7IGkyICs9IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJzQmxvY2tzLmxlbmd0aDsgciArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaTIgPCBlY2RhdGFbcl0ubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIGRhdGFbaW5kZXhdID0gZWNkYXRhW3JdW2kyXTtcbiAgICAgICAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9O1xuICAgICAgdmFyIGNyZWF0ZURhdGEgPSBmdW5jdGlvbih0eXBlTnVtYmVyMiwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwyLCBkYXRhTGlzdCkge1xuICAgICAgICB2YXIgcnNCbG9ja3MgPSBRUlJTQmxvY2suZ2V0UlNCbG9ja3ModHlwZU51bWJlcjIsIGVycm9yQ29ycmVjdGlvbkxldmVsMik7XG4gICAgICAgIHZhciBidWZmZXIgPSBxckJpdEJ1ZmZlcigpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZGF0YUxpc3QubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBkYXRhTGlzdFtpMl07XG4gICAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldE1vZGUoKSwgNCk7XG4gICAgICAgICAgYnVmZmVyLnB1dChkYXRhLmdldExlbmd0aCgpLCBRUlV0aWwuZ2V0TGVuZ3RoSW5CaXRzKGRhdGEuZ2V0TW9kZSgpLCB0eXBlTnVtYmVyMikpO1xuICAgICAgICAgIGRhdGEud3JpdGUoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdG90YWxEYXRhQ291bnQgPSAwO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcnNCbG9ja3MubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgdG90YWxEYXRhQ291bnQgKz0gcnNCbG9ja3NbaTJdLmRhdGFDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID4gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgICAgdGhyb3cgXCJjb2RlIGxlbmd0aCBvdmVyZmxvdy4gKFwiICsgYnVmZmVyLmdldExlbmd0aEluQml0cygpICsgXCI+XCIgKyB0b3RhbERhdGFDb3VudCAqIDggKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpICsgNCA8PSB0b3RhbERhdGFDb3VudCAqIDgpIHtcbiAgICAgICAgICBidWZmZXIucHV0KDAsIDQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgJSA4ICE9IDApIHtcbiAgICAgICAgICBidWZmZXIucHV0Qml0KGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGlmIChidWZmZXIuZ2V0TGVuZ3RoSW5CaXRzKCkgPj0gdG90YWxEYXRhQ291bnQgKiA4KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYnVmZmVyLnB1dChQQUQwLCA4KTtcbiAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpID49IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlci5wdXQoUEFEMSwgOCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ5dGVzKGJ1ZmZlciwgcnNCbG9ja3MpO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmFkZERhdGEgPSBmdW5jdGlvbihkYXRhLCBtb2RlKSB7XG4gICAgICAgIG1vZGUgPSBtb2RlIHx8IFwiQnl0ZVwiO1xuICAgICAgICB2YXIgbmV3RGF0YSA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgIGNhc2UgXCJOdW1lcmljXCI6XG4gICAgICAgICAgICBuZXdEYXRhID0gcXJOdW1iZXIoZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiQWxwaGFudW1lcmljXCI6XG4gICAgICAgICAgICBuZXdEYXRhID0gcXJBbHBoYU51bShkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJCeXRlXCI6XG4gICAgICAgICAgICBuZXdEYXRhID0gcXI4Qml0Qnl0ZShkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJLYW5qaVwiOlxuICAgICAgICAgICAgbmV3RGF0YSA9IHFyS2FuamkoZGF0YSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgXCJtb2RlOlwiICsgbW9kZTtcbiAgICAgICAgfVxuICAgICAgICBfZGF0YUxpc3QucHVzaChuZXdEYXRhKTtcbiAgICAgICAgX2RhdGFDYWNoZSA9IG51bGw7XG4gICAgICB9O1xuICAgICAgX3RoaXMuaXNEYXJrID0gZnVuY3Rpb24ocm93LCBjb2wpIHtcbiAgICAgICAgaWYgKHJvdyA8IDAgfHwgX21vZHVsZUNvdW50IDw9IHJvdyB8fCBjb2wgPCAwIHx8IF9tb2R1bGVDb3VudCA8PSBjb2wpIHtcbiAgICAgICAgICB0aHJvdyByb3cgKyBcIixcIiArIGNvbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX21vZHVsZXNbcm93XVtjb2xdO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmdldE1vZHVsZUNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbW9kdWxlQ291bnQ7XG4gICAgICB9O1xuICAgICAgX3RoaXMubWFrZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX3R5cGVOdW1iZXIgPCAxKSB7XG4gICAgICAgICAgdmFyIHR5cGVOdW1iZXIyID0gMTtcbiAgICAgICAgICBmb3IgKDsgdHlwZU51bWJlcjIgPCA0MDsgdHlwZU51bWJlcjIrKykge1xuICAgICAgICAgICAgdmFyIHJzQmxvY2tzID0gUVJSU0Jsb2NrLmdldFJTQmxvY2tzKHR5cGVOdW1iZXIyLCBfZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuICAgICAgICAgICAgdmFyIGJ1ZmZlciA9IHFyQml0QnVmZmVyKCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgX2RhdGFMaXN0Lmxlbmd0aDsgaTIrKykge1xuICAgICAgICAgICAgICB2YXIgZGF0YSA9IF9kYXRhTGlzdFtpMl07XG4gICAgICAgICAgICAgIGJ1ZmZlci5wdXQoZGF0YS5nZXRNb2RlKCksIDQpO1xuICAgICAgICAgICAgICBidWZmZXIucHV0KGRhdGEuZ2V0TGVuZ3RoKCksIFFSVXRpbC5nZXRMZW5ndGhJbkJpdHMoZGF0YS5nZXRNb2RlKCksIHR5cGVOdW1iZXIyKSk7XG4gICAgICAgICAgICAgIGRhdGEud3JpdGUoYnVmZmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciB0b3RhbERhdGFDb3VudCA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgcnNCbG9ja3MubGVuZ3RoOyBpMisrKSB7XG4gICAgICAgICAgICAgIHRvdGFsRGF0YUNvdW50ICs9IHJzQmxvY2tzW2kyXS5kYXRhQ291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYnVmZmVyLmdldExlbmd0aEluQml0cygpIDw9IHRvdGFsRGF0YUNvdW50ICogOCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgX3R5cGVOdW1iZXIgPSB0eXBlTnVtYmVyMjtcbiAgICAgICAgfVxuICAgICAgICBtYWtlSW1wbChmYWxzZSwgZ2V0QmVzdE1hc2tQYXR0ZXJuKCkpO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmNyZWF0ZVRhYmxlVGFnID0gZnVuY3Rpb24oY2VsbFNpemUsIG1hcmdpbikge1xuICAgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICAgIG1hcmdpbiA9IHR5cGVvZiBtYXJnaW4gPT0gXCJ1bmRlZmluZWRcIiA/IGNlbGxTaXplICogNCA6IG1hcmdpbjtcbiAgICAgICAgdmFyIHFySHRtbCA9IFwiXCI7XG4gICAgICAgIHFySHRtbCArPSAnPHRhYmxlIHN0eWxlPVwiJztcbiAgICAgICAgcXJIdG1sICs9IFwiIGJvcmRlci13aWR0aDogMHB4OyBib3JkZXItc3R5bGU6IG5vbmU7XCI7XG4gICAgICAgIHFySHRtbCArPSBcIiBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1wiO1xuICAgICAgICBxckh0bWwgKz0gXCIgcGFkZGluZzogMHB4OyBtYXJnaW46IFwiICsgbWFyZ2luICsgXCJweDtcIjtcbiAgICAgICAgcXJIdG1sICs9ICdcIj4nO1xuICAgICAgICBxckh0bWwgKz0gXCI8dGJvZHk+XCI7XG4gICAgICAgIGZvciAodmFyIHIgPSAwOyByIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgciArPSAxKSB7XG4gICAgICAgICAgcXJIdG1sICs9IFwiPHRyPlwiO1xuICAgICAgICAgIGZvciAodmFyIGMyID0gMDsgYzIgPCBfdGhpcy5nZXRNb2R1bGVDb3VudCgpOyBjMiArPSAxKSB7XG4gICAgICAgICAgICBxckh0bWwgKz0gJzx0ZCBzdHlsZT1cIic7XG4gICAgICAgICAgICBxckh0bWwgKz0gXCIgYm9yZGVyLXdpZHRoOiAwcHg7IGJvcmRlci1zdHlsZTogbm9uZTtcIjtcbiAgICAgICAgICAgIHFySHRtbCArPSBcIiBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlO1wiO1xuICAgICAgICAgICAgcXJIdG1sICs9IFwiIHBhZGRpbmc6IDBweDsgbWFyZ2luOiAwcHg7XCI7XG4gICAgICAgICAgICBxckh0bWwgKz0gXCIgd2lkdGg6IFwiICsgY2VsbFNpemUgKyBcInB4O1wiO1xuICAgICAgICAgICAgcXJIdG1sICs9IFwiIGhlaWdodDogXCIgKyBjZWxsU2l6ZSArIFwicHg7XCI7XG4gICAgICAgICAgICBxckh0bWwgKz0gXCIgYmFja2dyb3VuZC1jb2xvcjogXCI7XG4gICAgICAgICAgICBxckh0bWwgKz0gX3RoaXMuaXNEYXJrKHIsIGMyKSA/IFwiIzAwMDAwMFwiIDogXCIjZmZmZmZmXCI7XG4gICAgICAgICAgICBxckh0bWwgKz0gXCI7XCI7XG4gICAgICAgICAgICBxckh0bWwgKz0gJ1wiLz4nO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxckh0bWwgKz0gXCI8L3RyPlwiO1xuICAgICAgICB9XG4gICAgICAgIHFySHRtbCArPSBcIjwvdGJvZHk+XCI7XG4gICAgICAgIHFySHRtbCArPSBcIjwvdGFibGU+XCI7XG4gICAgICAgIHJldHVybiBxckh0bWw7XG4gICAgICB9O1xuICAgICAgX3RoaXMuY3JlYXRlU3ZnVGFnID0gZnVuY3Rpb24oY2VsbFNpemUsIG1hcmdpbiwgYWx0LCB0aXRsZSkge1xuICAgICAgICB2YXIgb3B0cyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1swXSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgb3B0cyA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICBjZWxsU2l6ZSA9IG9wdHMuY2VsbFNpemU7XG4gICAgICAgICAgbWFyZ2luID0gb3B0cy5tYXJnaW47XG4gICAgICAgICAgYWx0ID0gb3B0cy5hbHQ7XG4gICAgICAgICAgdGl0bGUgPSBvcHRzLnRpdGxlO1xuICAgICAgICB9XG4gICAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuICAgICAgICBhbHQgPSB0eXBlb2YgYWx0ID09PSBcInN0cmluZ1wiID8geyB0ZXh0OiBhbHQgfSA6IGFsdCB8fCB7fTtcbiAgICAgICAgYWx0LnRleHQgPSBhbHQudGV4dCB8fCBudWxsO1xuICAgICAgICBhbHQuaWQgPSBhbHQudGV4dCA/IGFsdC5pZCB8fCBcInFyY29kZS1kZXNjcmlwdGlvblwiIDogbnVsbDtcbiAgICAgICAgdGl0bGUgPSB0eXBlb2YgdGl0bGUgPT09IFwic3RyaW5nXCIgPyB7IHRleHQ6IHRpdGxlIH0gOiB0aXRsZSB8fCB7fTtcbiAgICAgICAgdGl0bGUudGV4dCA9IHRpdGxlLnRleHQgfHwgbnVsbDtcbiAgICAgICAgdGl0bGUuaWQgPSB0aXRsZS50ZXh0ID8gdGl0bGUuaWQgfHwgXCJxcmNvZGUtdGl0bGVcIiA6IG51bGw7XG4gICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgICAgdmFyIGMyLCBtYywgciwgbXIsIHFyU3ZnID0gXCJcIiwgcmVjdDtcbiAgICAgICAgcmVjdCA9IFwibFwiICsgY2VsbFNpemUgKyBcIiwwIDAsXCIgKyBjZWxsU2l6ZSArIFwiIC1cIiArIGNlbGxTaXplICsgXCIsMCAwLC1cIiArIGNlbGxTaXplICsgXCJ6IFwiO1xuICAgICAgICBxclN2ZyArPSAnPHN2ZyB2ZXJzaW9uPVwiMS4xXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJztcbiAgICAgICAgcXJTdmcgKz0gIW9wdHMuc2NhbGFibGUgPyAnIHdpZHRoPVwiJyArIHNpemUgKyAncHhcIiBoZWlnaHQ9XCInICsgc2l6ZSArICdweFwiJyA6IFwiXCI7XG4gICAgICAgIHFyU3ZnICs9ICcgdmlld0JveD1cIjAgMCAnICsgc2l6ZSArIFwiIFwiICsgc2l6ZSArICdcIiAnO1xuICAgICAgICBxclN2ZyArPSAnIHByZXNlcnZlQXNwZWN0UmF0aW89XCJ4TWluWU1pbiBtZWV0XCInO1xuICAgICAgICBxclN2ZyArPSB0aXRsZS50ZXh0IHx8IGFsdC50ZXh0ID8gJyByb2xlPVwiaW1nXCIgYXJpYS1sYWJlbGxlZGJ5PVwiJyArIGVzY2FwZVhtbChbdGl0bGUuaWQsIGFsdC5pZF0uam9pbihcIiBcIikudHJpbSgpKSArICdcIicgOiBcIlwiO1xuICAgICAgICBxclN2ZyArPSBcIj5cIjtcbiAgICAgICAgcXJTdmcgKz0gdGl0bGUudGV4dCA/ICc8dGl0bGUgaWQ9XCInICsgZXNjYXBlWG1sKHRpdGxlLmlkKSArICdcIj4nICsgZXNjYXBlWG1sKHRpdGxlLnRleHQpICsgXCI8L3RpdGxlPlwiIDogXCJcIjtcbiAgICAgICAgcXJTdmcgKz0gYWx0LnRleHQgPyAnPGRlc2NyaXB0aW9uIGlkPVwiJyArIGVzY2FwZVhtbChhbHQuaWQpICsgJ1wiPicgKyBlc2NhcGVYbWwoYWx0LnRleHQpICsgXCI8L2Rlc2NyaXB0aW9uPlwiIDogXCJcIjtcbiAgICAgICAgcXJTdmcgKz0gJzxyZWN0IHdpZHRoPVwiMTAwJVwiIGhlaWdodD1cIjEwMCVcIiBmaWxsPVwid2hpdGVcIiBjeD1cIjBcIiBjeT1cIjBcIi8+JztcbiAgICAgICAgcXJTdmcgKz0gJzxwYXRoIGQ9XCInO1xuICAgICAgICBmb3IgKHIgPSAwOyByIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgciArPSAxKSB7XG4gICAgICAgICAgbXIgPSByICogY2VsbFNpemUgKyBtYXJnaW47XG4gICAgICAgICAgZm9yIChjMiA9IDA7IGMyIDwgX3RoaXMuZ2V0TW9kdWxlQ291bnQoKTsgYzIgKz0gMSkge1xuICAgICAgICAgICAgaWYgKF90aGlzLmlzRGFyayhyLCBjMikpIHtcbiAgICAgICAgICAgICAgbWMgPSBjMiAqIGNlbGxTaXplICsgbWFyZ2luO1xuICAgICAgICAgICAgICBxclN2ZyArPSBcIk1cIiArIG1jICsgXCIsXCIgKyBtciArIHJlY3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHFyU3ZnICs9ICdcIiBzdHJva2U9XCJ0cmFuc3BhcmVudFwiIGZpbGw9XCJibGFja1wiLz4nO1xuICAgICAgICBxclN2ZyArPSBcIjwvc3ZnPlwiO1xuICAgICAgICByZXR1cm4gcXJTdmc7XG4gICAgICB9O1xuICAgICAgX3RoaXMuY3JlYXRlRGF0YVVSTCA9IGZ1bmN0aW9uKGNlbGxTaXplLCBtYXJnaW4pIHtcbiAgICAgICAgY2VsbFNpemUgPSBjZWxsU2l6ZSB8fCAyO1xuICAgICAgICBtYXJnaW4gPSB0eXBlb2YgbWFyZ2luID09IFwidW5kZWZpbmVkXCIgPyBjZWxsU2l6ZSAqIDQgOiBtYXJnaW47XG4gICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgICAgdmFyIG1pbjIgPSBtYXJnaW47XG4gICAgICAgIHZhciBtYXgyID0gc2l6ZSAtIG1hcmdpbjtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZURhdGFVUkwoc2l6ZSwgc2l6ZSwgZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICAgIGlmIChtaW4yIDw9IHggJiYgeCA8IG1heDIgJiYgbWluMiA8PSB5ICYmIHkgPCBtYXgyKSB7XG4gICAgICAgICAgICB2YXIgYzIgPSBNYXRoLmZsb29yKCh4IC0gbWluMikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgICB2YXIgciA9IE1hdGguZmxvb3IoKHkgLSBtaW4yKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5pc0RhcmsociwgYzIpID8gMCA6IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgX3RoaXMuY3JlYXRlSW1nVGFnID0gZnVuY3Rpb24oY2VsbFNpemUsIG1hcmdpbiwgYWx0KSB7XG4gICAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMjtcbiAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiA0IDogbWFyZ2luO1xuICAgICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICAgIHZhciBpbWcgPSBcIlwiO1xuICAgICAgICBpbWcgKz0gXCI8aW1nXCI7XG4gICAgICAgIGltZyArPSAnIHNyYz1cIic7XG4gICAgICAgIGltZyArPSBfdGhpcy5jcmVhdGVEYXRhVVJMKGNlbGxTaXplLCBtYXJnaW4pO1xuICAgICAgICBpbWcgKz0gJ1wiJztcbiAgICAgICAgaW1nICs9ICcgd2lkdGg9XCInO1xuICAgICAgICBpbWcgKz0gc2l6ZTtcbiAgICAgICAgaW1nICs9ICdcIic7XG4gICAgICAgIGltZyArPSAnIGhlaWdodD1cIic7XG4gICAgICAgIGltZyArPSBzaXplO1xuICAgICAgICBpbWcgKz0gJ1wiJztcbiAgICAgICAgaWYgKGFsdCkge1xuICAgICAgICAgIGltZyArPSAnIGFsdD1cIic7XG4gICAgICAgICAgaW1nICs9IGVzY2FwZVhtbChhbHQpO1xuICAgICAgICAgIGltZyArPSAnXCInO1xuICAgICAgICB9XG4gICAgICAgIGltZyArPSBcIi8+XCI7XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgICB9O1xuICAgICAgdmFyIGVzY2FwZVhtbCA9IGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgIHZhciBlc2NhcGVkID0gXCJcIjtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHMyLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgIHZhciBjMiA9IHMyLmNoYXJBdChpMik7XG4gICAgICAgICAgc3dpdGNoIChjMikge1xuICAgICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgICAgZXNjYXBlZCArPSBcIiZsdDtcIjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiPlwiOlxuICAgICAgICAgICAgICBlc2NhcGVkICs9IFwiJmd0O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCImXCI6XG4gICAgICAgICAgICAgIGVzY2FwZWQgKz0gXCImYW1wO1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgICAgICAgZXNjYXBlZCArPSBcIiZxdW90O1wiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGVzY2FwZWQgKz0gYzI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXNjYXBlZDtcbiAgICAgIH07XG4gICAgICB2YXIgX2NyZWF0ZUhhbGZBU0NJSSA9IGZ1bmN0aW9uKG1hcmdpbikge1xuICAgICAgICB2YXIgY2VsbFNpemUgPSAxO1xuICAgICAgICBtYXJnaW4gPSB0eXBlb2YgbWFyZ2luID09IFwidW5kZWZpbmVkXCIgPyBjZWxsU2l6ZSAqIDIgOiBtYXJnaW47XG4gICAgICAgIHZhciBzaXplID0gX3RoaXMuZ2V0TW9kdWxlQ291bnQoKSAqIGNlbGxTaXplICsgbWFyZ2luICogMjtcbiAgICAgICAgdmFyIG1pbjIgPSBtYXJnaW47XG4gICAgICAgIHZhciBtYXgyID0gc2l6ZSAtIG1hcmdpbjtcbiAgICAgICAgdmFyIHksIHgsIHIxLCByMiwgcDI7XG4gICAgICAgIHZhciBibG9ja3MgPSB7XG4gICAgICAgICAgXCJcXHUyNTg4XFx1MjU4OFwiOiBcIlxcdTI1ODhcIixcbiAgICAgICAgICBcIlxcdTI1ODggXCI6IFwiXFx1MjU4MFwiLFxuICAgICAgICAgIFwiIFxcdTI1ODhcIjogXCJcXHUyNTg0XCIsXG4gICAgICAgICAgXCIgIFwiOiBcIiBcIlxuICAgICAgICB9O1xuICAgICAgICB2YXIgYmxvY2tzTGFzdExpbmVOb01hcmdpbiA9IHtcbiAgICAgICAgICBcIlxcdTI1ODhcXHUyNTg4XCI6IFwiXFx1MjU4MFwiLFxuICAgICAgICAgIFwiXFx1MjU4OCBcIjogXCJcXHUyNTgwXCIsXG4gICAgICAgICAgXCIgXFx1MjU4OFwiOiBcIiBcIixcbiAgICAgICAgICBcIiAgXCI6IFwiIFwiXG4gICAgICAgIH07XG4gICAgICAgIHZhciBhc2NpaSA9IFwiXCI7XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBzaXplOyB5ICs9IDIpIHtcbiAgICAgICAgICByMSA9IE1hdGguZmxvb3IoKHkgLSBtaW4yKSAvIGNlbGxTaXplKTtcbiAgICAgICAgICByMiA9IE1hdGguZmxvb3IoKHkgKyAxIC0gbWluMikgLyBjZWxsU2l6ZSk7XG4gICAgICAgICAgZm9yICh4ID0gMDsgeCA8IHNpemU7IHggKz0gMSkge1xuICAgICAgICAgICAgcDIgPSBcIlxcdTI1ODhcIjtcbiAgICAgICAgICAgIGlmIChtaW4yIDw9IHggJiYgeCA8IG1heDIgJiYgbWluMiA8PSB5ICYmIHkgPCBtYXgyICYmIF90aGlzLmlzRGFyayhyMSwgTWF0aC5mbG9vcigoeCAtIG1pbjIpIC8gY2VsbFNpemUpKSkge1xuICAgICAgICAgICAgICBwMiA9IFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pbjIgPD0geCAmJiB4IDwgbWF4MiAmJiBtaW4yIDw9IHkgKyAxICYmIHkgKyAxIDwgbWF4MiAmJiBfdGhpcy5pc0RhcmsocjIsIE1hdGguZmxvb3IoKHggLSBtaW4yKSAvIGNlbGxTaXplKSkpIHtcbiAgICAgICAgICAgICAgcDIgKz0gXCIgXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwMiArPSBcIlxcdTI1ODhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzY2lpICs9IG1hcmdpbiA8IDEgJiYgeSArIDEgPj0gbWF4MiA/IGJsb2Nrc0xhc3RMaW5lTm9NYXJnaW5bcDJdIDogYmxvY2tzW3AyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXNjaWkgKz0gXCJcXG5cIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l6ZSAlIDIgJiYgbWFyZ2luID4gMCkge1xuICAgICAgICAgIHJldHVybiBhc2NpaS5zdWJzdHJpbmcoMCwgYXNjaWkubGVuZ3RoIC0gc2l6ZSAtIDEpICsgQXJyYXkoc2l6ZSArIDEpLmpvaW4oXCJcXHUyNTgwXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc2NpaS5zdWJzdHJpbmcoMCwgYXNjaWkubGVuZ3RoIC0gMSk7XG4gICAgICB9O1xuICAgICAgX3RoaXMuY3JlYXRlQVNDSUkgPSBmdW5jdGlvbihjZWxsU2l6ZSwgbWFyZ2luKSB7XG4gICAgICAgIGNlbGxTaXplID0gY2VsbFNpemUgfHwgMTtcbiAgICAgICAgaWYgKGNlbGxTaXplIDwgMikge1xuICAgICAgICAgIHJldHVybiBfY3JlYXRlSGFsZkFTQ0lJKG1hcmdpbik7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbFNpemUgLT0gMTtcbiAgICAgICAgbWFyZ2luID0gdHlwZW9mIG1hcmdpbiA9PSBcInVuZGVmaW5lZFwiID8gY2VsbFNpemUgKiAyIDogbWFyZ2luO1xuICAgICAgICB2YXIgc2l6ZSA9IF90aGlzLmdldE1vZHVsZUNvdW50KCkgKiBjZWxsU2l6ZSArIG1hcmdpbiAqIDI7XG4gICAgICAgIHZhciBtaW4yID0gbWFyZ2luO1xuICAgICAgICB2YXIgbWF4MiA9IHNpemUgLSBtYXJnaW47XG4gICAgICAgIHZhciB5LCB4LCByLCBwMjtcbiAgICAgICAgdmFyIHdoaXRlID0gQXJyYXkoY2VsbFNpemUgKyAxKS5qb2luKFwiXFx1MjU4OFxcdTI1ODhcIik7XG4gICAgICAgIHZhciBibGFjayA9IEFycmF5KGNlbGxTaXplICsgMSkuam9pbihcIiAgXCIpO1xuICAgICAgICB2YXIgYXNjaWkgPSBcIlwiO1xuICAgICAgICB2YXIgbGluZSA9IFwiXCI7XG4gICAgICAgIGZvciAoeSA9IDA7IHkgPCBzaXplOyB5ICs9IDEpIHtcbiAgICAgICAgICByID0gTWF0aC5mbG9vcigoeSAtIG1pbjIpIC8gY2VsbFNpemUpO1xuICAgICAgICAgIGxpbmUgPSBcIlwiO1xuICAgICAgICAgIGZvciAoeCA9IDA7IHggPCBzaXplOyB4ICs9IDEpIHtcbiAgICAgICAgICAgIHAyID0gMTtcbiAgICAgICAgICAgIGlmIChtaW4yIDw9IHggJiYgeCA8IG1heDIgJiYgbWluMiA8PSB5ICYmIHkgPCBtYXgyICYmIF90aGlzLmlzRGFyayhyLCBNYXRoLmZsb29yKCh4IC0gbWluMikgLyBjZWxsU2l6ZSkpKSB7XG4gICAgICAgICAgICAgIHAyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmUgKz0gcDIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKHIgPSAwOyByIDwgY2VsbFNpemU7IHIgKz0gMSkge1xuICAgICAgICAgICAgYXNjaWkgKz0gbGluZSArIFwiXFxuXCI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc2NpaS5zdWJzdHJpbmcoMCwgYXNjaWkubGVuZ3RoIC0gMSk7XG4gICAgICB9O1xuICAgICAgX3RoaXMucmVuZGVyVG8yZENvbnRleHQgPSBmdW5jdGlvbihjb250ZXh0LCBjZWxsU2l6ZSkge1xuICAgICAgICBjZWxsU2l6ZSA9IGNlbGxTaXplIHx8IDI7XG4gICAgICAgIHZhciBsZW5ndGggPSBfdGhpcy5nZXRNb2R1bGVDb3VudCgpO1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBsZW5ndGg7IHJvdysrKSB7XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbGVuZ3RoOyBjb2wrKykge1xuICAgICAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBfdGhpcy5pc0Rhcmsocm93LCBjb2wpID8gXCJibGFja1wiIDogXCJ3aGl0ZVwiO1xuICAgICAgICAgICAgY29udGV4dC5maWxsUmVjdChyb3cgKiBjZWxsU2l6ZSwgY29sICogY2VsbFNpemUsIGNlbGxTaXplLCBjZWxsU2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH07XG4gICAgcXJjb2RlMy5zdHJpbmdUb0J5dGVzRnVuY3MgPSB7XG4gICAgICBcImRlZmF1bHRcIjogZnVuY3Rpb24oczIpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzMi5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICB2YXIgYzIgPSBzMi5jaGFyQ29kZUF0KGkyKTtcbiAgICAgICAgICBieXRlcy5wdXNoKGMyICYgMjU1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgICB9XG4gICAgfTtcbiAgICBxcmNvZGUzLnN0cmluZ1RvQnl0ZXMgPSBxcmNvZGUzLnN0cmluZ1RvQnl0ZXNGdW5jc1tcImRlZmF1bHRcIl07XG4gICAgcXJjb2RlMy5jcmVhdGVTdHJpbmdUb0J5dGVzID0gZnVuY3Rpb24odW5pY29kZURhdGEsIG51bUNoYXJzKSB7XG4gICAgICB2YXIgdW5pY29kZU1hcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmluID0gYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW0odW5pY29kZURhdGEpO1xuICAgICAgICB2YXIgcmVhZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHZhciBiID0gYmluLnJlYWQoKTtcbiAgICAgICAgICBpZiAoYiA9PSAtMSlcbiAgICAgICAgICAgIHRocm93IFwiZW9mXCI7XG4gICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICAgIHZhciB1bmljb2RlTWFwMiA9IHt9O1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIHZhciBiMCA9IGJpbi5yZWFkKCk7XG4gICAgICAgICAgaWYgKGIwID09IC0xKVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgdmFyIGIxID0gcmVhZCgpO1xuICAgICAgICAgIHZhciBiMiA9IHJlYWQoKTtcbiAgICAgICAgICB2YXIgYjMgPSByZWFkKCk7XG4gICAgICAgICAgdmFyIGsgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGIwIDw8IDggfCBiMSk7XG4gICAgICAgICAgdmFyIHYgPSBiMiA8PCA4IHwgYjM7XG4gICAgICAgICAgdW5pY29kZU1hcDJba10gPSB2O1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ICE9IG51bUNoYXJzKSB7XG4gICAgICAgICAgdGhyb3cgY291bnQgKyBcIiAhPSBcIiArIG51bUNoYXJzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmljb2RlTWFwMjtcbiAgICAgIH0oKTtcbiAgICAgIHZhciB1bmtub3duQ2hhciA9IFwiP1wiLmNoYXJDb2RlQXQoMCk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oczIpIHtcbiAgICAgICAgdmFyIGJ5dGVzID0gW107XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBzMi5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgICB2YXIgYzIgPSBzMi5jaGFyQ29kZUF0KGkyKTtcbiAgICAgICAgICBpZiAoYzIgPCAxMjgpIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goYzIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgYiA9IHVuaWNvZGVNYXBbczIuY2hhckF0KGkyKV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGIgPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICBpZiAoKGIgJiAyNTUpID09IGIpIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJ5dGVzLnB1c2goYiA+Pj4gOCk7XG4gICAgICAgICAgICAgICAgYnl0ZXMucHVzaChiICYgMjU1KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYnl0ZXMucHVzaCh1bmtub3duQ2hhcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcztcbiAgICAgIH07XG4gICAgfTtcbiAgICB2YXIgUVJNb2RlID0ge1xuICAgICAgTU9ERV9OVU1CRVI6IDEgPDwgMCxcbiAgICAgIE1PREVfQUxQSEFfTlVNOiAxIDw8IDEsXG4gICAgICBNT0RFXzhCSVRfQllURTogMSA8PCAyLFxuICAgICAgTU9ERV9LQU5KSTogMSA8PCAzXG4gICAgfTtcbiAgICB2YXIgUVJFcnJvckNvcnJlY3Rpb25MZXZlbCA9IHtcbiAgICAgIEw6IDEsXG4gICAgICBNOiAwLFxuICAgICAgUTogMyxcbiAgICAgIEg6IDJcbiAgICB9O1xuICAgIHZhciBRUk1hc2tQYXR0ZXJuID0ge1xuICAgICAgUEFUVEVSTjAwMDogMCxcbiAgICAgIFBBVFRFUk4wMDE6IDEsXG4gICAgICBQQVRURVJOMDEwOiAyLFxuICAgICAgUEFUVEVSTjAxMTogMyxcbiAgICAgIFBBVFRFUk4xMDA6IDQsXG4gICAgICBQQVRURVJOMTAxOiA1LFxuICAgICAgUEFUVEVSTjExMDogNixcbiAgICAgIFBBVFRFUk4xMTE6IDdcbiAgICB9O1xuICAgIHZhciBRUlV0aWwgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBQQVRURVJOX1BPU0lUSU9OX1RBQkxFID0gW1xuICAgICAgICBbXSxcbiAgICAgICAgWzYsIDE4XSxcbiAgICAgICAgWzYsIDIyXSxcbiAgICAgICAgWzYsIDI2XSxcbiAgICAgICAgWzYsIDMwXSxcbiAgICAgICAgWzYsIDM0XSxcbiAgICAgICAgWzYsIDIyLCAzOF0sXG4gICAgICAgIFs2LCAyNCwgNDJdLFxuICAgICAgICBbNiwgMjYsIDQ2XSxcbiAgICAgICAgWzYsIDI4LCA1MF0sXG4gICAgICAgIFs2LCAzMCwgNTRdLFxuICAgICAgICBbNiwgMzIsIDU4XSxcbiAgICAgICAgWzYsIDM0LCA2Ml0sXG4gICAgICAgIFs2LCAyNiwgNDYsIDY2XSxcbiAgICAgICAgWzYsIDI2LCA0OCwgNzBdLFxuICAgICAgICBbNiwgMjYsIDUwLCA3NF0sXG4gICAgICAgIFs2LCAzMCwgNTQsIDc4XSxcbiAgICAgICAgWzYsIDMwLCA1NiwgODJdLFxuICAgICAgICBbNiwgMzAsIDU4LCA4Nl0sXG4gICAgICAgIFs2LCAzNCwgNjIsIDkwXSxcbiAgICAgICAgWzYsIDI4LCA1MCwgNzIsIDk0XSxcbiAgICAgICAgWzYsIDI2LCA1MCwgNzQsIDk4XSxcbiAgICAgICAgWzYsIDMwLCA1NCwgNzgsIDEwMl0sXG4gICAgICAgIFs2LCAyOCwgNTQsIDgwLCAxMDZdLFxuICAgICAgICBbNiwgMzIsIDU4LCA4NCwgMTEwXSxcbiAgICAgICAgWzYsIDMwLCA1OCwgODYsIDExNF0sXG4gICAgICAgIFs2LCAzNCwgNjIsIDkwLCAxMThdLFxuICAgICAgICBbNiwgMjYsIDUwLCA3NCwgOTgsIDEyMl0sXG4gICAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNl0sXG4gICAgICAgIFs2LCAyNiwgNTIsIDc4LCAxMDQsIDEzMF0sXG4gICAgICAgIFs2LCAzMCwgNTYsIDgyLCAxMDgsIDEzNF0sXG4gICAgICAgIFs2LCAzNCwgNjAsIDg2LCAxMTIsIDEzOF0sXG4gICAgICAgIFs2LCAzMCwgNTgsIDg2LCAxMTQsIDE0Ml0sXG4gICAgICAgIFs2LCAzNCwgNjIsIDkwLCAxMTgsIDE0Nl0sXG4gICAgICAgIFs2LCAzMCwgNTQsIDc4LCAxMDIsIDEyNiwgMTUwXSxcbiAgICAgICAgWzYsIDI0LCA1MCwgNzYsIDEwMiwgMTI4LCAxNTRdLFxuICAgICAgICBbNiwgMjgsIDU0LCA4MCwgMTA2LCAxMzIsIDE1OF0sXG4gICAgICAgIFs2LCAzMiwgNTgsIDg0LCAxMTAsIDEzNiwgMTYyXSxcbiAgICAgICAgWzYsIDI2LCA1NCwgODIsIDExMCwgMTM4LCAxNjZdLFxuICAgICAgICBbNiwgMzAsIDU4LCA4NiwgMTE0LCAxNDIsIDE3MF1cbiAgICAgIF07XG4gICAgICB2YXIgRzE1ID0gMSA8PCAxMCB8IDEgPDwgOCB8IDEgPDwgNSB8IDEgPDwgNCB8IDEgPDwgMiB8IDEgPDwgMSB8IDEgPDwgMDtcbiAgICAgIHZhciBHMTggPSAxIDw8IDEyIHwgMSA8PCAxMSB8IDEgPDwgMTAgfCAxIDw8IDkgfCAxIDw8IDggfCAxIDw8IDUgfCAxIDw8IDIgfCAxIDw8IDA7XG4gICAgICB2YXIgRzE1X01BU0sgPSAxIDw8IDE0IHwgMSA8PCAxMiB8IDEgPDwgMTAgfCAxIDw8IDQgfCAxIDw8IDE7XG4gICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgIHZhciBnZXRCQ0hEaWdpdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIGRpZ2l0ID0gMDtcbiAgICAgICAgd2hpbGUgKGRhdGEgIT0gMCkge1xuICAgICAgICAgIGRpZ2l0ICs9IDE7XG4gICAgICAgICAgZGF0YSA+Pj49IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRpZ2l0O1xuICAgICAgfTtcbiAgICAgIF90aGlzLmdldEJDSFR5cGVJbmZvID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB2YXIgZCA9IGRhdGEgPDwgMTA7XG4gICAgICAgIHdoaWxlIChnZXRCQ0hEaWdpdChkKSAtIGdldEJDSERpZ2l0KEcxNSkgPj0gMCkge1xuICAgICAgICAgIGQgXj0gRzE1IDw8IGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE1KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGRhdGEgPDwgMTAgfCBkKSBeIEcxNV9NQVNLO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmdldEJDSFR5cGVOdW1iZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBkID0gZGF0YSA8PCAxMjtcbiAgICAgICAgd2hpbGUgKGdldEJDSERpZ2l0KGQpIC0gZ2V0QkNIRGlnaXQoRzE4KSA+PSAwKSB7XG4gICAgICAgICAgZCBePSBHMTggPDwgZ2V0QkNIRGlnaXQoZCkgLSBnZXRCQ0hEaWdpdChHMTgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhIDw8IDEyIHwgZDtcbiAgICAgIH07XG4gICAgICBfdGhpcy5nZXRQYXR0ZXJuUG9zaXRpb24gPSBmdW5jdGlvbih0eXBlTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBQQVRURVJOX1BPU0lUSU9OX1RBQkxFW3R5cGVOdW1iZXIgLSAxXTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5nZXRNYXNrRnVuY3Rpb24gPSBmdW5jdGlvbihtYXNrUGF0dGVybikge1xuICAgICAgICBzd2l0Y2ggKG1hc2tQYXR0ZXJuKSB7XG4gICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4wMDA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaTIsIGopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChpMiArIGopICUgMiA9PSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAwMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICByZXR1cm4gaTIgJSAyID09IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMDEwOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgIHJldHVybiBqICUgMyA9PSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjAxMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICByZXR1cm4gKGkyICsgaikgJSAzID09IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTAwOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoTWF0aC5mbG9vcihpMiAvIDIpICsgTWF0aC5mbG9vcihqIC8gMykpICUgMiA9PSAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICBjYXNlIFFSTWFza1BhdHRlcm4uUEFUVEVSTjEwMTpcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbihpMiwgaikge1xuICAgICAgICAgICAgICByZXR1cm4gaTIgKiBqICUgMiArIGkyICogaiAlIDMgPT0gMDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSBRUk1hc2tQYXR0ZXJuLlBBVFRFUk4xMTA6XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oaTIsIGopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIChpMiAqIGogJSAyICsgaTIgKiBqICUgMykgJSAyID09IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGNhc2UgUVJNYXNrUGF0dGVybi5QQVRURVJOMTExOlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGkyLCBqKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoaTIgKiBqICUgMyArIChpMiArIGopICUgMikgJSAyID09IDA7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBcImJhZCBtYXNrUGF0dGVybjpcIiArIG1hc2tQYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0RXJyb3JDb3JyZWN0UG9seW5vbWlhbCA9IGZ1bmN0aW9uKGVycm9yQ29ycmVjdExlbmd0aCkge1xuICAgICAgICB2YXIgYTIgPSBxclBvbHlub21pYWwoWzFdLCAwKTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IGVycm9yQ29ycmVjdExlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgIGEyID0gYTIubXVsdGlwbHkocXJQb2x5bm9taWFsKFsxLCBRUk1hdGguZ2V4cChpMildLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEyO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmdldExlbmd0aEluQml0cyA9IGZ1bmN0aW9uKG1vZGUsIHR5cGUpIHtcbiAgICAgICAgaWYgKDEgPD0gdHlwZSAmJiB0eXBlIDwgMTApIHtcbiAgICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfTlVNQkVSOlxuICAgICAgICAgICAgICByZXR1cm4gMTA7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0FMUEhBX05VTTpcbiAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcbiAgICAgICAgICAgICAgcmV0dXJuIDg7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJOlxuICAgICAgICAgICAgICByZXR1cm4gODtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IFwibW9kZTpcIiArIG1vZGU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPCAyNykge1xuICAgICAgICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9OVU1CRVI6XG4gICAgICAgICAgICAgIHJldHVybiAxMjtcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfQUxQSEFfTlVNOlxuICAgICAgICAgICAgICByZXR1cm4gMTE7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFXzhCSVRfQllURTpcbiAgICAgICAgICAgICAgcmV0dXJuIDE2O1xuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9LQU5KSTpcbiAgICAgICAgICAgICAgcmV0dXJuIDEwO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGhyb3cgXCJtb2RlOlwiICsgbW9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA8IDQxKSB7XG4gICAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX05VTUJFUjpcbiAgICAgICAgICAgICAgcmV0dXJuIDE0O1xuICAgICAgICAgICAgY2FzZSBRUk1vZGUuTU9ERV9BTFBIQV9OVU06XG4gICAgICAgICAgICAgIHJldHVybiAxMztcbiAgICAgICAgICAgIGNhc2UgUVJNb2RlLk1PREVfOEJJVF9CWVRFOlxuICAgICAgICAgICAgICByZXR1cm4gMTY7XG4gICAgICAgICAgICBjYXNlIFFSTW9kZS5NT0RFX0tBTkpJOlxuICAgICAgICAgICAgICByZXR1cm4gMTI7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBcIm1vZGU6XCIgKyBtb2RlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcInR5cGU6XCIgKyB0eXBlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0TG9zdFBvaW50ID0gZnVuY3Rpb24ocXJjb2RlNCkge1xuICAgICAgICB2YXIgbW9kdWxlQ291bnQgPSBxcmNvZGU0LmdldE1vZHVsZUNvdW50KCk7XG4gICAgICAgIHZhciBsb3N0UG9pbnQgPSAwO1xuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudDsgcm93ICs9IDEpIHtcbiAgICAgICAgICBmb3IgKHZhciBjb2wgPSAwOyBjb2wgPCBtb2R1bGVDb3VudDsgY29sICs9IDEpIHtcbiAgICAgICAgICAgIHZhciBzYW1lQ291bnQgPSAwO1xuICAgICAgICAgICAgdmFyIGRhcmsgPSBxcmNvZGU0LmlzRGFyayhyb3csIGNvbCk7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gLTE7IHIgPD0gMTsgciArPSAxKSB7XG4gICAgICAgICAgICAgIGlmIChyb3cgKyByIDwgMCB8fCBtb2R1bGVDb3VudCA8PSByb3cgKyByKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZm9yICh2YXIgYzIgPSAtMTsgYzIgPD0gMTsgYzIgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChjb2wgKyBjMiA8IDAgfHwgbW9kdWxlQ291bnQgPD0gY29sICsgYzIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAociA9PSAwICYmIGMyID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGFyayA9PSBxcmNvZGU0LmlzRGFyayhyb3cgKyByLCBjb2wgKyBjMikpIHtcbiAgICAgICAgICAgICAgICAgIHNhbWVDb3VudCArPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNhbWVDb3VudCA+IDUpIHtcbiAgICAgICAgICAgICAgbG9zdFBvaW50ICs9IDMgKyBzYW1lQ291bnQgLSA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciByb3cgPSAwOyByb3cgPCBtb2R1bGVDb3VudCAtIDE7IHJvdyArPSAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQgLSAxOyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgIGlmIChxcmNvZGU0LmlzRGFyayhyb3csIGNvbCkpXG4gICAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBpZiAocXJjb2RlNC5pc0Rhcmsocm93ICsgMSwgY29sKSlcbiAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgIGlmIChxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDEpKVxuICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdyArIDEsIGNvbCArIDEpKVxuICAgICAgICAgICAgICBjb3VudCArPSAxO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09IDAgfHwgY291bnQgPT0gNCkge1xuICAgICAgICAgICAgICBsb3N0UG9pbnQgKz0gMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQ7IHJvdyArPSAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQgLSA2OyBjb2wgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdywgY29sKSAmJiAhcXJjb2RlNC5pc0Rhcmsocm93LCBjb2wgKyAxKSAmJiBxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDIpICYmIHFyY29kZTQuaXNEYXJrKHJvdywgY29sICsgMykgJiYgcXJjb2RlNC5pc0Rhcmsocm93LCBjb2wgKyA0KSAmJiAhcXJjb2RlNC5pc0Rhcmsocm93LCBjb2wgKyA1KSAmJiBxcmNvZGU0LmlzRGFyayhyb3csIGNvbCArIDYpKSB7XG4gICAgICAgICAgICAgIGxvc3RQb2ludCArPSA0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgY29sID0gMDsgY29sIDwgbW9kdWxlQ291bnQ7IGNvbCArPSAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgcm93ID0gMDsgcm93IDwgbW9kdWxlQ291bnQgLSA2OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdywgY29sKSAmJiAhcXJjb2RlNC5pc0Rhcmsocm93ICsgMSwgY29sKSAmJiBxcmNvZGU0LmlzRGFyayhyb3cgKyAyLCBjb2wpICYmIHFyY29kZTQuaXNEYXJrKHJvdyArIDMsIGNvbCkgJiYgcXJjb2RlNC5pc0Rhcmsocm93ICsgNCwgY29sKSAmJiAhcXJjb2RlNC5pc0Rhcmsocm93ICsgNSwgY29sKSAmJiBxcmNvZGU0LmlzRGFyayhyb3cgKyA2LCBjb2wpKSB7XG4gICAgICAgICAgICAgIGxvc3RQb2ludCArPSA0MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhcmtDb3VudCA9IDA7XG4gICAgICAgIGZvciAodmFyIGNvbCA9IDA7IGNvbCA8IG1vZHVsZUNvdW50OyBjb2wgKz0gMSkge1xuICAgICAgICAgIGZvciAodmFyIHJvdyA9IDA7IHJvdyA8IG1vZHVsZUNvdW50OyByb3cgKz0gMSkge1xuICAgICAgICAgICAgaWYgKHFyY29kZTQuaXNEYXJrKHJvdywgY29sKSkge1xuICAgICAgICAgICAgICBkYXJrQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJhdGlvID0gTWF0aC5hYnMoMTAwICogZGFya0NvdW50IC8gbW9kdWxlQ291bnQgLyBtb2R1bGVDb3VudCAtIDUwKSAvIDU7XG4gICAgICAgIGxvc3RQb2ludCArPSByYXRpbyAqIDEwO1xuICAgICAgICByZXR1cm4gbG9zdFBvaW50O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9KCk7XG4gICAgdmFyIFFSTWF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIEVYUF9UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgdmFyIExPR19UQUJMRSA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IDg7IGkyICs9IDEpIHtcbiAgICAgICAgRVhQX1RBQkxFW2kyXSA9IDEgPDwgaTI7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpMiA9IDg7IGkyIDwgMjU2OyBpMiArPSAxKSB7XG4gICAgICAgIEVYUF9UQUJMRVtpMl0gPSBFWFBfVEFCTEVbaTIgLSA0XSBeIEVYUF9UQUJMRVtpMiAtIDVdIF4gRVhQX1RBQkxFW2kyIC0gNl0gXiBFWFBfVEFCTEVbaTIgLSA4XTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCAyNTU7IGkyICs9IDEpIHtcbiAgICAgICAgTE9HX1RBQkxFW0VYUF9UQUJMRVtpMl1dID0gaTI7XG4gICAgICB9XG4gICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgIF90aGlzLmdsb2cgPSBmdW5jdGlvbihuMikge1xuICAgICAgICBpZiAobjIgPCAxKSB7XG4gICAgICAgICAgdGhyb3cgXCJnbG9nKFwiICsgbjIgKyBcIilcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTE9HX1RBQkxFW24yXTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5nZXhwID0gZnVuY3Rpb24objIpIHtcbiAgICAgICAgd2hpbGUgKG4yIDwgMCkge1xuICAgICAgICAgIG4yICs9IDI1NTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAobjIgPj0gMjU2KSB7XG4gICAgICAgICAgbjIgLT0gMjU1O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFWFBfVEFCTEVbbjJdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9KCk7XG4gICAgZnVuY3Rpb24gcXJQb2x5bm9taWFsKG51bSwgc2hpZnQpIHtcbiAgICAgIGlmICh0eXBlb2YgbnVtLmxlbmd0aCA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG51bS5sZW5ndGggKyBcIi9cIiArIHNoaWZ0O1xuICAgICAgfVxuICAgICAgdmFyIF9udW0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBudW0ubGVuZ3RoICYmIG51bVtvZmZzZXRdID09IDApIHtcbiAgICAgICAgICBvZmZzZXQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX251bTIgPSBuZXcgQXJyYXkobnVtLmxlbmd0aCAtIG9mZnNldCArIHNoaWZ0KTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IG51bS5sZW5ndGggLSBvZmZzZXQ7IGkyICs9IDEpIHtcbiAgICAgICAgICBfbnVtMltpMl0gPSBudW1baTIgKyBvZmZzZXRdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfbnVtMjtcbiAgICAgIH0oKTtcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgX3RoaXMuZ2V0QXQgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gX251bVtpbmRleF07XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbnVtLmxlbmd0aDtcbiAgICAgIH07XG4gICAgICBfdGhpcy5tdWx0aXBseSA9IGZ1bmN0aW9uKGUyKSB7XG4gICAgICAgIHZhciBudW0yID0gbmV3IEFycmF5KF90aGlzLmdldExlbmd0aCgpICsgZTIuZ2V0TGVuZ3RoKCkgLSAxKTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IF90aGlzLmdldExlbmd0aCgpOyBpMiArPSAxKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBlMi5nZXRMZW5ndGgoKTsgaiArPSAxKSB7XG4gICAgICAgICAgICBudW0yW2kyICsgal0gXj0gUVJNYXRoLmdleHAoUVJNYXRoLmdsb2coX3RoaXMuZ2V0QXQoaTIpKSArIFFSTWF0aC5nbG9nKGUyLmdldEF0KGopKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxclBvbHlub21pYWwobnVtMiwgMCk7XG4gICAgICB9O1xuICAgICAgX3RoaXMubW9kID0gZnVuY3Rpb24oZTIpIHtcbiAgICAgICAgaWYgKF90aGlzLmdldExlbmd0aCgpIC0gZTIuZ2V0TGVuZ3RoKCkgPCAwKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG4gICAgICAgIHZhciByYXRpbyA9IFFSTWF0aC5nbG9nKF90aGlzLmdldEF0KDApKSAtIFFSTWF0aC5nbG9nKGUyLmdldEF0KDApKTtcbiAgICAgICAgdmFyIG51bTIgPSBuZXcgQXJyYXkoX3RoaXMuZ2V0TGVuZ3RoKCkpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgX3RoaXMuZ2V0TGVuZ3RoKCk7IGkyICs9IDEpIHtcbiAgICAgICAgICBudW0yW2kyXSA9IF90aGlzLmdldEF0KGkyKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgZTIuZ2V0TGVuZ3RoKCk7IGkyICs9IDEpIHtcbiAgICAgICAgICBudW0yW2kyXSBePSBRUk1hdGguZ2V4cChRUk1hdGguZ2xvZyhlMi5nZXRBdChpMikpICsgcmF0aW8pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBxclBvbHlub21pYWwobnVtMiwgMCkubW9kKGUyKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIHZhciBRUlJTQmxvY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBSU19CTE9DS19UQUJMRSA9IFtcbiAgICAgICAgWzEsIDI2LCAxOV0sXG4gICAgICAgIFsxLCAyNiwgMTZdLFxuICAgICAgICBbMSwgMjYsIDEzXSxcbiAgICAgICAgWzEsIDI2LCA5XSxcbiAgICAgICAgWzEsIDQ0LCAzNF0sXG4gICAgICAgIFsxLCA0NCwgMjhdLFxuICAgICAgICBbMSwgNDQsIDIyXSxcbiAgICAgICAgWzEsIDQ0LCAxNl0sXG4gICAgICAgIFsxLCA3MCwgNTVdLFxuICAgICAgICBbMSwgNzAsIDQ0XSxcbiAgICAgICAgWzIsIDM1LCAxN10sXG4gICAgICAgIFsyLCAzNSwgMTNdLFxuICAgICAgICBbMSwgMTAwLCA4MF0sXG4gICAgICAgIFsyLCA1MCwgMzJdLFxuICAgICAgICBbMiwgNTAsIDI0XSxcbiAgICAgICAgWzQsIDI1LCA5XSxcbiAgICAgICAgWzEsIDEzNCwgMTA4XSxcbiAgICAgICAgWzIsIDY3LCA0M10sXG4gICAgICAgIFsyLCAzMywgMTUsIDIsIDM0LCAxNl0sXG4gICAgICAgIFsyLCAzMywgMTEsIDIsIDM0LCAxMl0sXG4gICAgICAgIFsyLCA4NiwgNjhdLFxuICAgICAgICBbNCwgNDMsIDI3XSxcbiAgICAgICAgWzQsIDQzLCAxOV0sXG4gICAgICAgIFs0LCA0MywgMTVdLFxuICAgICAgICBbMiwgOTgsIDc4XSxcbiAgICAgICAgWzQsIDQ5LCAzMV0sXG4gICAgICAgIFsyLCAzMiwgMTQsIDQsIDMzLCAxNV0sXG4gICAgICAgIFs0LCAzOSwgMTMsIDEsIDQwLCAxNF0sXG4gICAgICAgIFsyLCAxMjEsIDk3XSxcbiAgICAgICAgWzIsIDYwLCAzOCwgMiwgNjEsIDM5XSxcbiAgICAgICAgWzQsIDQwLCAxOCwgMiwgNDEsIDE5XSxcbiAgICAgICAgWzQsIDQwLCAxNCwgMiwgNDEsIDE1XSxcbiAgICAgICAgWzIsIDE0NiwgMTE2XSxcbiAgICAgICAgWzMsIDU4LCAzNiwgMiwgNTksIDM3XSxcbiAgICAgICAgWzQsIDM2LCAxNiwgNCwgMzcsIDE3XSxcbiAgICAgICAgWzQsIDM2LCAxMiwgNCwgMzcsIDEzXSxcbiAgICAgICAgWzIsIDg2LCA2OCwgMiwgODcsIDY5XSxcbiAgICAgICAgWzQsIDY5LCA0MywgMSwgNzAsIDQ0XSxcbiAgICAgICAgWzYsIDQzLCAxOSwgMiwgNDQsIDIwXSxcbiAgICAgICAgWzYsIDQzLCAxNSwgMiwgNDQsIDE2XSxcbiAgICAgICAgWzQsIDEwMSwgODFdLFxuICAgICAgICBbMSwgODAsIDUwLCA0LCA4MSwgNTFdLFxuICAgICAgICBbNCwgNTAsIDIyLCA0LCA1MSwgMjNdLFxuICAgICAgICBbMywgMzYsIDEyLCA4LCAzNywgMTNdLFxuICAgICAgICBbMiwgMTE2LCA5MiwgMiwgMTE3LCA5M10sXG4gICAgICAgIFs2LCA1OCwgMzYsIDIsIDU5LCAzN10sXG4gICAgICAgIFs0LCA0NiwgMjAsIDYsIDQ3LCAyMV0sXG4gICAgICAgIFs3LCA0MiwgMTQsIDQsIDQzLCAxNV0sXG4gICAgICAgIFs0LCAxMzMsIDEwN10sXG4gICAgICAgIFs4LCA1OSwgMzcsIDEsIDYwLCAzOF0sXG4gICAgICAgIFs4LCA0NCwgMjAsIDQsIDQ1LCAyMV0sXG4gICAgICAgIFsxMiwgMzMsIDExLCA0LCAzNCwgMTJdLFxuICAgICAgICBbMywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSxcbiAgICAgICAgWzQsIDY0LCA0MCwgNSwgNjUsIDQxXSxcbiAgICAgICAgWzExLCAzNiwgMTYsIDUsIDM3LCAxN10sXG4gICAgICAgIFsxMSwgMzYsIDEyLCA1LCAzNywgMTNdLFxuICAgICAgICBbNSwgMTA5LCA4NywgMSwgMTEwLCA4OF0sXG4gICAgICAgIFs1LCA2NSwgNDEsIDUsIDY2LCA0Ml0sXG4gICAgICAgIFs1LCA1NCwgMjQsIDcsIDU1LCAyNV0sXG4gICAgICAgIFsxMSwgMzYsIDEyLCA3LCAzNywgMTNdLFxuICAgICAgICBbNSwgMTIyLCA5OCwgMSwgMTIzLCA5OV0sXG4gICAgICAgIFs3LCA3MywgNDUsIDMsIDc0LCA0Nl0sXG4gICAgICAgIFsxNSwgNDMsIDE5LCAyLCA0NCwgMjBdLFxuICAgICAgICBbMywgNDUsIDE1LCAxMywgNDYsIDE2XSxcbiAgICAgICAgWzEsIDEzNSwgMTA3LCA1LCAxMzYsIDEwOF0sXG4gICAgICAgIFsxMCwgNzQsIDQ2LCAxLCA3NSwgNDddLFxuICAgICAgICBbMSwgNTAsIDIyLCAxNSwgNTEsIDIzXSxcbiAgICAgICAgWzIsIDQyLCAxNCwgMTcsIDQzLCAxNV0sXG4gICAgICAgIFs1LCAxNTAsIDEyMCwgMSwgMTUxLCAxMjFdLFxuICAgICAgICBbOSwgNjksIDQzLCA0LCA3MCwgNDRdLFxuICAgICAgICBbMTcsIDUwLCAyMiwgMSwgNTEsIDIzXSxcbiAgICAgICAgWzIsIDQyLCAxNCwgMTksIDQzLCAxNV0sXG4gICAgICAgIFszLCAxNDEsIDExMywgNCwgMTQyLCAxMTRdLFxuICAgICAgICBbMywgNzAsIDQ0LCAxMSwgNzEsIDQ1XSxcbiAgICAgICAgWzE3LCA0NywgMjEsIDQsIDQ4LCAyMl0sXG4gICAgICAgIFs5LCAzOSwgMTMsIDE2LCA0MCwgMTRdLFxuICAgICAgICBbMywgMTM1LCAxMDcsIDUsIDEzNiwgMTA4XSxcbiAgICAgICAgWzMsIDY3LCA0MSwgMTMsIDY4LCA0Ml0sXG4gICAgICAgIFsxNSwgNTQsIDI0LCA1LCA1NSwgMjVdLFxuICAgICAgICBbMTUsIDQzLCAxNSwgMTAsIDQ0LCAxNl0sXG4gICAgICAgIFs0LCAxNDQsIDExNiwgNCwgMTQ1LCAxMTddLFxuICAgICAgICBbMTcsIDY4LCA0Ml0sXG4gICAgICAgIFsxNywgNTAsIDIyLCA2LCA1MSwgMjNdLFxuICAgICAgICBbMTksIDQ2LCAxNiwgNiwgNDcsIDE3XSxcbiAgICAgICAgWzIsIDEzOSwgMTExLCA3LCAxNDAsIDExMl0sXG4gICAgICAgIFsxNywgNzQsIDQ2XSxcbiAgICAgICAgWzcsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICAgIFszNCwgMzcsIDEzXSxcbiAgICAgICAgWzQsIDE1MSwgMTIxLCA1LCAxNTIsIDEyMl0sXG4gICAgICAgIFs0LCA3NSwgNDcsIDE0LCA3NiwgNDhdLFxuICAgICAgICBbMTEsIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG4gICAgICAgIFsxNiwgNDUsIDE1LCAxNCwgNDYsIDE2XSxcbiAgICAgICAgWzYsIDE0NywgMTE3LCA0LCAxNDgsIDExOF0sXG4gICAgICAgIFs2LCA3MywgNDUsIDE0LCA3NCwgNDZdLFxuICAgICAgICBbMTEsIDU0LCAyNCwgMTYsIDU1LCAyNV0sXG4gICAgICAgIFszMCwgNDYsIDE2LCAyLCA0NywgMTddLFxuICAgICAgICBbOCwgMTMyLCAxMDYsIDQsIDEzMywgMTA3XSxcbiAgICAgICAgWzgsIDc1LCA0NywgMTMsIDc2LCA0OF0sXG4gICAgICAgIFs3LCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgICBbMjIsIDQ1LCAxNSwgMTMsIDQ2LCAxNl0sXG4gICAgICAgIFsxMCwgMTQyLCAxMTQsIDIsIDE0MywgMTE1XSxcbiAgICAgICAgWzE5LCA3NCwgNDYsIDQsIDc1LCA0N10sXG4gICAgICAgIFsyOCwgNTAsIDIyLCA2LCA1MSwgMjNdLFxuICAgICAgICBbMzMsIDQ2LCAxNiwgNCwgNDcsIDE3XSxcbiAgICAgICAgWzgsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sXG4gICAgICAgIFsyMiwgNzMsIDQ1LCAzLCA3NCwgNDZdLFxuICAgICAgICBbOCwgNTMsIDIzLCAyNiwgNTQsIDI0XSxcbiAgICAgICAgWzEyLCA0NSwgMTUsIDI4LCA0NiwgMTZdLFxuICAgICAgICBbMywgMTQ3LCAxMTcsIDEwLCAxNDgsIDExOF0sXG4gICAgICAgIFszLCA3MywgNDUsIDIzLCA3NCwgNDZdLFxuICAgICAgICBbNCwgNTQsIDI0LCAzMSwgNTUsIDI1XSxcbiAgICAgICAgWzExLCA0NSwgMTUsIDMxLCA0NiwgMTZdLFxuICAgICAgICBbNywgMTQ2LCAxMTYsIDcsIDE0NywgMTE3XSxcbiAgICAgICAgWzIxLCA3MywgNDUsIDcsIDc0LCA0Nl0sXG4gICAgICAgIFsxLCA1MywgMjMsIDM3LCA1NCwgMjRdLFxuICAgICAgICBbMTksIDQ1LCAxNSwgMjYsIDQ2LCAxNl0sXG4gICAgICAgIFs1LCAxNDUsIDExNSwgMTAsIDE0NiwgMTE2XSxcbiAgICAgICAgWzE5LCA3NSwgNDcsIDEwLCA3NiwgNDhdLFxuICAgICAgICBbMTUsIDU0LCAyNCwgMjUsIDU1LCAyNV0sXG4gICAgICAgIFsyMywgNDUsIDE1LCAyNSwgNDYsIDE2XSxcbiAgICAgICAgWzEzLCAxNDUsIDExNSwgMywgMTQ2LCAxMTZdLFxuICAgICAgICBbMiwgNzQsIDQ2LCAyOSwgNzUsIDQ3XSxcbiAgICAgICAgWzQyLCA1NCwgMjQsIDEsIDU1LCAyNV0sXG4gICAgICAgIFsyMywgNDUsIDE1LCAyOCwgNDYsIDE2XSxcbiAgICAgICAgWzE3LCAxNDUsIDExNV0sXG4gICAgICAgIFsxMCwgNzQsIDQ2LCAyMywgNzUsIDQ3XSxcbiAgICAgICAgWzEwLCA1NCwgMjQsIDM1LCA1NSwgMjVdLFxuICAgICAgICBbMTksIDQ1LCAxNSwgMzUsIDQ2LCAxNl0sXG4gICAgICAgIFsxNywgMTQ1LCAxMTUsIDEsIDE0NiwgMTE2XSxcbiAgICAgICAgWzE0LCA3NCwgNDYsIDIxLCA3NSwgNDddLFxuICAgICAgICBbMjksIDU0LCAyNCwgMTksIDU1LCAyNV0sXG4gICAgICAgIFsxMSwgNDUsIDE1LCA0NiwgNDYsIDE2XSxcbiAgICAgICAgWzEzLCAxNDUsIDExNSwgNiwgMTQ2LCAxMTZdLFxuICAgICAgICBbMTQsIDc0LCA0NiwgMjMsIDc1LCA0N10sXG4gICAgICAgIFs0NCwgNTQsIDI0LCA3LCA1NSwgMjVdLFxuICAgICAgICBbNTksIDQ2LCAxNiwgMSwgNDcsIDE3XSxcbiAgICAgICAgWzEyLCAxNTEsIDEyMSwgNywgMTUyLCAxMjJdLFxuICAgICAgICBbMTIsIDc1LCA0NywgMjYsIDc2LCA0OF0sXG4gICAgICAgIFszOSwgNTQsIDI0LCAxNCwgNTUsIDI1XSxcbiAgICAgICAgWzIyLCA0NSwgMTUsIDQxLCA0NiwgMTZdLFxuICAgICAgICBbNiwgMTUxLCAxMjEsIDE0LCAxNTIsIDEyMl0sXG4gICAgICAgIFs2LCA3NSwgNDcsIDM0LCA3NiwgNDhdLFxuICAgICAgICBbNDYsIDU0LCAyNCwgMTAsIDU1LCAyNV0sXG4gICAgICAgIFsyLCA0NSwgMTUsIDY0LCA0NiwgMTZdLFxuICAgICAgICBbMTcsIDE1MiwgMTIyLCA0LCAxNTMsIDEyM10sXG4gICAgICAgIFsyOSwgNzQsIDQ2LCAxNCwgNzUsIDQ3XSxcbiAgICAgICAgWzQ5LCA1NCwgMjQsIDEwLCA1NSwgMjVdLFxuICAgICAgICBbMjQsIDQ1LCAxNSwgNDYsIDQ2LCAxNl0sXG4gICAgICAgIFs0LCAxNTIsIDEyMiwgMTgsIDE1MywgMTIzXSxcbiAgICAgICAgWzEzLCA3NCwgNDYsIDMyLCA3NSwgNDddLFxuICAgICAgICBbNDgsIDU0LCAyNCwgMTQsIDU1LCAyNV0sXG4gICAgICAgIFs0MiwgNDUsIDE1LCAzMiwgNDYsIDE2XSxcbiAgICAgICAgWzIwLCAxNDcsIDExNywgNCwgMTQ4LCAxMThdLFxuICAgICAgICBbNDAsIDc1LCA0NywgNywgNzYsIDQ4XSxcbiAgICAgICAgWzQzLCA1NCwgMjQsIDIyLCA1NSwgMjVdLFxuICAgICAgICBbMTAsIDQ1LCAxNSwgNjcsIDQ2LCAxNl0sXG4gICAgICAgIFsxOSwgMTQ4LCAxMTgsIDYsIDE0OSwgMTE5XSxcbiAgICAgICAgWzE4LCA3NSwgNDcsIDMxLCA3NiwgNDhdLFxuICAgICAgICBbMzQsIDU0LCAyNCwgMzQsIDU1LCAyNV0sXG4gICAgICAgIFsyMCwgNDUsIDE1LCA2MSwgNDYsIDE2XVxuICAgICAgXTtcbiAgICAgIHZhciBxclJTQmxvY2sgPSBmdW5jdGlvbih0b3RhbENvdW50LCBkYXRhQ291bnQpIHtcbiAgICAgICAgdmFyIF90aGlzMiA9IHt9O1xuICAgICAgICBfdGhpczIudG90YWxDb3VudCA9IHRvdGFsQ291bnQ7XG4gICAgICAgIF90aGlzMi5kYXRhQ291bnQgPSBkYXRhQ291bnQ7XG4gICAgICAgIHJldHVybiBfdGhpczI7XG4gICAgICB9O1xuICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICB2YXIgZ2V0UnNCbG9ja1RhYmxlID0gZnVuY3Rpb24odHlwZU51bWJlciwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpIHtcbiAgICAgICAgc3dpdGNoIChlcnJvckNvcnJlY3Rpb25MZXZlbCkge1xuICAgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5MOlxuICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgMF07XG4gICAgICAgICAgY2FzZSBRUkVycm9yQ29ycmVjdGlvbkxldmVsLk06XG4gICAgICAgICAgICByZXR1cm4gUlNfQkxPQ0tfVEFCTEVbKHR5cGVOdW1iZXIgLSAxKSAqIDQgKyAxXTtcbiAgICAgICAgICBjYXNlIFFSRXJyb3JDb3JyZWN0aW9uTGV2ZWwuUTpcbiAgICAgICAgICAgIHJldHVybiBSU19CTE9DS19UQUJMRVsodHlwZU51bWJlciAtIDEpICogNCArIDJdO1xuICAgICAgICAgIGNhc2UgUVJFcnJvckNvcnJlY3Rpb25MZXZlbC5IOlxuICAgICAgICAgICAgcmV0dXJuIFJTX0JMT0NLX1RBQkxFWyh0eXBlTnVtYmVyIC0gMSkgKiA0ICsgM107XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy5nZXRSU0Jsb2NrcyA9IGZ1bmN0aW9uKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKSB7XG4gICAgICAgIHZhciByc0Jsb2NrID0gZ2V0UnNCbG9ja1RhYmxlKHR5cGVOdW1iZXIsIGVycm9yQ29ycmVjdGlvbkxldmVsKTtcbiAgICAgICAgaWYgKHR5cGVvZiByc0Jsb2NrID09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICB0aHJvdyBcImJhZCBycyBibG9jayBAIHR5cGVOdW1iZXI6XCIgKyB0eXBlTnVtYmVyICsgXCIvZXJyb3JDb3JyZWN0aW9uTGV2ZWw6XCIgKyBlcnJvckNvcnJlY3Rpb25MZXZlbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gcnNCbG9jay5sZW5ndGggLyAzO1xuICAgICAgICB2YXIgbGlzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgdmFyIGNvdW50ID0gcnNCbG9ja1tpMiAqIDMgKyAwXTtcbiAgICAgICAgICB2YXIgdG90YWxDb3VudCA9IHJzQmxvY2tbaTIgKiAzICsgMV07XG4gICAgICAgICAgdmFyIGRhdGFDb3VudCA9IHJzQmxvY2tbaTIgKiAzICsgMl07XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBjb3VudDsgaiArPSAxKSB7XG4gICAgICAgICAgICBsaXN0LnB1c2gocXJSU0Jsb2NrKHRvdGFsQ291bnQsIGRhdGFDb3VudCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGlzdDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfSgpO1xuICAgIHZhciBxckJpdEJ1ZmZlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIF9idWZmZXIgPSBbXTtcbiAgICAgIHZhciBfbGVuZ3RoID0gMDtcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgX3RoaXMuZ2V0QnVmZmVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYnVmZmVyO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmdldEF0ID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgdmFyIGJ1ZkluZGV4ID0gTWF0aC5mbG9vcihpbmRleCAvIDgpO1xuICAgICAgICByZXR1cm4gKF9idWZmZXJbYnVmSW5kZXhdID4+PiA3IC0gaW5kZXggJSA4ICYgMSkgPT0gMTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5wdXQgPSBmdW5jdGlvbihudW0sIGxlbmd0aCkge1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgbGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgX3RoaXMucHV0Qml0KChudW0gPj4+IGxlbmd0aCAtIGkyIC0gMSAmIDEpID09IDEpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0TGVuZ3RoSW5CaXRzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbGVuZ3RoO1xuICAgICAgfTtcbiAgICAgIF90aGlzLnB1dEJpdCA9IGZ1bmN0aW9uKGJpdCkge1xuICAgICAgICB2YXIgYnVmSW5kZXggPSBNYXRoLmZsb29yKF9sZW5ndGggLyA4KTtcbiAgICAgICAgaWYgKF9idWZmZXIubGVuZ3RoIDw9IGJ1ZkluZGV4KSB7XG4gICAgICAgICAgX2J1ZmZlci5wdXNoKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICBfYnVmZmVyW2J1ZkluZGV4XSB8PSAxMjggPj4+IF9sZW5ndGggJSA4O1xuICAgICAgICB9XG4gICAgICAgIF9sZW5ndGggKz0gMTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcbiAgICB2YXIgcXJOdW1iZXIgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICB2YXIgX21vZGUgPSBRUk1vZGUuTU9ERV9OVU1CRVI7XG4gICAgICB2YXIgX2RhdGEgPSBkYXRhO1xuICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICBfdGhpcy5nZXRNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfbW9kZTtcbiAgICAgIH07XG4gICAgICBfdGhpcy5nZXRMZW5ndGggPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuIF9kYXRhLmxlbmd0aDtcbiAgICAgIH07XG4gICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICB2YXIgZGF0YTIgPSBfZGF0YTtcbiAgICAgICAgdmFyIGkyID0gMDtcbiAgICAgICAgd2hpbGUgKGkyICsgMiA8IGRhdGEyLmxlbmd0aCkge1xuICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YTIuc3Vic3RyaW5nKGkyLCBpMiArIDMpKSwgMTApO1xuICAgICAgICAgIGkyICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkyIDwgZGF0YTIubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGRhdGEyLmxlbmd0aCAtIGkyID09IDEpIHtcbiAgICAgICAgICAgIGJ1ZmZlci5wdXQoc3RyVG9OdW0oZGF0YTIuc3Vic3RyaW5nKGkyLCBpMiArIDEpKSwgNCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChkYXRhMi5sZW5ndGggLSBpMiA9PSAyKSB7XG4gICAgICAgICAgICBidWZmZXIucHV0KHN0clRvTnVtKGRhdGEyLnN1YnN0cmluZyhpMiwgaTIgKyAyKSksIDcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBzdHJUb051bSA9IGZ1bmN0aW9uKHMyKSB7XG4gICAgICAgIHZhciBudW0gPSAwO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgczIubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgbnVtID0gbnVtICogMTAgKyBjaGF0VG9OdW0oczIuY2hhckF0KGkyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICAgIH07XG4gICAgICB2YXIgY2hhdFRvTnVtID0gZnVuY3Rpb24oYzIpIHtcbiAgICAgICAgaWYgKFwiMFwiIDw9IGMyICYmIGMyIDw9IFwiOVwiKSB7XG4gICAgICAgICAgcmV0dXJuIGMyLmNoYXJDb2RlQXQoMCkgLSBcIjBcIi5jaGFyQ29kZUF0KDApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwiaWxsZWdhbCBjaGFyIDpcIiArIGMyO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuICAgIHZhciBxckFscGhhTnVtID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdmFyIF9tb2RlID0gUVJNb2RlLk1PREVfQUxQSEFfTlVNO1xuICAgICAgdmFyIF9kYXRhID0gZGF0YTtcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgX3RoaXMuZ2V0TW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX21vZGU7XG4gICAgICB9O1xuICAgICAgX3RoaXMuZ2V0TGVuZ3RoID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBfZGF0YS5sZW5ndGg7XG4gICAgICB9O1xuICAgICAgX3RoaXMud3JpdGUgPSBmdW5jdGlvbihidWZmZXIpIHtcbiAgICAgICAgdmFyIHMyID0gX2RhdGE7XG4gICAgICAgIHZhciBpMiA9IDA7XG4gICAgICAgIHdoaWxlIChpMiArIDEgPCBzMi5sZW5ndGgpIHtcbiAgICAgICAgICBidWZmZXIucHV0KFxuICAgICAgICAgICAgZ2V0Q29kZShzMi5jaGFyQXQoaTIpKSAqIDQ1ICsgZ2V0Q29kZShzMi5jaGFyQXQoaTIgKyAxKSksXG4gICAgICAgICAgICAxMVxuICAgICAgICAgICk7XG4gICAgICAgICAgaTIgKz0gMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaTIgPCBzMi5sZW5ndGgpIHtcbiAgICAgICAgICBidWZmZXIucHV0KGdldENvZGUoczIuY2hhckF0KGkyKSksIDYpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdmFyIGdldENvZGUgPSBmdW5jdGlvbihjMikge1xuICAgICAgICBpZiAoXCIwXCIgPD0gYzIgJiYgYzIgPD0gXCI5XCIpIHtcbiAgICAgICAgICByZXR1cm4gYzIuY2hhckNvZGVBdCgwKSAtIFwiMFwiLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJBXCIgPD0gYzIgJiYgYzIgPD0gXCJaXCIpIHtcbiAgICAgICAgICByZXR1cm4gYzIuY2hhckNvZGVBdCgwKSAtIFwiQVwiLmNoYXJDb2RlQXQoMCkgKyAxMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzd2l0Y2ggKGMyKSB7XG4gICAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgICByZXR1cm4gMzY7XG4gICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICByZXR1cm4gMzc7XG4gICAgICAgICAgICBjYXNlIFwiJVwiOlxuICAgICAgICAgICAgICByZXR1cm4gMzg7XG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICByZXR1cm4gMzk7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICByZXR1cm4gNDA7XG4gICAgICAgICAgICBjYXNlIFwiLVwiOlxuICAgICAgICAgICAgICByZXR1cm4gNDE7XG4gICAgICAgICAgICBjYXNlIFwiLlwiOlxuICAgICAgICAgICAgICByZXR1cm4gNDI7XG4gICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgICByZXR1cm4gNDM7XG4gICAgICAgICAgICBjYXNlIFwiOlwiOlxuICAgICAgICAgICAgICByZXR1cm4gNDQ7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBcImlsbGVnYWwgY2hhciA6XCIgKyBjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcbiAgICB2YXIgcXI4Qml0Qnl0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFXzhCSVRfQllURTtcbiAgICAgIHZhciBfYnl0ZXMgPSBxcmNvZGUzLnN0cmluZ1RvQnl0ZXMoZGF0YSk7XG4gICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gX2J5dGVzLmxlbmd0aDtcbiAgICAgIH07XG4gICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgX2J5dGVzLmxlbmd0aDsgaTIgKz0gMSkge1xuICAgICAgICAgIGJ1ZmZlci5wdXQoX2J5dGVzW2kyXSwgOCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcbiAgICB2YXIgcXJLYW5qaSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHZhciBfbW9kZSA9IFFSTW9kZS5NT0RFX0tBTkpJO1xuICAgICAgdmFyIHN0cmluZ1RvQnl0ZXMgPSBxcmNvZGUzLnN0cmluZ1RvQnl0ZXNGdW5jc1tcIlNKSVNcIl07XG4gICAgICBpZiAoIXN0cmluZ1RvQnl0ZXMpIHtcbiAgICAgICAgdGhyb3cgXCJzamlzIG5vdCBzdXBwb3J0ZWQuXCI7XG4gICAgICB9XG4gICAgICAhZnVuY3Rpb24oYzIsIGNvZGUpIHtcbiAgICAgICAgdmFyIHRlc3QgPSBzdHJpbmdUb0J5dGVzKGMyKTtcbiAgICAgICAgaWYgKHRlc3QubGVuZ3RoICE9IDIgfHwgKHRlc3RbMF0gPDwgOCB8IHRlc3RbMV0pICE9IGNvZGUpIHtcbiAgICAgICAgICB0aHJvdyBcInNqaXMgbm90IHN1cHBvcnRlZC5cIjtcbiAgICAgICAgfVxuICAgICAgfShcIlxcdTUzQ0JcIiwgMzg3MjYpO1xuICAgICAgdmFyIF9ieXRlcyA9IHN0cmluZ1RvQnl0ZXMoZGF0YSk7XG4gICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgIF90aGlzLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9tb2RlO1xuICAgICAgfTtcbiAgICAgIF90aGlzLmdldExlbmd0aCA9IGZ1bmN0aW9uKGJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gfn4oX2J5dGVzLmxlbmd0aCAvIDIpO1xuICAgICAgfTtcbiAgICAgIF90aGlzLndyaXRlID0gZnVuY3Rpb24oYnVmZmVyKSB7XG4gICAgICAgIHZhciBkYXRhMiA9IF9ieXRlcztcbiAgICAgICAgdmFyIGkyID0gMDtcbiAgICAgICAgd2hpbGUgKGkyICsgMSA8IGRhdGEyLmxlbmd0aCkge1xuICAgICAgICAgIHZhciBjMiA9ICgyNTUgJiBkYXRhMltpMl0pIDw8IDggfCAyNTUgJiBkYXRhMltpMiArIDFdO1xuICAgICAgICAgIGlmICgzMzA4OCA8PSBjMiAmJiBjMiA8PSA0MDk1Nikge1xuICAgICAgICAgICAgYzIgLT0gMzMwODg7XG4gICAgICAgICAgfSBlbHNlIGlmICg1NzQwOCA8PSBjMiAmJiBjMiA8PSA2MDM1MSkge1xuICAgICAgICAgICAgYzIgLT0gNDk0NzI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IFwiaWxsZWdhbCBjaGFyIGF0IFwiICsgKGkyICsgMSkgKyBcIi9cIiArIGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjMiA9IChjMiA+Pj4gOCAmIDI1NSkgKiAxOTIgKyAoYzIgJiAyNTUpO1xuICAgICAgICAgIGJ1ZmZlci5wdXQoYzIsIDEzKTtcbiAgICAgICAgICBpMiArPSAyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpMiA8IGRhdGEyLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IFwiaWxsZWdhbCBjaGFyIGF0IFwiICsgKGkyICsgMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcbiAgICB2YXIgYnl0ZUFycmF5T3V0cHV0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2J5dGVzID0gW107XG4gICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgX2J5dGVzLnB1c2goYiAmIDI1NSk7XG4gICAgICB9O1xuICAgICAgX3RoaXMud3JpdGVTaG9ydCA9IGZ1bmN0aW9uKGkyKSB7XG4gICAgICAgIF90aGlzLndyaXRlQnl0ZShpMik7XG4gICAgICAgIF90aGlzLndyaXRlQnl0ZShpMiA+Pj4gOCk7XG4gICAgICB9O1xuICAgICAgX3RoaXMud3JpdGVCeXRlcyA9IGZ1bmN0aW9uKGIsIG9mZiwgbGVuKSB7XG4gICAgICAgIG9mZiA9IG9mZiB8fCAwO1xuICAgICAgICBsZW4gPSBsZW4gfHwgYi5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBsZW47IGkyICs9IDEpIHtcbiAgICAgICAgICBfdGhpcy53cml0ZUJ5dGUoYltpMiArIG9mZl0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgX3RoaXMud3JpdGVTdHJpbmcgPSBmdW5jdGlvbihzMikge1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgczIubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgX3RoaXMud3JpdGVCeXRlKHMyLmNoYXJDb2RlQXQoaTIpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF90aGlzLnRvQnl0ZUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfYnl0ZXM7XG4gICAgICB9O1xuICAgICAgX3RoaXMudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHMyID0gXCJcIjtcbiAgICAgICAgczIgKz0gXCJbXCI7XG4gICAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBfYnl0ZXMubGVuZ3RoOyBpMiArPSAxKSB7XG4gICAgICAgICAgaWYgKGkyID4gMCkge1xuICAgICAgICAgICAgczIgKz0gXCIsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMyICs9IF9ieXRlc1tpMl07XG4gICAgICAgIH1cbiAgICAgICAgczIgKz0gXCJdXCI7XG4gICAgICAgIHJldHVybiBzMjtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcbiAgICB2YXIgYmFzZTY0RW5jb2RlT3V0cHV0U3RyZWFtID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgX2J1ZmZlciA9IDA7XG4gICAgICB2YXIgX2J1ZmxlbiA9IDA7XG4gICAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgICB2YXIgX2Jhc2U2NCA9IFwiXCI7XG4gICAgICB2YXIgX3RoaXMgPSB7fTtcbiAgICAgIHZhciB3cml0ZUVuY29kZWQgPSBmdW5jdGlvbihiKSB7XG4gICAgICAgIF9iYXNlNjQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlbmNvZGUoYiAmIDYzKSk7XG4gICAgICB9O1xuICAgICAgdmFyIGVuY29kZSA9IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgIGlmIChuMiA8IDApXG4gICAgICAgICAgO1xuICAgICAgICBlbHNlIGlmIChuMiA8IDI2KSB7XG4gICAgICAgICAgcmV0dXJuIDY1ICsgbjI7XG4gICAgICAgIH0gZWxzZSBpZiAobjIgPCA1Mikge1xuICAgICAgICAgIHJldHVybiA5NyArIChuMiAtIDI2KTtcbiAgICAgICAgfSBlbHNlIGlmIChuMiA8IDYyKSB7XG4gICAgICAgICAgcmV0dXJuIDQ4ICsgKG4yIC0gNTIpO1xuICAgICAgICB9IGVsc2UgaWYgKG4yID09IDYyKSB7XG4gICAgICAgICAgcmV0dXJuIDQzO1xuICAgICAgICB9IGVsc2UgaWYgKG4yID09IDYzKSB7XG4gICAgICAgICAgcmV0dXJuIDQ3O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IFwibjpcIiArIG4yO1xuICAgICAgfTtcbiAgICAgIF90aGlzLndyaXRlQnl0ZSA9IGZ1bmN0aW9uKG4yKSB7XG4gICAgICAgIF9idWZmZXIgPSBfYnVmZmVyIDw8IDggfCBuMiAmIDI1NTtcbiAgICAgICAgX2J1ZmxlbiArPSA4O1xuICAgICAgICBfbGVuZ3RoICs9IDE7XG4gICAgICAgIHdoaWxlIChfYnVmbGVuID49IDYpIHtcbiAgICAgICAgICB3cml0ZUVuY29kZWQoX2J1ZmZlciA+Pj4gX2J1ZmxlbiAtIDYpO1xuICAgICAgICAgIF9idWZsZW4gLT0gNjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIF90aGlzLmZsdXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfYnVmbGVuID4gMCkge1xuICAgICAgICAgIHdyaXRlRW5jb2RlZChfYnVmZmVyIDw8IDYgLSBfYnVmbGVuKTtcbiAgICAgICAgICBfYnVmZmVyID0gMDtcbiAgICAgICAgICBfYnVmbGVuID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xlbmd0aCAlIDMgIT0gMCkge1xuICAgICAgICAgIHZhciBwYWRsZW4gPSAzIC0gX2xlbmd0aCAlIDM7XG4gICAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHBhZGxlbjsgaTIgKz0gMSkge1xuICAgICAgICAgICAgX2Jhc2U2NCArPSBcIj1cIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBfdGhpcy50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX2Jhc2U2NDtcbiAgICAgIH07XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfTtcbiAgICB2YXIgYmFzZTY0RGVjb2RlSW5wdXRTdHJlYW0gPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHZhciBfc3RyID0gc3RyO1xuICAgICAgdmFyIF9wb3MgPSAwO1xuICAgICAgdmFyIF9idWZmZXIgPSAwO1xuICAgICAgdmFyIF9idWZsZW4gPSAwO1xuICAgICAgdmFyIF90aGlzID0ge307XG4gICAgICBfdGhpcy5yZWFkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlIChfYnVmbGVuIDwgOCkge1xuICAgICAgICAgIGlmIChfcG9zID49IF9zdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoX2J1ZmxlbiA9PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IFwidW5leHBlY3RlZCBlbmQgb2YgZmlsZS4vXCIgKyBfYnVmbGVuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYzIgPSBfc3RyLmNoYXJBdChfcG9zKTtcbiAgICAgICAgICBfcG9zICs9IDE7XG4gICAgICAgICAgaWYgKGMyID09IFwiPVwiKSB7XG4gICAgICAgICAgICBfYnVmbGVuID0gMDtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMyLm1hdGNoKC9eXFxzJC8pKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2J1ZmZlciA9IF9idWZmZXIgPDwgNiB8IGRlY29kZShjMi5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgICBfYnVmbGVuICs9IDY7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG4yID0gX2J1ZmZlciA+Pj4gX2J1ZmxlbiAtIDggJiAyNTU7XG4gICAgICAgIF9idWZsZW4gLT0gODtcbiAgICAgICAgcmV0dXJuIG4yO1xuICAgICAgfTtcbiAgICAgIHZhciBkZWNvZGUgPSBmdW5jdGlvbihjMikge1xuICAgICAgICBpZiAoNjUgPD0gYzIgJiYgYzIgPD0gOTApIHtcbiAgICAgICAgICByZXR1cm4gYzIgLSA2NTtcbiAgICAgICAgfSBlbHNlIGlmICg5NyA8PSBjMiAmJiBjMiA8PSAxMjIpIHtcbiAgICAgICAgICByZXR1cm4gYzIgLSA5NyArIDI2O1xuICAgICAgICB9IGVsc2UgaWYgKDQ4IDw9IGMyICYmIGMyIDw9IDU3KSB7XG4gICAgICAgICAgcmV0dXJuIGMyIC0gNDggKyA1MjtcbiAgICAgICAgfSBlbHNlIGlmIChjMiA9PSA0Mykge1xuICAgICAgICAgIHJldHVybiA2MjtcbiAgICAgICAgfSBlbHNlIGlmIChjMiA9PSA0Nykge1xuICAgICAgICAgIHJldHVybiA2MztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBcImM6XCIgKyBjMjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuICAgIHZhciBnaWZJbWFnZSA9IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHZhciBfd2lkdGggPSB3aWR0aDtcbiAgICAgIHZhciBfaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgdmFyIF9kYXRhID0gbmV3IEFycmF5KHdpZHRoICogaGVpZ2h0KTtcbiAgICAgIHZhciBfdGhpcyA9IHt9O1xuICAgICAgX3RoaXMuc2V0UGl4ZWwgPSBmdW5jdGlvbih4LCB5LCBwaXhlbCkge1xuICAgICAgICBfZGF0YVt5ICogX3dpZHRoICsgeF0gPSBwaXhlbDtcbiAgICAgIH07XG4gICAgICBfdGhpcy53cml0ZSA9IGZ1bmN0aW9uKG91dCkge1xuICAgICAgICBvdXQud3JpdGVTdHJpbmcoXCJHSUY4N2FcIik7XG4gICAgICAgIG91dC53cml0ZVNob3J0KF93aWR0aCk7XG4gICAgICAgIG91dC53cml0ZVNob3J0KF9oZWlnaHQpO1xuICAgICAgICBvdXQud3JpdGVCeXRlKDEyOCk7XG4gICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgIG91dC53cml0ZUJ5dGUoMjU1KTtcbiAgICAgICAgb3V0LndyaXRlQnl0ZSgyNTUpO1xuICAgICAgICBvdXQud3JpdGVCeXRlKDI1NSk7XG4gICAgICAgIG91dC53cml0ZVN0cmluZyhcIixcIik7XG4gICAgICAgIG91dC53cml0ZVNob3J0KDApO1xuICAgICAgICBvdXQud3JpdGVTaG9ydCgwKTtcbiAgICAgICAgb3V0LndyaXRlU2hvcnQoX3dpZHRoKTtcbiAgICAgICAgb3V0LndyaXRlU2hvcnQoX2hlaWdodCk7XG4gICAgICAgIG91dC53cml0ZUJ5dGUoMCk7XG4gICAgICAgIHZhciBsendNaW5Db2RlU2l6ZSA9IDI7XG4gICAgICAgIHZhciByYXN0ZXIgPSBnZXRMWldSYXN0ZXIobHp3TWluQ29kZVNpemUpO1xuICAgICAgICBvdXQud3JpdGVCeXRlKGx6d01pbkNvZGVTaXplKTtcbiAgICAgICAgdmFyIG9mZnNldCA9IDA7XG4gICAgICAgIHdoaWxlIChyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0ID4gMjU1KSB7XG4gICAgICAgICAgb3V0LndyaXRlQnl0ZSgyNTUpO1xuICAgICAgICAgIG91dC53cml0ZUJ5dGVzKHJhc3Rlciwgb2Zmc2V0LCAyNTUpO1xuICAgICAgICAgIG9mZnNldCArPSAyNTU7XG4gICAgICAgIH1cbiAgICAgICAgb3V0LndyaXRlQnl0ZShyYXN0ZXIubGVuZ3RoIC0gb2Zmc2V0KTtcbiAgICAgICAgb3V0LndyaXRlQnl0ZXMocmFzdGVyLCBvZmZzZXQsIHJhc3Rlci5sZW5ndGggLSBvZmZzZXQpO1xuICAgICAgICBvdXQud3JpdGVCeXRlKDApO1xuICAgICAgICBvdXQud3JpdGVTdHJpbmcoXCI7XCIpO1xuICAgICAgfTtcbiAgICAgIHZhciBiaXRPdXRwdXRTdHJlYW0gPSBmdW5jdGlvbihvdXQpIHtcbiAgICAgICAgdmFyIF9vdXQgPSBvdXQ7XG4gICAgICAgIHZhciBfYml0TGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIF9iaXRCdWZmZXIgPSAwO1xuICAgICAgICB2YXIgX3RoaXMyID0ge307XG4gICAgICAgIF90aGlzMi53cml0ZSA9IGZ1bmN0aW9uKGRhdGEsIGxlbmd0aCkge1xuICAgICAgICAgIGlmIChkYXRhID4+PiBsZW5ndGggIT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgXCJsZW5ndGggb3ZlclwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoX2JpdExlbmd0aCArIGxlbmd0aCA+PSA4KSB7XG4gICAgICAgICAgICBfb3V0LndyaXRlQnl0ZSgyNTUgJiAoZGF0YSA8PCBfYml0TGVuZ3RoIHwgX2JpdEJ1ZmZlcikpO1xuICAgICAgICAgICAgbGVuZ3RoIC09IDggLSBfYml0TGVuZ3RoO1xuICAgICAgICAgICAgZGF0YSA+Pj49IDggLSBfYml0TGVuZ3RoO1xuICAgICAgICAgICAgX2JpdEJ1ZmZlciA9IDA7XG4gICAgICAgICAgICBfYml0TGVuZ3RoID0gMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2JpdEJ1ZmZlciA9IGRhdGEgPDwgX2JpdExlbmd0aCB8IF9iaXRCdWZmZXI7XG4gICAgICAgICAgX2JpdExlbmd0aCA9IF9iaXRMZW5ndGggKyBsZW5ndGg7XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzMi5mbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChfYml0TGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgX291dC53cml0ZUJ5dGUoX2JpdEJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXMyO1xuICAgICAgfTtcbiAgICAgIHZhciBnZXRMWldSYXN0ZXIgPSBmdW5jdGlvbihsendNaW5Db2RlU2l6ZSkge1xuICAgICAgICB2YXIgY2xlYXJDb2RlID0gMSA8PCBsendNaW5Db2RlU2l6ZTtcbiAgICAgICAgdmFyIGVuZENvZGUgPSAoMSA8PCBsendNaW5Db2RlU2l6ZSkgKyAxO1xuICAgICAgICB2YXIgYml0TGVuZ3RoID0gbHp3TWluQ29kZVNpemUgKyAxO1xuICAgICAgICB2YXIgdGFibGUgPSBsendUYWJsZSgpO1xuICAgICAgICBmb3IgKHZhciBpMiA9IDA7IGkyIDwgY2xlYXJDb2RlOyBpMiArPSAxKSB7XG4gICAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoaTIpKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZS5hZGQoU3RyaW5nLmZyb21DaGFyQ29kZShjbGVhckNvZGUpKTtcbiAgICAgICAgdGFibGUuYWRkKFN0cmluZy5mcm9tQ2hhckNvZGUoZW5kQ29kZSkpO1xuICAgICAgICB2YXIgYnl0ZU91dCA9IGJ5dGVBcnJheU91dHB1dFN0cmVhbSgpO1xuICAgICAgICB2YXIgYml0T3V0ID0gYml0T3V0cHV0U3RyZWFtKGJ5dGVPdXQpO1xuICAgICAgICBiaXRPdXQud3JpdGUoY2xlYXJDb2RlLCBiaXRMZW5ndGgpO1xuICAgICAgICB2YXIgZGF0YUluZGV4ID0gMDtcbiAgICAgICAgdmFyIHMyID0gU3RyaW5nLmZyb21DaGFyQ29kZShfZGF0YVtkYXRhSW5kZXhdKTtcbiAgICAgICAgZGF0YUluZGV4ICs9IDE7XG4gICAgICAgIHdoaWxlIChkYXRhSW5kZXggPCBfZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICB2YXIgYzIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKF9kYXRhW2RhdGFJbmRleF0pO1xuICAgICAgICAgIGRhdGFJbmRleCArPSAxO1xuICAgICAgICAgIGlmICh0YWJsZS5jb250YWlucyhzMiArIGMyKSkge1xuICAgICAgICAgICAgczIgPSBzMiArIGMyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaXRPdXQud3JpdGUodGFibGUuaW5kZXhPZihzMiksIGJpdExlbmd0aCk7XG4gICAgICAgICAgICBpZiAodGFibGUuc2l6ZSgpIDwgNDA5NSkge1xuICAgICAgICAgICAgICBpZiAodGFibGUuc2l6ZSgpID09IDEgPDwgYml0TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYml0TGVuZ3RoICs9IDE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGFibGUuYWRkKHMyICsgYzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgczIgPSBjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYml0T3V0LndyaXRlKHRhYmxlLmluZGV4T2YoczIpLCBiaXRMZW5ndGgpO1xuICAgICAgICBiaXRPdXQud3JpdGUoZW5kQ29kZSwgYml0TGVuZ3RoKTtcbiAgICAgICAgYml0T3V0LmZsdXNoKCk7XG4gICAgICAgIHJldHVybiBieXRlT3V0LnRvQnl0ZUFycmF5KCk7XG4gICAgICB9O1xuICAgICAgdmFyIGx6d1RhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBfbWFwID0ge307XG4gICAgICAgIHZhciBfc2l6ZSA9IDA7XG4gICAgICAgIHZhciBfdGhpczIgPSB7fTtcbiAgICAgICAgX3RoaXMyLmFkZCA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgIGlmIChfdGhpczIuY29udGFpbnMoa2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgXCJkdXAga2V5OlwiICsga2V5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBfbWFwW2tleV0gPSBfc2l6ZTtcbiAgICAgICAgICBfc2l6ZSArPSAxO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpczIuc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBfc2l6ZTtcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMyLmluZGV4T2YgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gX21hcFtrZXldO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpczIuY29udGFpbnMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdHlwZW9mIF9tYXBba2V5XSAhPSBcInVuZGVmaW5lZFwiO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3RoaXMyO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9O1xuICAgIHZhciBjcmVhdGVEYXRhVVJMID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgZ2V0UGl4ZWwpIHtcbiAgICAgIHZhciBnaWYgPSBnaWZJbWFnZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5ICs9IDEpIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCArPSAxKSB7XG4gICAgICAgICAgZ2lmLnNldFBpeGVsKHgsIHksIGdldFBpeGVsKHgsIHkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGIgPSBieXRlQXJyYXlPdXRwdXRTdHJlYW0oKTtcbiAgICAgIGdpZi53cml0ZShiKTtcbiAgICAgIHZhciBiYXNlNjQgPSBiYXNlNjRFbmNvZGVPdXRwdXRTdHJlYW0oKTtcbiAgICAgIHZhciBieXRlcyA9IGIudG9CeXRlQXJyYXkoKTtcbiAgICAgIGZvciAodmFyIGkyID0gMDsgaTIgPCBieXRlcy5sZW5ndGg7IGkyICs9IDEpIHtcbiAgICAgICAgYmFzZTY0LndyaXRlQnl0ZShieXRlc1tpMl0pO1xuICAgICAgfVxuICAgICAgYmFzZTY0LmZsdXNoKCk7XG4gICAgICByZXR1cm4gXCJkYXRhOmltYWdlL2dpZjtiYXNlNjQsXCIgKyBiYXNlNjQ7XG4gICAgfTtcbiAgICByZXR1cm4gcXJjb2RlMztcbiAgfSgpO1xuICAhZnVuY3Rpb24oKSB7XG4gICAgcXJjb2RlMi5zdHJpbmdUb0J5dGVzRnVuY3NbXCJVVEYtOFwiXSA9IGZ1bmN0aW9uKHMyKSB7XG4gICAgICBmdW5jdGlvbiB0b1VURjhBcnJheShzdHIpIHtcbiAgICAgICAgdmFyIHV0ZjggPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaTIgPSAwOyBpMiA8IHN0ci5sZW5ndGg7IGkyKyspIHtcbiAgICAgICAgICB2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpMik7XG4gICAgICAgICAgaWYgKGNoYXJjb2RlIDwgMTI4KVxuICAgICAgICAgICAgdXRmOC5wdXNoKGNoYXJjb2RlKTtcbiAgICAgICAgICBlbHNlIGlmIChjaGFyY29kZSA8IDIwNDgpIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgMTkyIHwgY2hhcmNvZGUgPj4gNixcbiAgICAgICAgICAgICAgMTI4IHwgY2hhcmNvZGUgJiA2M1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNoYXJjb2RlIDwgNTUyOTYgfHwgY2hhcmNvZGUgPj0gNTczNDQpIHtcbiAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgMjI0IHwgY2hhcmNvZGUgPj4gMTIsXG4gICAgICAgICAgICAgIDEyOCB8IGNoYXJjb2RlID4+IDYgJiA2MyxcbiAgICAgICAgICAgICAgMTI4IHwgY2hhcmNvZGUgJiA2M1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaTIrKztcbiAgICAgICAgICAgIGNoYXJjb2RlID0gNjU1MzYgKyAoKGNoYXJjb2RlICYgMTAyMykgPDwgMTAgfCBzdHIuY2hhckNvZGVBdChpMikgJiAxMDIzKTtcbiAgICAgICAgICAgIHV0ZjgucHVzaChcbiAgICAgICAgICAgICAgMjQwIHwgY2hhcmNvZGUgPj4gMTgsXG4gICAgICAgICAgICAgIDEyOCB8IGNoYXJjb2RlID4+IDEyICYgNjMsXG4gICAgICAgICAgICAgIDEyOCB8IGNoYXJjb2RlID4+IDYgJiA2MyxcbiAgICAgICAgICAgICAgMTI4IHwgY2hhcmNvZGUgJiA2M1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0Zjg7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9VVEY4QXJyYXkoczIpO1xuICAgIH07XG4gIH0oKTtcbiAgKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICB7XG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcbiAgICB9XG4gIH0pKGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBxcmNvZGUyO1xuICB9KTtcbn0pKHFyY29kZSQxKTtcbmNvbnN0IHFyY29kZSA9IHFyY29kZSQxLmV4cG9ydHM7XG5mdW5jdGlvbiBjb3B5VG9DbGlwYm9hcmQodGV4dCkge1xuICBpZiAobmF2aWdhdG9yID09IG51bGwgPyB2b2lkIDAgOiBuYXZpZ2F0b3IuY2xpcGJvYXJkKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpO1xuICB9XG4gIGZhbGxiYWNrQ29weVRleHRUb0NsaXBib2FyZCh0ZXh0KTtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuZnVuY3Rpb24gZmFsbGJhY2tDb3B5VGV4dFRvQ2xpcGJvYXJkKHRleHQpIHtcbiAgY29uc3QgdGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gIHRleHRBcmVhLnZhbHVlID0gdGV4dDtcbiAgdGV4dEFyZWEuc3R5bGUudG9wID0gXCIwXCI7XG4gIHRleHRBcmVhLnN0eWxlLmxlZnQgPSBcIjBcIjtcbiAgdGV4dEFyZWEuc3R5bGUucG9zaXRpb24gPSBcImZpeGVkXCI7XG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGV4dEFyZWEpO1xuICB0ZXh0QXJlYS5mb2N1cygpO1xuICB0ZXh0QXJlYS5zZWxlY3QoKTtcbiAgdHJ5IHtcbiAgICBkb2N1bWVudC5leGVjQ29tbWFuZChcImNvcHlcIik7XG4gIH0gZmluYWxseSB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0QXJlYSk7XG4gIH1cbn1cbnZhciBkZWVwUmVhZE9iamVjdCA9IChvYmosIHBhdGgsIGRlZmF1bHRWYWx1ZSkgPT4ge1xuICBjb25zdCB2YWx1ZSA9IHBhdGgudHJpbSgpLnNwbGl0KFwiLlwiKS5yZWR1Y2UoKGEyLCBiKSA9PiBhMiA/IGEyW2JdIDogdm9pZCAwLCBvYmopO1xuICByZXR1cm4gdmFsdWUgIT09IHZvaWQgMCA/IHZhbHVlIDogZGVmYXVsdFZhbHVlO1xufTtcbnZhciB0ZW1wbGF0ZSA9IChzdHIsIHBhcmFtcywgcmVnID0gL3t7KC4qPyl9fS9nKSA9PiBzdHIucmVwbGFjZShyZWcsIChfLCBrZXkpID0+IGRlZXBSZWFkT2JqZWN0KHBhcmFtcywga2V5LCBcIlwiKSk7XG52YXIgY3JlYXRlSTE4bkNvbnRleHQgPSAoaW5pdCA9IHt9LCBsYW5nID0gbmF2aWdhdG9yLmxhbmd1YWdlIGluIGluaXQgPyBuYXZpZ2F0b3IubGFuZ3VhZ2UgOiBPYmplY3Qua2V5cyhpbml0KVswXSkgPT4ge1xuICBjb25zdCBbbG9jYWxlLCBzZXRMb2NhbGVdID0gY3JlYXRlU2lnbmFsKGxhbmcpO1xuICBjb25zdCBbZGljdCwgc2V0RGljdF0gPSBjcmVhdGVTdG9yZShpbml0KTtcbiAgY29uc3QgdHJhbnNsYXRlID0gKGtleSwgcGFyYW1zLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBjb25zdCB2YWwgPSBkZWVwUmVhZE9iamVjdChkaWN0W2xvY2FsZSgpXSwga2V5LCBkZWZhdWx0VmFsdWUgfHwgXCJcIik7XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09IFwiZnVuY3Rpb25cIilcbiAgICAgIHJldHVybiB2YWwocGFyYW1zKTtcbiAgICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIilcbiAgICAgIHJldHVybiB0ZW1wbGF0ZSh2YWwsIHBhcmFtcyB8fCB7fSk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfTtcbiAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICBhZGQobGFuZzIsIHRhYmxlKSB7XG4gICAgICBzZXREaWN0KGxhbmcyLCAodDIpID0+IE9iamVjdC5hc3NpZ24odDIgfHwge30sIHRhYmxlKSk7XG4gICAgfSxcbiAgICBsb2NhbGU6IChsYW5nMikgPT4gbGFuZzIgPyBzZXRMb2NhbGUobGFuZzIpIDogbG9jYWxlKCksXG4gICAgZGljdDogKGxhbmcyKSA9PiBkZWVwUmVhZE9iamVjdChkaWN0LCBsYW5nMilcbiAgfTtcbiAgcmV0dXJuIFt0cmFuc2xhdGUsIGFjdGlvbnNdO1xufTtcbnZhciBJMThuQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xudmFyIHVzZUkxOG4gPSAoKSA9PiB1c2VDb250ZXh0KEkxOG5Db250ZXh0KTtcbmNvbnN0IFRyYW5zbGF0aW9uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIHJldHVybiBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIHQyKHByb3BzLnRyYW5zbGF0aW9uS2V5LCBwcm9wcy50cmFuc2xhdGlvblZhbHVlcywgKF9hID0gcHJvcHMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKTtcbiAgfSk7XG59O1xuY29uc3QgX3RtcGwkJGQgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGRpdj48L2Rpdj5gKTtcbmNvbnN0IGNvcHlUZXh0ID0ge1xuICB0cmFuc2xhdGlvbktleTogXCJjb21tb24uY29weUxpbmtcIixcbiAgdGV4dDogXCJDb3B5IExpbmtcIlxufTtcbmNvbnN0IGNvcGllZFRleHQgPSB7XG4gIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5jb3BpZWRcIixcbiAgdGV4dDogXCJDb3BpZWQhXCJcbn07XG5jb25zdCBRUkNvZGUgPSAocHJvcHMpID0+IHtcbiAgbGV0IHFyQ29kZUNhbnZhc1JlZjtcbiAgbGV0IHFyQ29kZVdyYXBwZXJSZWY7XG4gIGxldCBpbWFnZVJlZjtcbiAgY29uc3QgW2NvcHlCdXR0b25PcGVuZWQsIHNldENvcHlCdXR0b25PcGVuZWRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3QgW2NvcHlCdXR0b25Ib3ZlcmVkLCBzZXRDb3B5QnV0dG9uSG92ZXJlZF0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBbcXJIb3ZlcmVkLCBzZXRRckhvdmVyZWRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3QgW2NvcHlCdXR0b25UZXh0LCBzZXRDb3B5QnV0dG9uVGV4dF0gPSBjcmVhdGVTaWduYWwoY29weVRleHQpO1xuICBjb25zdCBbcGljU2l6ZSwgc2V0UGljU2l6ZV0gPSBjcmVhdGVTaWduYWwocGljU2l6ZURlZmF1bHQpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4gc2V0Q29weUJ1dHRvbk9wZW5lZChjb3B5QnV0dG9uSG92ZXJlZCgpIHx8IHFySG92ZXJlZCgpKSk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiAhY29weUJ1dHRvbk9wZW5lZCgpICYmIHNldENvcHlCdXR0b25UZXh0KGNvcHlUZXh0KSk7XG4gIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBcIkxcIjtcbiAgICBjb25zdCBjZWxsU2l6ZSA9IDQ7XG4gICAgY29uc3QgcXIgPSBxcmNvZGUoMCwgZXJyb3JDb3JyZWN0aW9uTGV2ZWwpO1xuICAgIHFyLmFkZERhdGEocHJvcHMuc291cmNlVXJsKTtcbiAgICBxci5tYWtlKCk7XG4gICAgcXJDb2RlQ2FudmFzUmVmLmlubmVySFRNTCA9IHFyLmNyZWF0ZVN2Z1RhZyhjZWxsU2l6ZSwgMCk7XG4gICAgY29uc3QgcXJTaXplID0gcXJDb2RlQ2FudmFzUmVmLmZpcnN0RWxlbWVudENoaWxkLmNsaWVudFdpZHRoO1xuICAgIGNvbnN0IHNjYWxlID0gTWF0aC5yb3VuZChxck5vcm1hbFNpemUgLyBxclNpemUgKiAxZTUpIC8gMWU1O1xuICAgIGlmIChpbWFnZVJlZikge1xuICAgICAgY29uc3QgaW1nU2l6ZSA9IE1hdGguY2VpbChpbWdTaXplRGVmYXVsdCAvIChzY2FsZSAqIGNlbGxTaXplKSkgKiBjZWxsU2l6ZTtcbiAgICAgIGNvbnN0IGltZ09mZnNldCA9IHRvUHgoTWF0aC5jZWlsKChxclNpemUgLSBpbWdTaXplKSAvICgyICogY2VsbFNpemUpKSAqIGNlbGxTaXplKTtcbiAgICAgIGltYWdlUmVmLnN0eWxlLnRvcCA9IGltZ09mZnNldDtcbiAgICAgIGltYWdlUmVmLnN0eWxlLmxlZnQgPSBpbWdPZmZzZXQ7XG4gICAgICBpbWFnZVJlZi5zdHlsZS5oZWlnaHQgPSB0b1B4KGltZ1NpemUpO1xuICAgICAgaW1hZ2VSZWYuc3R5bGUud2lkdGggPSB0b1B4KGltZ1NpemUpO1xuICAgICAgc2V0UGljU2l6ZShNYXRoLnJvdW5kKHBpY1NpemVEZWZhdWx0IC8gc2NhbGUpKTtcbiAgICB9XG4gICAgcXJDb2RlV3JhcHBlclJlZi5zdHlsZS50cmFuc2Zvcm0gPSBgc2NhbGUoJHtzY2FsZX0pYDtcbiAgfSk7XG4gIGxldCB0aW1lb3V0SWQgPSBudWxsO1xuICBjb25zdCBvbkNvcHlDbGljayA9ICgpID0+IHtcbiAgICBjb3B5VG9DbGlwYm9hcmQocHJvcHMuc291cmNlVXJsKTtcbiAgICBzZXRDb3B5QnV0dG9uVGV4dChjb3BpZWRUZXh0KTtcbiAgICBpZiAodGltZW91dElkICE9IG51bGwpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgIH1cbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHNldENvcHlCdXR0b25UZXh0KGNvcHlUZXh0KSwgM2UzKTtcbiAgfTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChRckNvZGVCYWNrZ3JvdW5kLCB7XG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoUXJDb2RlV3JhcHBlciwge1xuICAgICAgICByZWYociQpIHtcbiAgICAgICAgICBjb25zdCBfcmVmJCA9IHFyQ29kZVdyYXBwZXJSZWY7XG4gICAgICAgICAgdHlwZW9mIF9yZWYkID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJChyJCkgOiBxckNvZGVXcmFwcGVyUmVmID0gciQ7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTW91c2VFbnRlcjogKCkgPT4gc2V0UXJIb3ZlcmVkKHRydWUpLFxuICAgICAgICBvbk1vdXNlTGVhdmU6ICgpID0+IHNldFRpbWVvdXQoKCkgPT4gc2V0UXJIb3ZlcmVkKGZhbHNlKSksXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gWygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBfZWwkID0gX3RtcGwkJGQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgY29uc3QgX3JlZiQyID0gcXJDb2RlQ2FudmFzUmVmO1xuICAgICAgICAgICAgdHlwZW9mIF9yZWYkMiA9PT0gXCJmdW5jdGlvblwiID8gdXNlKF9yZWYkMiwgX2VsJCkgOiBxckNvZGVDYW52YXNSZWYgPSBfZWwkO1xuICAgICAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICAgICAgfSkoKSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaW1hZ2VVcmw7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEltYWdlQmFja2dyb3VuZCwge1xuICAgICAgICAgICAgICAgIHJlZihyJCkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgX3JlZiQzID0gaW1hZ2VSZWY7XG4gICAgICAgICAgICAgICAgICB0eXBlb2YgX3JlZiQzID09PSBcImZ1bmN0aW9uXCIgPyBfcmVmJDMociQpIDogaW1hZ2VSZWYgPSByJDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoSW1hZ2VTdHlsZWQkMiwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgc3JjKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy5pbWFnZVVybDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYWx0OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGljU2l6ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUcmFuc2l0aW9uLCB7XG4gICAgICAgIG9uQmVmb3JlRW50ZXI6IChlbCkgPT4ge1xuICAgICAgICAgIGVsLmFuaW1hdGUoW3tcbiAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKC01MCUsIDQ0cHgpXCJcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCAwKVwiXG4gICAgICAgICAgfV0sIHtcbiAgICAgICAgICAgIGR1cmF0aW9uOiAyMDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FeGl0OiAoZWwsIGRvbmUpID0+IHtcbiAgICAgICAgICBlbC5hbmltYXRlKFt7XG4gICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgtNTAlLCAwKVwiXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoLTUwJSwgNDRweClcIlxuICAgICAgICAgIH1dLCB7XG4gICAgICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICAgICAgfSkuZmluaXNoZWQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY29weUJ1dHRvbk9wZW5lZCgpICYmICFwcm9wcy5kaXNhYmxlQ29weTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQ29weUJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uQ29weUNsaWNrLFxuICAgICAgICAgICAgICAgIG9uTW91c2VFbnRlcjogKCkgPT4gY29weUJ1dHRvbk9wZW5lZCgpICYmIHNldENvcHlCdXR0b25Ib3ZlcmVkKHRydWUpLFxuICAgICAgICAgICAgICAgIG9uTW91c2VMZWF2ZTogKCkgPT4gc2V0VGltZW91dCgoKSA9PiBzZXRDb3B5QnV0dG9uSG92ZXJlZChmYWxzZSkpLFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uS2V5KCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjb3B5QnV0dG9uVGV4dCgpLnRyYW5zbGF0aW9uS2V5O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcHlCdXR0b25UZXh0KCkudGV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgVGV4dFN0eWxlZCQzID0gc3R5bGVkLmRpdmBcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgZm9udC13ZWlnaHQ6ICR7KHByb3BzKSA9PiBwcm9wcy5mb250V2VpZ2h0fTtcbiAgICBmb250LXNpemU6ICR7KHByb3BzKSA9PiBwcm9wcy5mb250U2l6ZX07XG4gICAgbGluZS1oZWlnaHQ6ICR7KHByb3BzKSA9PiBwcm9wcy5saW5lSGVpZ2h0fTtcblxuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMuY29sb3J9O1xuYDtcbmNvbnN0IFRleHQgPSAoaW5wdXRzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgbGV0IHRleHRSZWY7XG4gIGNvbnN0IGNvbG9yID0gKCkgPT4gaW5wdXRzLmNvbG9yIHx8IHRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnk7XG4gIGNvbnN0IHByb3BzID0gbWVyZ2VQcm9wcyh7XG4gICAgZm9udFNpemU6IFwiMTRweFwiLFxuICAgIGZvbnRXZWlnaHQ6IFwiNTEwXCIsXG4gICAgbGluZUhlaWdodDogXCIxMzAlXCJcbiAgfSwgaW5wdXRzKTtcbiAgY3JlYXRlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoIXRleHRSZWYpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHByb3BzLmN1cnNvciA9PT0gXCJ1bnNldFwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlKHRleHRSZWYpLmN1cnNvciAhPT0gXCJwb2ludGVyXCIpIHtcbiAgICAgIHRleHRSZWYuc3R5bGUuY3Vyc29yID0gXCJkZWZhdWx0XCI7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDMsIHtcbiAgICBnZXQgZm9udFNpemUoKSB7XG4gICAgICByZXR1cm4gcHJvcHMuZm9udFNpemU7XG4gICAgfSxcbiAgICBnZXQgZm9udFdlaWdodCgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5mb250V2VpZ2h0O1xuICAgIH0sXG4gICAgZ2V0IGxpbmVIZWlnaHQoKSB7XG4gICAgICByZXR1cm4gcHJvcHMubGluZUhlaWdodDtcbiAgICB9LFxuICAgIGdldCBjb2xvcigpIHtcbiAgICAgIHJldHVybiBjb2xvcigpO1xuICAgIH0sXG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgcmVmKHIkKSB7XG4gICAgICBjb25zdCBfcmVmJCA9IHRleHRSZWY7XG4gICAgICB0eXBlb2YgX3JlZiQgPT09IFwiZnVuY3Rpb25cIiA/IF9yZWYkKHIkKSA6IHRleHRSZWYgPSByJDtcbiAgICB9LFxuICAgIFwiZGF0YS10Yy10ZXh0XCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBjcmVhdGVNZW1vKCgpID0+ICEhcHJvcHMudHJhbnNsYXRpb25LZXkpKCkgPyB0Mihwcm9wcy50cmFuc2xhdGlvbktleSwgcHJvcHMudHJhbnNsYXRpb25WYWx1ZXMsIChfYSA9IHByb3BzLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IFdhbGxldEl0ZW1TdHlsZWQgPSBzdHlsZWQuYnV0dG9uYFxuICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICBib3JkZXI6IG5vbmU7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogdW5zZXQ7XG4gICAgcGFkZGluZzogMTJweCA4cHggOHB4O1xuICAgIGhlaWdodDogOTRweDtcbiAgICB3aWR0aDogOTJweDtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcblxuICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjEyNXMgZWFzZS1pbi1vdXQ7XG5cbiAgICAke21lZGlhTm90VG91Y2h9IHtcbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJjphY3RpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTYpO1xuICAgIH1cblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgcGFkZGluZzogOHB4IDRweDtcbiAgICAgICAgaGVpZ2h0OiAxMjRweDtcbiAgICAgICAgd2lkdGg6IDgycHg7XG4gICAgfVxuXG4gICAgJHttZWRpYVRvdWNofSB7XG4gICAgICAgICY6YWN0aXZlIHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Mik7XG4gICAgICAgIH1cbiAgICB9XG5gO1xuY29uc3QgSW1hZ2VTdHlsZWQkMSA9IHN0eWxlZChJbWFnZSlgXG4gICAgd2lkdGg6IDQ4cHg7XG4gICAgaGVpZ2h0OiA0OHB4O1xuICAgIGJvcmRlci1yYWRpdXM6IDEycHg7XG5cbiAgICBtYXJnaW4tYm90dG9tOiA4cHg7XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIHdpZHRoOiA2NHB4O1xuICAgICAgICBoZWlnaHQ6IDY0cHg7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDE2cHg7XG4gICAgfVxuYDtcbmNvbnN0IFN0eWxlZFRleHQgPSBzdHlsZWQoVGV4dClgXG4gICAgZm9udC13ZWlnaHQ6IDU5MDtcbiAgICBtYXgtd2lkdGg6IDc2cHg7XG4gICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xuYDtcbmNvbnN0IFdhbGxldEl0ZW0gPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChXYWxsZXRJdGVtU3R5bGVkLCB7XG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgb25DbGljazogKCkgPT4gcHJvcHMub25DbGljaygpLFxuICAgIFwiZGF0YS10Yy13YWxsZXQtaXRlbVwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChJbWFnZVN0eWxlZCQxLCB7XG4gICAgICAgIGdldCBzcmMoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLmljb25Vcmw7XG4gICAgICAgIH0sXG4gICAgICAgIGFsdDogXCJcIlxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTdHlsZWRUZXh0LCB7XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMubmFtZTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgSDFTdHlsZWQkMyA9IHN0eWxlZC5oMWBcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgICBmb250LXNpemU6IDI0cHg7XG4gICAgbGluZS1oZWlnaHQ6IDMwcHg7XG5cbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG5cbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnl9O1xuXG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiA2cHg7XG5cbiAgICBjdXJzb3I6IGRlZmF1bHQ7XG5gO1xuY29uc3QgSDEgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQzLCB7XG4gICAgZ2V0IFtcImNsYXNzXCJdKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmNsYXNzO1xuICAgIH0sXG4gICAgXCJkYXRhLXRjLWgxXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiBjcmVhdGVNZW1vKCgpID0+ICEhcHJvcHMudHJhbnNsYXRpb25LZXkpKCkgPyB0Mihwcm9wcy50cmFuc2xhdGlvbktleSwgcHJvcHMudHJhbnNsYXRpb25WYWx1ZXMsIChfYSA9IHByb3BzLmNoaWxkcmVuKSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9TdHJpbmcoKSkgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IEgyU3R5bGVkJDMgPSBzdHlsZWQuaDJgXG4gICAgZm9udC1zdHlsZTogbm9ybWFsO1xuICAgIGZvbnQtd2VpZ2h0OiA1MTA7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuXG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuXG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuXG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiAzMnB4O1xuXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuYDtcbmNvbnN0IEgyID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoSDJTdHlsZWQkMywge1xuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1oMlwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiAhIXByb3BzLnRyYW5zbGF0aW9uS2V5KSgpID8gdDIocHJvcHMudHJhbnNsYXRpb25LZXksIHByb3BzLnRyYW5zbGF0aW9uVmFsdWVzLCAoX2EgPSBwcm9wcy5jaGlsZHJlbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvU3RyaW5nKCkpIDogcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBIM1N0eWxlZCA9IHN0eWxlZC5oM2BcbiAgICBmb250LXN0eWxlOiBub3JtYWw7XG4gICAgZm9udC13ZWlnaHQ6IDU5MDtcbiAgICBmb250LXNpemU6IDE1cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG5cbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnl9O1xuXG4gICAgbWFyZ2luLXRvcDogMDtcbiAgICBtYXJnaW4tYm90dG9tOiAwO1xuXG4gICAgY3Vyc29yOiBkZWZhdWx0O1xuYDtcbmNvbnN0IEgzID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoSDNTdHlsZWQsIHtcbiAgICBcImRhdGEtdGMtaDNcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4gISFwcm9wcy50cmFuc2xhdGlvbktleSkoKSA/IHQyKHByb3BzLnRyYW5zbGF0aW9uS2V5LCBwcm9wcy50cmFuc2xhdGlvblZhbHVlcywgKF9hID0gcHJvcHMuY2hpbGRyZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYS50b1N0cmluZygpKSA6IHByb3BzLmNoaWxkcmVuO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgX3RtcGwkJGMgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD1cIjE4XCIgaGVpZ2h0PVwiMTdcIiB2aWV3Qm94PVwiMCAwIDE4IDE3XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xLjUgMTUuOTk5TDE2LjUgMC45OTkwMjNNMTYuNSAwLjk5OTAyM1YxMi45OTlNMTYuNSAwLjk5OTAyM0g0LjVcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PC9wYXRoPjwvc3ZnPmApO1xuY29uc3QgTG9uZ0Fycm93SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnNlY29uZGFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgY29uc3QgX2VsJCA9IF90bXBsJCRjLmNsb25lTm9kZSh0cnVlKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMiwgXCJzdHJva2VcIiwgZmlsbCgpKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xuY29uc3QgX3RtcGwkJGIgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZmlsbC1ydWxlPVwiZXZlbm9kZFwiIGNsaXAtcnVsZT1cImV2ZW5vZGRcIiBkPVwiTTE0LjE4MzkgMTcuNzA2OUMxMy42NDA1IDE4LjY1MDcgMTMuMzY4OCAxOS4xMjI2IDEzLjA1OTEgMTkuMzQ4QzEyLjQyNzggMTkuODA3NCAxMS41NzIzIDE5LjgwNzQgMTAuOTQxIDE5LjM0OEMxMC42MzEyIDE5LjEyMjYgMTAuMzU5NSAxOC42NTA3IDkuODE2MTMgMTcuNzA2OUw1LjUyMDY2IDEwLjI0NjRDNC43Njg2NCA4Ljk0MDI0IDQuMzkyNjMgOC4yODcxNyA0LjMzNzYyIDcuNzU4OTRDNC4yMjU1IDYuNjgyMzYgNC44MTg5NCA1LjY1NTkxIDUuODA3ODggNS4yMTU4OUM2LjI5MzA5IDUgNy4wNDY2NyA1IDguNTUzODMgNUgxNS40NDYyQzE2Ljk1MzQgNSAxNy43MDY5IDUgMTguMTkyMiA1LjIxNTg5QzE5LjE4MTEgNS42NTU5MSAxOS43NzQ1IDYuNjgyMzYgMTkuNjYyNCA3Ljc1ODk0QzE5LjYwNzQgOC4yODcxNyAxOS4yMzE0IDguOTQwMjQgMTguNDc5NCAxMC4yNDY0TDE0LjE4MzkgMTcuNzA2OVpNMTEuMSAxNi4zNDEyTDYuNTYxMzkgOC40ODAwMkM2LjMxOTk1IDguMDYxODUgNi4xOTkyNCA3Ljg1Mjc2IDYuMTgxNDYgNy42ODM2NUM2LjE0NTIzIDcuMzM4OTYgNi4zMzUwNyA3LjAxMDE1IDYuNjUxNjkgNi44NjkxOUM2LjgwNzAzIDYuODAwMDIgNy4wNDg0NyA2LjgwMDAyIDcuNTMxMzMgNi44MDAwMkg3LjUzMTM0TDExLjEgNi44MDAwMlYxNi4zNDEyWk0xMi45IDE2LjM0MTJMMTcuNDM4NyA4LjQ4MDAyQzE3LjY4MDEgOC4wNjE4NSAxNy44MDA4IDcuODUyNzYgMTcuODE4NiA3LjY4MzY1QzE3Ljg1NDggNy4zMzg5NiAxNy42NjUgNy4wMTAxNSAxNy4zNDg0IDYuODY5MTlDMTcuMTkzIDYuODAwMDIgMTYuOTUxNiA2LjgwMDAyIDE2LjQ2ODcgNi44MDAwMkwxMi45IDYuODAwMDJWMTYuMzQxMlpcIj48L3BhdGg+PC9zdmc+YCk7XG5jb25zdCBUb25JY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24ucHJpbWFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgY29uc3QgX2VsJCA9IF90bXBsJCRiLmNsb25lTm9kZSh0cnVlKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQ7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KCgpID0+IHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIGZpbGwoKSkpO1xuICAgIHJldHVybiBfZWwkO1xuICB9KSgpO1xufTtcbmNvbnN0IF90bXBsJCRhID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiMTFcIj48L2NpcmNsZT48cGF0aCBkPVwiTTE3LjEzNjQgOS42MzY0QzE3LjQ4NzkgOS4yODQ5MyAxNy40ODc5IDguNzE1MDggMTcuMTM2NCA4LjM2MzYxQzE2Ljc4NDkgOC4wMTIxNCAxNi4yMTUxIDguMDEyMTQgMTUuODYzNiA4LjM2MzYxTDEwIDE0LjIyNzJMOC4xMzY0IDEyLjM2MzZDNy43ODQ5MyAxMi4wMTIxIDcuMjE1MDggMTIuMDEyMSA2Ljg2MzYxIDEyLjM2MzZDNi41MTIxNCAxMi43MTUxIDYuNTEyMTQgMTMuMjg0OSA2Ljg2MzYxIDEzLjYzNjRMOS4zNjM2MSAxNi4xMzY0QzkuNzE1MDggMTYuNDg3OSAxMC4yODQ5IDE2LjQ4NzkgMTAuNjM2NCAxNi4xMzY0TDE3LjEzNjQgOS42MzY0WlwiPjwvcGF0aD48L3N2Zz5gKSwgX3RtcGwkMiQzID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9XCI3MlwiIGhlaWdodD1cIjcyXCIgdmlld0JveD1cIjAgMCA3MiA3MlwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxjaXJjbGUgY3g9XCIzNlwiIGN5PVwiMzZcIiByPVwiMzNcIj48L2NpcmNsZT48cGF0aCBkPVwiTTUwLjkxNDIgMjguNDE0MkM1MS42OTUzIDI3LjYzMzIgNTEuNjk1MyAyNi4zNjY4IDUwLjkxNDIgMjUuNTg1OEM1MC4xMzMyIDI0LjgwNDcgNDguODY2OCAyNC44MDQ3IDQ4LjA4NTggMjUuNTg1OEwzMCA0My42NzE2TDIzLjkxNDIgMzcuNTg1OEMyMy4xMzMyIDM2LjgwNDcgMjEuODY2OCAzNi44MDQ3IDIxLjA4NTggMzcuNTg1OEMyMC4zMDQ3IDM4LjM2NjggMjAuMzA0NyAzOS42MzMyIDIxLjA4NTggNDAuNDE0MkwyOC41ODU4IDQ3LjkxNDJDMjkuMzY2OCA0OC42OTUzIDMwLjYzMzIgNDguNjk1MyAzMS40MTQyIDQ3LjkxNDJMNTAuOTE0MiAyOC40MTQyWlwiPjwvcGF0aD48L3N2Zz5gKTtcbmNvbnN0IFN1Y2Nlc3NJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3Qgc2l6ZSA9ICgpID0+IHByb3BzLnNpemUgfHwgXCJzXCI7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnN1Y2Nlc3M7XG4gIHJldHVybiBjcmVhdGVNZW1vKCgoKSA9PiB7XG4gICAgY29uc3QgX2MkID0gY3JlYXRlTWVtbygoKSA9PiBzaXplKCkgPT09IFwic1wiKTtcbiAgICByZXR1cm4gKCkgPT4gX2MkKCkgPyAoKCkgPT4ge1xuICAgICAgY29uc3QgX2VsJCA9IF90bXBsJCRhLmNsb25lTm9kZSh0cnVlKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQsIF9lbCQzID0gX2VsJDIubmV4dFNpYmxpbmc7XG4gICAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgICBjb25zdCBfdiQgPSBwcm9wcy5jbGFzcywgX3YkMiA9IGZpbGwoKSwgX3YkMyA9IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZTtcbiAgICAgICAgX3YkICE9PSBfcCQuX3YkICYmIHNldEF0dHJpYnV0ZShfZWwkLCBcImNsYXNzXCIsIF9wJC5fdiQgPSBfdiQpO1xuICAgICAgICBfdiQyICE9PSBfcCQuX3YkMiAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQuX3YkMiA9IF92JDIpO1xuICAgICAgICBfdiQzICE9PSBfcCQuX3YkMyAmJiBzZXRBdHRyaWJ1dGUoX2VsJDMsIFwiZmlsbFwiLCBfcCQuX3YkMyA9IF92JDMpO1xuICAgICAgICByZXR1cm4gX3AkO1xuICAgICAgfSwge1xuICAgICAgICBfdiQ6IHZvaWQgMCxcbiAgICAgICAgX3YkMjogdm9pZCAwLFxuICAgICAgICBfdiQzOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgfSkoKSA6ICgoKSA9PiB7XG4gICAgICBjb25zdCBfZWwkNCA9IF90bXBsJDIkMy5jbG9uZU5vZGUodHJ1ZSksIF9lbCQ1ID0gX2VsJDQuZmlyc3RDaGlsZCwgX2VsJDYgPSBfZWwkNS5uZXh0U2libGluZztcbiAgICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICAgIGNvbnN0IF92JDQgPSBwcm9wcy5jbGFzcywgX3YkNSA9IGZpbGwoKSwgX3YkNiA9IHRoZW1lLmNvbG9ycy5jb25zdGFudC53aGl0ZTtcbiAgICAgICAgX3YkNCAhPT0gX3AkLl92JDQgJiYgc2V0QXR0cmlidXRlKF9lbCQ0LCBcImNsYXNzXCIsIF9wJC5fdiQ0ID0gX3YkNCk7XG4gICAgICAgIF92JDUgIT09IF9wJC5fdiQ1ICYmIHNldEF0dHJpYnV0ZShfZWwkNSwgXCJmaWxsXCIsIF9wJC5fdiQ1ID0gX3YkNSk7XG4gICAgICAgIF92JDYgIT09IF9wJC5fdiQ2ICYmIHNldEF0dHJpYnV0ZShfZWwkNiwgXCJmaWxsXCIsIF9wJC5fdiQ2ID0gX3YkNik7XG4gICAgICAgIHJldHVybiBfcCQ7XG4gICAgICB9LCB7XG4gICAgICAgIF92JDQ6IHZvaWQgMCxcbiAgICAgICAgX3YkNTogdm9pZCAwLFxuICAgICAgICBfdiQ2OiB2b2lkIDBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9lbCQ0O1xuICAgIH0pKCk7XG4gIH0pKCkpO1xufTtcbmNvbnN0IF90bXBsJCQ5ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9XCIyNFwiIGhlaWdodD1cIjI0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiMTFcIj48L2NpcmNsZT48cGF0aCBkPVwiTTcuODYzNjEgOS4xMzY0QzcuNTEyMTQgOC43ODQ5MyA3LjUxMjE0IDguMjE1MDggNy44NjM2MSA3Ljg2MzYxQzguMjE1MDggNy41MTIxNCA4Ljc4NDkzIDcuNTEyMTQgOS4xMzY0IDcuODYzNjFMMTIgMTAuNzI3MkwxNC44NjM2IDcuODYzNjFDMTUuMjE1MSA3LjUxMjE0IDE1Ljc4NDkgNy41MTIxNCAxNi4xMzY0IDcuODYzNjFDMTYuNDg3OSA4LjIxNTA4IDE2LjQ4NzkgOC43ODQ5MyAxNi4xMzY0IDkuMTM2NEwxMy4yNzI4IDEyTDE2LjEzNjQgMTQuODYzNkMxNi40ODc5IDE1LjIxNTEgMTYuNDg3OSAxNS43ODQ5IDE2LjEzNjQgMTYuMTM2NEMxNS43ODQ5IDE2LjQ4NzkgMTUuMjE1MSAxNi40ODc5IDE0Ljg2MzYgMTYuMTM2NEwxMiAxMy4yNzI4TDkuMTM2NCAxNi4xMzY0QzguNzg0OTMgMTYuNDg3OSA4LjIxNTA4IDE2LjQ4NzkgNy44NjM2MSAxNi4xMzY0QzcuNTEyMTQgMTUuNzg0OSA3LjUxMjE0IDE1LjIxNTEgNy44NjM2MSAxNC44NjM2TDEwLjcyNzIgMTJMNy44NjM2MSA5LjEzNjRaXCI+PC9wYXRoPjwvc3ZnPmApLCBfdG1wbCQyJDIgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD1cIjcyXCIgaGVpZ2h0PVwiNzJcIiB2aWV3Qm94PVwiMCAwIDcyIDcyXCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PGNpcmNsZSBjeD1cIjM2XCIgY3k9XCIzNlwiIHI9XCIzM1wiPjwvY2lyY2xlPjxwYXRoIGQ9XCJNMjQuMDg1OCAyNi45MTQyQzIzLjMwNDcgMjYuMTMzMiAyMy4zMDQ3IDI0Ljg2NjggMjQuMDg1OCAyNC4wODU4QzI0Ljg2NjggMjMuMzA0NyAyNi4xMzMyIDIzLjMwNDcgMjYuOTE0MiAyNC4wODU4TDM2IDMzLjE3MTZMNDUuMDg1OCAyNC4wODU4QzQ1Ljg2NjggMjMuMzA0NyA0Ny4xMzMyIDIzLjMwNDcgNDcuOTE0MiAyNC4wODU4QzQ4LjY5NTMgMjQuODY2OCA0OC42OTUzIDI2LjEzMzIgNDcuOTE0MiAyNi45MTQyTDM4LjgyODQgMzZMNDcuOTE0MiA0NS4wODU4QzQ4LjY5NTMgNDUuODY2OCA0OC42OTUzIDQ3LjEzMzIgNDcuOTE0MiA0Ny45MTQyQzQ3LjEzMzIgNDguNjk1MyA0NS44NjY4IDQ4LjY5NTMgNDUuMDg1OCA0Ny45MTQyTDM2IDM4LjgyODRMMjYuOTE0MiA0Ny45MTQyQzI2LjEzMzIgNDguNjk1MyAyNC44NjY4IDQ4LjY5NTMgMjQuMDg1OCA0Ny45MTQyQzIzLjMwNDcgNDcuMTMzMiAyMy4zMDQ3IDQ1Ljg2NjggMjQuMDg1OCA0NS4wODU4TDMzLjE3MTYgMzZMMjQuMDg1OCAyNi45MTQyWlwiPjwvcGF0aD48L3N2Zz5gKTtcbmNvbnN0IEVycm9ySWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IHNpemUgPSAoKSA9PiBwcm9wcy5zaXplIHx8IFwic1wiO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi5lcnJvcjtcbiAgcmV0dXJuIGNyZWF0ZU1lbW8oKCgpID0+IHtcbiAgICBjb25zdCBfYyQgPSBjcmVhdGVNZW1vKCgpID0+IHNpemUoKSA9PT0gXCJzXCIpO1xuICAgIHJldHVybiAoKSA9PiBfYyQoKSA/ICgoKSA9PiB7XG4gICAgICBjb25zdCBfZWwkID0gX3RtcGwkJDkuY2xvbmVOb2RlKHRydWUpLCBfZWwkMiA9IF9lbCQuZmlyc3RDaGlsZCwgX2VsJDMgPSBfZWwkMi5uZXh0U2libGluZztcbiAgICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICAgIGNvbnN0IF92JCA9IHByb3BzLmNsYXNzLCBfdiQyID0gZmlsbCgpLCBfdiQzID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlO1xuICAgICAgICBfdiQgIT09IF9wJC5fdiQgJiYgc2V0QXR0cmlidXRlKF9lbCQsIFwiY2xhc3NcIiwgX3AkLl92JCA9IF92JCk7XG4gICAgICAgIF92JDIgIT09IF9wJC5fdiQyICYmIHNldEF0dHJpYnV0ZShfZWwkMiwgXCJmaWxsXCIsIF9wJC5fdiQyID0gX3YkMik7XG4gICAgICAgIF92JDMgIT09IF9wJC5fdiQzICYmIHNldEF0dHJpYnV0ZShfZWwkMywgXCJmaWxsXCIsIF9wJC5fdiQzID0gX3YkMyk7XG4gICAgICAgIHJldHVybiBfcCQ7XG4gICAgICB9LCB7XG4gICAgICAgIF92JDogdm9pZCAwLFxuICAgICAgICBfdiQyOiB2b2lkIDAsXG4gICAgICAgIF92JDM6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2VsJDtcbiAgICB9KSgpIDogKCgpID0+IHtcbiAgICAgIGNvbnN0IF9lbCQ0ID0gX3RtcGwkMiQyLmNsb25lTm9kZSh0cnVlKSwgX2VsJDUgPSBfZWwkNC5maXJzdENoaWxkLCBfZWwkNiA9IF9lbCQ1Lm5leHRTaWJsaW5nO1xuICAgICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgICAgY29uc3QgX3YkNCA9IHByb3BzLmNsYXNzLCBfdiQ1ID0gZmlsbCgpLCBfdiQ2ID0gdGhlbWUuY29sb3JzLmNvbnN0YW50LndoaXRlO1xuICAgICAgICBfdiQ0ICE9PSBfcCQuX3YkNCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDQsIFwiY2xhc3NcIiwgX3AkLl92JDQgPSBfdiQ0KTtcbiAgICAgICAgX3YkNSAhPT0gX3AkLl92JDUgJiYgc2V0QXR0cmlidXRlKF9lbCQ1LCBcImZpbGxcIiwgX3AkLl92JDUgPSBfdiQ1KTtcbiAgICAgICAgX3YkNiAhPT0gX3AkLl92JDYgJiYgc2V0QXR0cmlidXRlKF9lbCQ2LCBcImZpbGxcIiwgX3AkLl92JDYgPSBfdiQ2KTtcbiAgICAgICAgcmV0dXJuIF9wJDtcbiAgICAgIH0sIHtcbiAgICAgICAgX3YkNDogdm9pZCAwLFxuICAgICAgICBfdiQ1OiB2b2lkIDAsXG4gICAgICAgIF92JDY6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gX2VsJDQ7XG4gICAgfSkoKTtcbiAgfSkoKSk7XG59O1xuY29uc3QgX3RtcGwkJDggPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPHN2ZyB3aWR0aD1cIjI0XCIgaGVpZ2h0PVwiMjRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHBhdGggZD1cIk0xNS41NSA1Ljg1MTIzQzE4Ljk0NTkgNy44MTE4NCAyMC4xMDk0IDEyLjE1NDEgMTguMTQ4OCAxNS41NUMxNi4xODgyIDE4Ljk0NTkgMTEuODQ1OSAyMC4xMDk0IDguNDQ5OTggMTguMTQ4OEM4LjAxOTUyIDE3LjkwMDMgNy40NjkwOSAxOC4wNDc4IDcuMjIwNTYgMTguNDc4MkM2Ljk3MjAzIDE4LjkwODcgNy4xMTk1MiAxOS40NTkxIDcuNTQ5OTggMTkuNzA3NkMxMS44MDY4IDIyLjE2NTMgMTcuMjQ5OSAyMC43MDY4IDE5LjcwNzYgMTYuNDVDMjIuMTY1MyAxMi4xOTMyIDIwLjcwNjggNi43NTAwNSAxNi40NSA0LjI5MjM5QzEyLjE5MzIgMS44MzQ3MiA2Ljc1MDAzIDMuMjkzMjEgNC4yOTIzNiA3LjU1MDAxQzQuMDQzODMgNy45ODA0NyA0LjE5MTMyIDguNTMwOTEgNC42MjE3OCA4Ljc3OTQzQzUuMDUyMjQgOS4wMjc5NiA1LjYwMjY4IDguODgwNDggNS44NTEyIDguNDUwMDFDNy44MTE4MSA1LjA1NDEzIDEyLjE1NDEgMy44OTA2MiAxNS41NSA1Ljg1MTIzWlwiPjwvcGF0aD48L3N2Zz5gKSwgX3RtcGwkMiQxID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxzdmcgd2lkdGg9XCI3MlwiIGhlaWdodD1cIjcyXCIgdmlld0JveD1cIjAgMCA3MiA3MlwiIGZpbGw9XCJub25lXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxwYXRoIGQ9XCJNMjQgNTYuNzg0NkMzNS40NzkgNjMuNDEyIDUwLjE1NzIgNTkuNDc5IDU2Ljc4NDYgNDcuOTk5OUM2My40MTIgMzYuNTIwOSA1OS40NzkgMjEuODQyNyA0OCAxNS4yMTUzQzM2LjUyMSA4LjU4NzkxIDIxLjg0MjggMTIuNTIwOSAxNS4yMTU0IDIzLjk5OTlcIiBzdHJva2Utd2lkdGg9XCI0XCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PC9wYXRoPjwvc3ZnPmApO1xuY29uc3QgTG9hZGVySWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IHNpemUgPSAoKSA9PiBwcm9wcy5zaXplIHx8IFwic1wiO1xuICBjb25zdCBmaWxsID0gKCkgPT4gcHJvcHMuZmlsbCB8fCB0aGVtZS5jb2xvcnMuaWNvbi50ZXJ0aWFyeTtcbiAgY29uc3Qgcm90YXRlQW5pbWF0aW9uID0gaGBcbiAgICAgICAgMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XG4gICAgICAgIH1cbiAgICBgO1xuICBjb25zdCBzdmdDbGFzcyA9IHVgXG4gICAgICAgIGFuaW1hdGlvbjogJHtyb3RhdGVBbmltYXRpb259IDFzIGxpbmVhciBpbmZpbml0ZTtcbiAgICBgO1xuICByZXR1cm4gY3JlYXRlTWVtbygoKCkgPT4ge1xuICAgIGNvbnN0IF9jJCA9IGNyZWF0ZU1lbW8oKCkgPT4gc2l6ZSgpID09PSBcInNcIik7XG4gICAgcmV0dXJuICgpID0+IF9jJCgpID8gKCgpID0+IHtcbiAgICAgIGNvbnN0IF9lbCQgPSBfdG1wbCQkOC5jbG9uZU5vZGUodHJ1ZSksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgICAgY29uc3QgX3YkID0gY24oc3ZnQ2xhc3MsIHByb3BzLmNsYXNzKSwgX3YkMiA9IGZpbGwoKTtcbiAgICAgICAgX3YkICE9PSBfcCQuX3YkICYmIHNldEF0dHJpYnV0ZShfZWwkLCBcImNsYXNzXCIsIF9wJC5fdiQgPSBfdiQpO1xuICAgICAgICBfdiQyICE9PSBfcCQuX3YkMiAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQuX3YkMiA9IF92JDIpO1xuICAgICAgICByZXR1cm4gX3AkO1xuICAgICAgfSwge1xuICAgICAgICBfdiQ6IHZvaWQgMCxcbiAgICAgICAgX3YkMjogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfZWwkO1xuICAgIH0pKCkgOiAoKCkgPT4ge1xuICAgICAgY29uc3QgX2VsJDMgPSBfdG1wbCQyJDEuY2xvbmVOb2RlKHRydWUpLCBfZWwkNCA9IF9lbCQzLmZpcnN0Q2hpbGQ7XG4gICAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKF9wJCkgPT4ge1xuICAgICAgICBjb25zdCBfdiQzID0gY24oc3ZnQ2xhc3MsIHByb3BzLmNsYXNzKSwgX3YkNCA9IGZpbGwoKTtcbiAgICAgICAgX3YkMyAhPT0gX3AkLl92JDMgJiYgc2V0QXR0cmlidXRlKF9lbCQzLCBcImNsYXNzXCIsIF9wJC5fdiQzID0gX3YkMyk7XG4gICAgICAgIF92JDQgIT09IF9wJC5fdiQ0ICYmIHNldEF0dHJpYnV0ZShfZWwkNCwgXCJzdHJva2VcIiwgX3AkLl92JDQgPSBfdiQ0KTtcbiAgICAgICAgcmV0dXJuIF9wJDtcbiAgICAgIH0sIHtcbiAgICAgICAgX3YkMzogdm9pZCAwLFxuICAgICAgICBfdiQ0OiB2b2lkIDBcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIF9lbCQzO1xuICAgIH0pKCk7XG4gIH0pKCkpO1xufTtcbmNvbnN0IFRvbkNvbm5lY3RVaUNvbnRleHQgPSBjcmVhdGVDb250ZXh0KCk7XG5jb25zdCBfdG1wbCQkNyA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBmaWxsLXJ1bGU9XCJldmVub2RkXCIgY2xpcC1ydWxlPVwiZXZlbm9kZFwiIGQ9XCJNNy43NjIyOCAyLjA5OTk4SDEwLjIzNzhDMTEuMDQ1OCAyLjA5OTk3IDExLjcwNjcgMi4wOTk5NiAxMi4yNDM4IDIuMTQzODRDMTIuNzk5NyAyLjE4OTI2IDEzLjMwMTcgMi4yODYxNCAxMy43NzA2IDIuNTI1MDVDMTQuNTA0NSAyLjg5ODk2IDE1LjEwMTEgMy40OTU1OCAxNS40NzUgNC4yMjk0MUMxNS43MTM5IDQuNjk4MyAxNS44MTA4IDUuMjAwMzggMTUuODU2MiA1Ljc1NjI5QzE1LjkwMDEgNi4yOTMzNyAxNS45MDAxIDYuOTU0MjIgMTUuOTAwMSA3Ljc2MjI3VjguMUgxNi4yMzc3QzE3LjA0NTcgOC4wOTk5OSAxNy43MDY2IDguMDk5OTggMTguMjQzNyA4LjE0Mzg2QzE4Ljc5OTYgOC4xODkyOCAxOS4zMDE3IDguMjg2MTYgMTkuNzcwNSA4LjUyNTA3QzIwLjUwNDQgOC44OTg5OCAyMS4xMDEgOS40OTU2IDIxLjQ3NDkgMTAuMjI5NEMyMS43MTM4IDEwLjY5ODMgMjEuODEwNyAxMS4yMDA0IDIxLjg1NjEgMTEuNzU2M0MyMS45IDEyLjI5MzQgMjEuOSAxMi45NTQyIDIxLjkgMTMuNzYyM1YxNi4yMzc3QzIxLjkgMTcuMDQ1OCAyMS45IDE3LjcwNjYgMjEuODU2MSAxOC4yNDM3QzIxLjgxMDcgMTguNzk5NiAyMS43MTM4IDE5LjMwMTcgMjEuNDc0OSAxOS43NzA2QzIxLjEwMSAyMC41MDQ0IDIwLjUwNDQgMjEuMTAxIDE5Ljc3MDUgMjEuNDc0OUMxOS4zMDE3IDIxLjcxMzggMTguNzk5NiAyMS44MTA3IDE4LjI0MzcgMjEuODU2MUMxNy43MDY2IDIxLjkgMTcuMDQ1OCAyMS45IDE2LjIzNzggMjEuOUgxMy43NjIzQzEyLjk1NDMgMjEuOSAxMi4yOTM0IDIxLjkgMTEuNzU2MyAyMS44NTYxQzExLjIwMDQgMjEuODEwNyAxMC42OTgzIDIxLjcxMzggMTAuMjI5NCAyMS40NzQ5QzkuNDk1NjEgMjEuMTAxIDguODk4OTggMjAuNTA0NCA4LjUyNTA4IDE5Ljc3MDZDOC4yODYxNiAxOS4zMDE3IDguMTg5MjggMTguNzk5NiA4LjE0Mzg2IDE4LjI0MzdDOC4wOTk5OCAxNy43MDY2IDguMDk5OTkgMTcuMDQ1OCA4LjEgMTYuMjM3N1YxNS45SDcuNzYyMjdDNi45NTQyNiAxNS45IDYuMjkzMzUgMTUuOSA1Ljc1NjI5IDE1Ljg1NjFDNS4yMDAzOCAxNS44MTA3IDQuNjk4MyAxNS43MTM4IDQuMjI5NDEgMTUuNDc0OUMzLjQ5NTU4IDE1LjEwMSAyLjg5ODk2IDE0LjUwNDQgMi41MjUwNSAxMy43NzA1QzIuMjg2MTQgMTMuMzAxNyAyLjE4OTI2IDEyLjc5OTYgMi4xNDM4NCAxMi4yNDM3QzIuMDk5OTYgMTEuNzA2NiAyLjA5OTk3IDExLjA0NTggMi4wOTk5OCAxMC4yMzc3VjcuNzYyMjhDMi4wOTk5NyA2Ljk1NDI0IDIuMDk5OTYgNi4yOTMzNiAyLjE0Mzg0IDUuNzU2MjlDMi4xODkyNiA1LjIwMDM4IDIuMjg2MTQgNC42OTgzIDIuNTI1MDUgNC4yMjk0MUMyLjg5ODk2IDMuNDk1NTggMy40OTU1OCAyLjg5ODk2IDQuMjI5NDEgMi41MjUwNUM0LjY5ODMgMi4yODYxNCA1LjIwMDM4IDIuMTg5MjYgNS43NTYyOSAyLjE0Mzg0QzYuMjkzMzYgMi4wOTk5NiA2Ljk1NDI1IDIuMDk5OTcgNy43NjIyOCAyLjA5OTk4Wk04LjEgMTQuMVYxMy43NjIzQzguMDk5OTkgMTIuOTU0MiA4LjA5OTk4IDEyLjI5MzQgOC4xNDM4NiAxMS43NTYzQzguMTg5MjggMTEuMjAwNCA4LjI4NjE2IDEwLjY5ODMgOC41MjUwOCAxMC4yMjk0QzguODk4OTggOS40OTU2IDkuNDk1NjEgOC44OTg5OCAxMC4yMjk0IDguNTI1MDdDMTAuNjk4MyA4LjI4NjE2IDExLjIwMDQgOC4xODkyOCAxMS43NTYzIDguMTQzODZDMTIuMjkzNCA4LjA5OTk4IDEyLjk1NDIgOC4wOTk5OSAxMy43NjIzIDguMUgxNC4xMDAxVjcuNzk5OThDMTQuMTAwMSA2Ljk0NTA1IDE0LjA5OTQgNi4zNTc5OCAxNC4wNjIyIDUuOTAyODdDMTQuMDI1OSA1LjQ1ODI3IDEzLjk1OTMgNS4yMTk0NCAxMy44NzEyIDUuMDQ2NkMxMy42Njk5IDQuNjUxNDYgMTMuMzQ4NiA0LjMzMDIgMTIuOTUzNSA0LjEyODg2QzEyLjc4MDYgNC4wNDA3OSAxMi41NDE4IDMuOTc0MTkgMTIuMDk3MiAzLjkzNzg2QzExLjY0MjEgMy45MDA2OCAxMS4wNTUgMy44OTk5OCAxMC4yMDAxIDMuODk5OThINy43OTk5OEM2Ljk0NTA1IDMuODk5OTggNi4zNTc5OCAzLjkwMDY4IDUuOTAyODcgMy45Mzc4NkM1LjQ1ODI3IDMuOTc0MTkgNS4yMTk0NCA0LjA0MDc5IDUuMDQ2NiA0LjEyODg2QzQuNjUxNDYgNC4zMzAyIDQuMzMwMiA0LjY1MTQ2IDQuMTI4ODYgNS4wNDY2QzQuMDQwNzkgNS4yMTk0NCAzLjk3NDE5IDUuNDU4MjcgMy45Mzc4NiA1LjkwMjg3QzMuOTAwNjggNi4zNTc5OCAzLjg5OTk4IDYuOTQ1MDUgMy44OTk5OCA3Ljc5OTk4VjEwLjJDMy44OTk5OCAxMS4wNTQ5IDMuOTAwNjggMTEuNjQyIDMuOTM3ODYgMTIuMDk3MUMzLjk3NDE5IDEyLjU0MTcgNC4wNDA3OSAxMi43ODA1IDQuMTI4ODYgMTIuOTUzNEM0LjMzMDIgMTMuMzQ4NSA0LjY1MTQ2IDEzLjY2OTggNS4wNDY2IDEzLjg3MTFDNS4yMTk0NCAxMy45NTkyIDUuNDU4MjcgMTQuMDI1OCA1LjkwMjg3IDE0LjA2MjFDNi4zNTc5OCAxNC4wOTkzIDYuOTQ1MDUgMTQuMSA3Ljc5OTk4IDE0LjFIOC4xWk0xMS4wNDY2IDEwLjEyODlDMTEuMjE5NSAxMC4wNDA4IDExLjQ1ODMgOS45NzQyMSAxMS45MDI5IDkuOTM3ODhDMTIuMzU4IDkuOTAwNyAxMi45NDUxIDkuOSAxMy44IDkuOUgxNi4yQzE3LjA1NDkgOS45IDE3LjY0MiA5LjkwMDcgMTguMDk3MSA5LjkzNzg4QzE4LjU0MTcgOS45NzQyMSAxOC43ODA1IDEwLjA0MDggMTguOTUzNCAxMC4xMjg5QzE5LjM0ODUgMTAuMzMwMiAxOS42Njk4IDEwLjY1MTUgMTkuODcxMSAxMS4wNDY2QzE5Ljk1OTIgMTEuMjE5NSAyMC4wMjU4IDExLjQ1ODMgMjAuMDYyMSAxMS45MDI5QzIwLjA5OTMgMTIuMzU4IDIwLjEgMTIuOTQ1MSAyMC4xIDEzLjhWMTYuMkMyMC4xIDE3LjA1NDkgMjAuMDk5MyAxNy42NDIgMjAuMDYyMSAxOC4wOTcxQzIwLjAyNTggMTguNTQxNyAxOS45NTkyIDE4Ljc4MDUgMTkuODcxMSAxOC45NTM0QzE5LjY2OTggMTkuMzQ4NSAxOS4zNDg1IDE5LjY2OTggMTguOTUzNCAxOS44NzExQzE4Ljc4MDUgMTkuOTU5MiAxOC41NDE3IDIwLjAyNTggMTguMDk3MSAyMC4wNjIxQzE3LjY0MiAyMC4wOTkzIDE3LjA1NDkgMjAuMSAxNi4yIDIwLjFIMTMuOEMxMi45NDUxIDIwLjEgMTIuMzU4IDIwLjA5OTMgMTEuOTAyOSAyMC4wNjIxQzExLjQ1ODMgMjAuMDI1OCAxMS4yMTk1IDE5Ljk1OTIgMTEuMDQ2NiAxOS44NzExQzEwLjY1MTUgMTkuNjY5OCAxMC4zMzAyIDE5LjM0ODUgMTAuMTI4OSAxOC45NTM0QzEwLjA0MDggMTguNzgwNSA5Ljk3NDIxIDE4LjU0MTcgOS45Mzc4OCAxOC4wOTcxQzkuOTAwNyAxNy42NDIgOS45IDE3LjA1NDkgOS45IDE2LjJWMTMuOEM5LjkgMTIuOTQ1MSA5LjkwMDcgMTIuMzU4IDkuOTM3ODggMTEuOTAyOUM5Ljk3NDIxIDExLjQ1ODMgMTAuMDQwOCAxMS4yMTk1IDEwLjEyODkgMTEuMDQ2NkMxMC4zMzAyIDEwLjY1MTUgMTAuNjUxNSAxMC4zMzAyIDExLjA0NjYgMTAuMTI4OVpcIj48L3BhdGg+PC9zdmc+YCk7XG5jb25zdCBDb3B5SWNvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IGZpbGwgPSAoKSA9PiBwcm9wcy5maWxsIHx8IHRoZW1lLmNvbG9ycy5pY29uLnByaW1hcnk7XG4gIHJldHVybiAoKCkgPT4ge1xuICAgIGNvbnN0IF9lbCQgPSBfdG1wbCQkNy5jbG9uZU5vZGUodHJ1ZSksIF9lbCQyID0gX2VsJC5maXJzdENoaWxkO1xuICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoKSA9PiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBmaWxsKCkpKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG5jb25zdCBfdG1wbCQkNiA9IC8qIEBfX1BVUkVfXyAqLyB0ZW1wbGF0ZSQxKGA8c3ZnIHdpZHRoPVwiMjRcIiBoZWlnaHQ9XCIyNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cGF0aCBkPVwiTTguNzYyNCAzLjEwMDAxQzcuOTU0MzUgMy4xIDcuMjkzNDkgMy4wOTk5OSA2Ljc1NjQyIDMuMTQzODdDNi4yMDA1IDMuMTg5MjkgNS42OTg0MiAzLjI4NjE3IDUuMjI5NTQgMy41MjUwOEM0LjQ5NTcgMy44OTg5OSAzLjg5OTA4IDQuNDk1NjEgMy41MjUxNyA1LjIyOTQ0QzMuMjg2MjYgNS42OTgzMyAzLjE4OTM4IDYuMjAwNDEgMy4xNDM5NiA2Ljc1NjMyQzMuMTAwMDggNy4yOTM0IDMuMTAwMDkgNy45NTQyNCAzLjEwMDEgOC43NjIyOVYxNS4yMzc3QzMuMTAwMDkgMTYuMDQ1OCAzLjEwMDA4IDE2LjcwNjYgMy4xNDM5NiAxNy4yNDM3QzMuMTg5MzggMTcuNzk5NiAzLjI4NjI2IDE4LjMwMTcgMy41MjUxNyAxOC43NzA2QzMuODk5MDggMTkuNTA0NCA0LjQ5NTcgMjAuMTAxIDUuMjI5NTQgMjAuNDc0OUM1LjY5ODQyIDIwLjcxMzggNi4yMDA1IDIwLjgxMDcgNi43NTY0MiAyMC44NTYxQzcuMjkzNDkgMjAuOSA3Ljk1NDM0IDIwLjkgOC43NjIzOSAyMC45SDEyLjAwMDFDMTIuNDk3MiAyMC45IDEyLjkwMDEgMjAuNDk3MSAxMi45MDAxIDIwQzEyLjkwMDEgMTkuNTAzIDEyLjQ5NzIgMTkuMSAxMi4wMDAxIDE5LjFIOC44MDAxQzcuOTQ1MTcgMTkuMSA3LjM1ODEgMTkuMDk5MyA2LjkwMjk5IDE5LjA2MjFDNi40NTgzOSAxOS4wMjU4IDYuMjE5NTYgMTguOTU5MiA2LjA0NjcyIDE4Ljg3MTFDNS42NTE1OCAxOC42Njk4IDUuMzMwMzIgMTguMzQ4NSA1LjEyODk4IDE3Ljk1MzRDNS4wNDA5MiAxNy43ODA1IDQuOTc0MzEgMTcuNTQxNyA0LjkzNzk4IDE3LjA5NzFDNC45MDA4IDE2LjY0MiA0LjkwMDEgMTYuMDU0OSA0LjkwMDEgMTUuMlY4LjgwMDAxQzQuOTAwMSA3Ljk0NTA4IDQuOTAwOCA3LjM1ODAxIDQuOTM3OTggNi45MDI5QzQuOTc0MzEgNi40NTgzIDUuMDQwOTIgNi4yMTk0NyA1LjEyODk4IDYuMDQ2NjNDNS4zMzAzMiA1LjY1MTQ5IDUuNjUxNTggNS4zMzAyMyA2LjA0NjcyIDUuMTI4ODlDNi4yMTk1NiA1LjA0MDgyIDYuNDU4MzkgNC45NzQyMiA2LjkwMjk5IDQuOTM3ODlDNy4zNTgxIDQuOTAwNzEgNy45NDUxNyA0LjkwMDAxIDguODAwMSA0LjkwMDAxSDEyLjAwMDFDMTIuNDk3MiA0LjkwMDAxIDEyLjkwMDEgNC40OTcwNiAxMi45MDAxIDQuMDAwMDFDMTIuOTAwMSAzLjUwMjk1IDEyLjQ5NzIgMy4xMDAwMSAxMi4wMDAxIDMuMTAwMDFIOC43NjI0WlwiPjwvcGF0aD48cGF0aCBkPVwiTTE3LjYzNjQgNy4zNjM2QzE3LjI4NDkgNy4wMTIxMiAxNi43MTUxIDcuMDEyMTIgMTYuMzYzNiA3LjM2MzZDMTYuMDEyMSA3LjcxNTA3IDE2LjAxMjEgOC4yODQ5MiAxNi4zNjM2IDguNjM2MzlMMTguODI3MiAxMS4xSDkuMDAwMDFDOC41MDI5NSAxMS4xIDguMTAwMDEgMTEuNTAyOSA4LjEwMDAxIDEyQzguMTAwMDEgMTIuNDk3IDguNTAyOTUgMTIuOSA5LjAwMDAxIDEyLjlIMTguODI3MkwxNi4zNjM2IDE1LjM2MzZDMTYuMDEyMSAxNS43MTUxIDE2LjAxMjEgMTYuMjg0OSAxNi4zNjM2IDE2LjYzNjRDMTYuNzE1MSAxNi45ODc5IDE3LjI4NDkgMTYuOTg3OSAxNy42MzY0IDE2LjYzNjRMMjEuNjM2NCAxMi42MzY0QzIxLjk4NzkgMTIuMjg0OSAyMS45ODc5IDExLjcxNTEgMjEuNjM2NCAxMS4zNjM2TDE3LjYzNjQgNy4zNjM2WlwiPjwvcGF0aD48L3N2Zz5gKTtcbmNvbnN0IERpc2Nvbm5lY3RJY29uID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgZmlsbCA9ICgpID0+IHByb3BzLmZpbGwgfHwgdGhlbWUuY29sb3JzLmljb24ucHJpbWFyeTtcbiAgcmV0dXJuICgoKSA9PiB7XG4gICAgY29uc3QgX2VsJCA9IF90bXBsJCQ2LmNsb25lTm9kZSh0cnVlKSwgX2VsJDIgPSBfZWwkLmZpcnN0Q2hpbGQsIF9lbCQzID0gX2VsJDIubmV4dFNpYmxpbmc7XG4gICAgY3JlYXRlUmVuZGVyRWZmZWN0KChfcCQpID0+IHtcbiAgICAgIGNvbnN0IF92JCA9IGZpbGwoKSwgX3YkMiA9IGZpbGwoKTtcbiAgICAgIF92JCAhPT0gX3AkLl92JCAmJiBzZXRBdHRyaWJ1dGUoX2VsJDIsIFwiZmlsbFwiLCBfcCQuX3YkID0gX3YkKTtcbiAgICAgIF92JDIgIT09IF9wJC5fdiQyICYmIHNldEF0dHJpYnV0ZShfZWwkMywgXCJmaWxsXCIsIF9wJC5fdiQyID0gX3YkMik7XG4gICAgICByZXR1cm4gX3AkO1xuICAgIH0sIHtcbiAgICAgIF92JDogdm9pZCAwLFxuICAgICAgX3YkMjogdm9pZCAwXG4gICAgfSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xuY29uc3QgaG92ZXJCb3JkZXJzJDEgPSB7XG4gIG06IFwiOHB4XCIsXG4gIHM6IFwiNHB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgZHJvcGRvd25Cb3JkZXJzID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBBY2NvdW50QnV0dG9uRHJvcGRvd25TdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAyNTZweDtcbiAgICBib3gtc2hhZG93OiAwIDRweCAyNHB4IHJnYmEoMCwgMCwgMCwgMC4xNik7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGRyb3Bkb3duQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcblxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5wcmltYXJ5fVxuICAgICAgICAgICBcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnByaW1hcnl9XG5gO1xuY29uc3QgVWxTdHlsZWQkMSA9IHN0eWxlZC51bGBcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgcGFkZGluZzogOHB4O1xuYDtcbmNvbnN0IE1lbnVCdXR0b25TdHlsZWQgPSBzdHlsZWQuYnV0dG9uYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IDhweDtcbiAgICBoZWlnaHQ6IDQwcHg7XG4gICAgcGFkZGluZy1sZWZ0OiA4cHg7XG4gICAgd2lkdGg6IDEwMCU7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgYm9yZGVyOiBub25lO1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBob3ZlckJvcmRlcnMkMVtwcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcbiAgICBjdXJzb3I6IHBvaW50ZXI7XG5cbiAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yLCB0cmFuc2Zvcm0gMC4xcyBlYXNlLWluLW91dDtcblxuICAgICY6aG92ZXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQuc2Vjb25kYXJ5fTtcbiAgICB9XG5cbiAgICAmOmFjdGl2ZSB7XG4gICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMC45Nik7XG4gICAgfVxuYDtcbmNvbnN0IF90bXBsJCQ1ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxsaT48L2xpPmApO1xuY29uc3QgTWVudUl0ZW1UZXh0ID0gKHByb3BzKSA9PiBjcmVhdGVDb21wb25lbnQoVGV4dCwge1xuICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgcmV0dXJuIHByb3BzLnRyYW5zbGF0aW9uS2V5O1xuICB9LFxuICBmb250U2l6ZTogXCIxNXB4XCIsXG4gIGZvbnRXZWlnaHQ6IFwiNTkwXCIsXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gIH1cbn0pO1xuY29uc3QgQWNjb3VudEJ1dHRvbkRyb3Bkb3duID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRvbkNvbm5lY3RVaSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFtpc0NvcGllZFNob3duLCBzZXRJc0NvcGllZFNob3duXSA9IGNyZWF0ZVNpZ25hbChmYWxzZSk7XG4gIGNvbnN0IG9uQ29weSA9ICgpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHVzZXJGcmllbmRseUFkZHJlc3MgPSB0b1VzZXJGcmllbmRseUFkZHJlc3ModG9uQ29ubmVjdFVpLmFjY291bnQuYWRkcmVzcywgdG9uQ29ubmVjdFVpLmFjY291bnQuY2hhaW4gPT09IENIQUlOLlRFU1RORVQpO1xuICAgIHlpZWxkIGNvcHlUb0NsaXBib2FyZCh1c2VyRnJpZW5kbHlBZGRyZXNzKTtcbiAgICBzZXRJc0NvcGllZFNob3duKHRydWUpO1xuICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0SXNDb3BpZWRTaG93bihmYWxzZSksIDFlMyk7XG4gIH0pO1xuICBjb25zdCBvbkRpc2Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgdG9uQ29ubmVjdFVpLmRpc2Nvbm5lY3QoKTtcbiAgICBwcm9wcy5vbkNsb3NlKCk7XG4gIH07XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWNjb3VudEJ1dHRvbkRyb3Bkb3duU3R5bGVkLCB7XG4gICAgcmVmKHIkKSB7XG4gICAgICBjb25zdCBfcmVmJCA9IHByb3BzLnJlZjtcbiAgICAgIHR5cGVvZiBfcmVmJCA9PT0gXCJmdW5jdGlvblwiID8gX3JlZiQociQpIDogcHJvcHMucmVmID0gciQ7XG4gICAgfSxcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtZHJvcGRvd25cIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChVbFN0eWxlZCQxLCB7XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gWygoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBfZWwkID0gX3RtcGwkJDUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChNZW51QnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IG9uQ29weSgpLFxuICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoQ29weUljb24sIHt9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gIWlzQ29waWVkU2hvd24oKTtcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTWVudUl0ZW1UZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiYnV0dG9uLmRyb3Bkb3duLmNvcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJDb3B5IGFkZHJlc3NcIlxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNDb3BpZWRTaG93bigpO1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChNZW51SXRlbVRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJidXR0b24uZHJvcGRvd24uY29waWVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQWRkcmVzcyBjb3BpZWQhXCJcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICByZXR1cm4gX2VsJDtcbiAgICAgICAgICB9KSgpLCAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgX2VsJDIgPSBfdG1wbCQkNS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICBpbnNlcnQoX2VsJDIsIGNyZWF0ZUNvbXBvbmVudChNZW51QnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IG9uRGlzY29ubmVjdCgpLFxuICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoRGlzY29ubmVjdEljb24sIHt9KSwgY3JlYXRlQ29tcG9uZW50KE1lbnVJdGVtVGV4dCwge1xuICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiYnV0dG9uLmRyb3Bkb3duLmRpc2Nvbm5lY3RcIixcbiAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIkRpc2Nvbm5lY3RcIlxuICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgcmV0dXJuIF9lbCQyO1xuICAgICAgICAgIH0pKCldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IGJvcmRlcnMkMiA9IHtcbiAgbTogXCIxNnB4XCIsXG4gIHM6IFwiOHB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgTm90aWZpY2F0aW9uU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogMjU2cHg7XG4gICAgcGFkZGluZzogMTJweCAxNnB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZ2FwOiA5cHg7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmJhY2tncm91bmQucHJpbWFyeX07XG4gICAgYm94LXNoYWRvdzogMCA0cHggMjRweCByZ2JhKDAsIDAsIDAsIDAuMTYpO1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzJDJbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG5gO1xuY29uc3QgTm90aWZpY2F0aW9uQ29udGVudFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgd2lkdGg6IDE5MnB4O1xuYDtcbmNvbnN0IFRleHRTdHlsZWQkMiA9IHN0eWxlZChUZXh0KWBcbiAgICBtYXJnaW4tdG9wOiA0cHg7XG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuYDtcbmNvbnN0IE5vdGlmaWNhdGlvbiA9IChwcm9wcykgPT4ge1xuICBjb25zdCBkYXRhQXR0cnMgPSB1c2VEYXRhQXR0cmlidXRlcyhwcm9wcyk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uU3R5bGVkLCBtZXJnZVByb3BzKHtcbiAgICBnZXQgW1wiY2xhc3NcIl0oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2xhc3M7XG4gICAgfSxcbiAgICBcImRhdGEtdGMtbm90aWZpY2F0aW9uXCI6IFwidHJ1ZVwiXG4gIH0sIGRhdGFBdHRycywge1xuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KE5vdGlmaWNhdGlvbkNvbnRlbnRTdHlsZWQsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEgzLCB7XG4gICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy5oZWFkZXIudHJhbnNsYXRpb25LZXk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMuaGVhZGVyLnRyYW5zbGF0aW9uVmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLmNoaWxkcmVuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBwcm9wcy50ZXh0O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkJDIsIHtcbiAgICAgICAgICAgICAgICBnZXQgdHJhbnNsYXRpb25LZXkoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcHJvcHMudGV4dC50cmFuc2xhdGlvbktleTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBwcm9wcy50ZXh0LnRyYW5zbGF0aW9uVmFsdWVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlTWVtbygoKSA9PiBwcm9wcy5pY29uKV07XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgTG9hZGVySWNvblN0eWxlZCQxID0gc3R5bGVkKExvYWRlckljb24pYFxuICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcbmA7XG5jb25zdCBDb25maXJtT3BlcmF0aW9uTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gIHZhciBfYTtcbiAgY29uc3QgdG9uQ29ubmVjdFVJID0gdXNlQ29udGV4dChUb25Db25uZWN0VWlDb250ZXh0KTtcbiAgY29uc3QgW3QyXSA9IHVzZUkxOG4oKTtcbiAgY29uc3QgbmFtZSA9ICgoX2EgPSB0b25Db25uZWN0VUkud2FsbGV0KSA9PSBudWxsID8gdm9pZCAwIDogX2EubmFtZSkgfHwgdDIoXCJjb21tb24ueW91cldhbGxldFwiLCB7fSwgXCJ5b3VyIHdhbGxldFwiKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChOb3RpZmljYXRpb24sIHtcbiAgICBoZWFkZXI6IHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIm5vdGlmaWNhdGlvbnMuY29uZmlybS5oZWFkZXJcIixcbiAgICAgIHRyYW5zbGF0aW9uVmFsdWVzOiB7XG4gICAgICAgIG5hbWVcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJJY29uU3R5bGVkJDEsIHt9KTtcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1ub3RpZmljYXRpb24tY29uZmlybVwiOiBcInRydWVcIixcbiAgICBjaGlsZHJlbjogXCJDb25maXJtIG9wZXJhdGlvbiBpbiB5b3VyIHdhbGxldFwiXG4gIH0pO1xufTtcbmNvbnN0IEVycm9ySWNvblN0eWxlZCA9IHN0eWxlZChFcnJvckljb24pYFxuICAgIG1hcmdpbi10b3A6IDJweDtcbmA7XG5jb25zdCBFcnJvclRyYW5zYWN0aW9uTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uLCB7XG4gICAgaGVhZGVyOiB7XG4gICAgICB0cmFuc2xhdGlvbktleTogXCJub3RpZmljYXRpb25zLnRyYW5zYWN0aW9uQ2FuY2VsZWQuaGVhZGVyXCJcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIm5vdGlmaWNhdGlvbnMudHJhbnNhY3Rpb25DYW5jZWxlZC50ZXh0XCJcbiAgICB9LFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChFcnJvckljb25TdHlsZWQsIHt9KTtcbiAgICB9LFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1ub3RpZmljYXRpb24tdHgtY2FuY2VsbGVkXCI6IFwidHJ1ZVwiLFxuICAgIGNoaWxkcmVuOiBcIlRyYW5zYWN0aW9uIGNhbmNlbGxlZFwiXG4gIH0pO1xufTtcbmNvbnN0IFN1Y2Nlc3NJY29uU3R5bGVkID0gc3R5bGVkKFN1Y2Nlc3NJY29uKWBcbiAgICBtYXJnaW4tdG9wOiAycHg7XG5gO1xuY29uc3QgU3VjY2Vzc1RyYW5zYWN0aW9uTm90aWZpY2F0aW9uID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoTm90aWZpY2F0aW9uLCB7XG4gICAgaGVhZGVyOiB7XG4gICAgICB0cmFuc2xhdGlvbktleTogXCJub3RpZmljYXRpb25zLnRyYW5zYWN0aW9uU2VudC5oZWFkZXJcIlxuICAgIH0sXG4gICAgdGV4dDoge1xuICAgICAgdHJhbnNsYXRpb25LZXk6IFwibm90aWZpY2F0aW9ucy50cmFuc2FjdGlvblNlbnQudGV4dFwiXG4gICAgfSxcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3VjY2Vzc0ljb25TdHlsZWQsIHt9KTtcbiAgICB9LFxuICAgIGdldCBbXCJjbGFzc1wiXSgpIHtcbiAgICAgIHJldHVybiBwcm9wcy5jbGFzcztcbiAgICB9LFxuICAgIFwiZGF0YS10Yy1ub3RpZmljYXRpb24tdHgtc2VudFwiOiBcInRydWVcIixcbiAgICBjaGlsZHJlbjogXCJUcmFuc2FjdGlvbiBzZW50XCJcbiAgfSk7XG59O1xuY29uc3QgTm90aWZpY2F0aW9uQ2xhc3MgPSB1YFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtOHB4KTtcbiAgICBtYXJnaW4tYm90dG9tOiAxMnB4O1xuYDtcbmNvbnN0IF90bXBsJCQ0ID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxkaXYgZGF0YS10Yy1saXN0LW5vdGlmaWNhdGlvbnM9XCJ0cnVlXCI+PC9kaXY+YCk7XG5jb25zdCBOb3RpZmljYXRpb25zID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IHRpbWVvdXRzID0gW107XG4gIGNvbnN0IFtvcGVuZWROb3RpZmljYXRpb25zLCBzZXRPcGVuZWROb3RpZmljYXRpb25zXSA9IGNyZWF0ZVNpZ25hbChbXSk7XG4gIGxldCBsYXN0SWQgPSAtMTtcbiAgY29uc3QgbGl2ZVRpbWVvdXRNcyA9IDQ1MDA7XG4gIGNyZWF0ZUVmZmVjdChvbihhY3Rpb24sIChhY3Rpb24yKSA9PiB7XG4gICAgaWYgKGFjdGlvbjIgJiYgYWN0aW9uMi5zaG93Tm90aWZpY2F0aW9uKSB7XG4gICAgICBsYXN0SWQrKztcbiAgICAgIGNvbnN0IGlkID0gbGFzdElkO1xuICAgICAgc2V0T3BlbmVkTm90aWZpY2F0aW9ucygobm90aWZpY2F0aW9uczIpID0+IG5vdGlmaWNhdGlvbnMyLmZpbHRlcigobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24uYWN0aW9uICE9PSBcImNvbmZpcm0tdHJhbnNhY3Rpb25cIikuY29uY2F0KHtcbiAgICAgICAgaWQsXG4gICAgICAgIGFjdGlvbjogYWN0aW9uMi5uYW1lXG4gICAgICB9KSk7XG4gICAgICB0aW1lb3V0cy5wdXNoKHNldFRpbWVvdXQoKCkgPT4gc2V0T3BlbmVkTm90aWZpY2F0aW9ucygobm90aWZpY2F0aW9uczIpID0+IG5vdGlmaWNhdGlvbnMyLmZpbHRlcigobm90aWZpY2F0aW9uKSA9PiBub3RpZmljYXRpb24uaWQgIT09IGlkKSksIGxpdmVUaW1lb3V0TXMpKTtcbiAgICB9XG4gIH0pKTtcbiAgb25DbGVhbnVwKCgpID0+IHtcbiAgICB0aW1lb3V0cy5mb3JFYWNoKGNsZWFyVGltZW91dCk7XG4gIH0pO1xuICByZXR1cm4gKCgpID0+IHtcbiAgICBjb25zdCBfZWwkID0gX3RtcGwkJDQuY2xvbmVOb2RlKHRydWUpO1xuICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoVHJhbnNpdGlvbkdyb3VwLCB7XG4gICAgICBvbkJlZm9yZUVudGVyOiAoZWwpID0+IHtcbiAgICAgICAgZWwuYW5pbWF0ZShbe1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIlxuICAgICAgICB9LCB7XG4gICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtOHB4KVwiXG4gICAgICAgIH1dLCB7XG4gICAgICAgICAgZHVyYXRpb246IDIwMFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBvbkV4aXQ6IChlbCwgZG9uZSkgPT4ge1xuICAgICAgICBjb25zdCBhMiA9IGVsLmFuaW1hdGUoW3tcbiAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC04cHgpXCJcbiAgICAgICAgfSwge1xuICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLTMwcHgpXCJcbiAgICAgICAgfV0sIHtcbiAgICAgICAgICBkdXJhdGlvbjogMjAwXG4gICAgICAgIH0pO1xuICAgICAgICBhMi5maW5pc2hlZC50aGVuKGRvbmUpO1xuICAgICAgfSxcbiAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChGb3IsIHtcbiAgICAgICAgICBnZXQgZWFjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBvcGVuZWROb3RpZmljYXRpb25zKCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjaGlsZHJlbjogKG9wZW5lZE5vdGlmaWNhdGlvbikgPT4gY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5lZE5vdGlmaWNhdGlvbi5hY3Rpb24gPT09IFwidHJhbnNhY3Rpb24tc2VudFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdWNjZXNzVHJhbnNhY3Rpb25Ob3RpZmljYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgXCJjbGFzc1wiOiBOb3RpZmljYXRpb25DbGFzc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gb3BlbmVkTm90aWZpY2F0aW9uLmFjdGlvbiA9PT0gXCJ0cmFuc2FjdGlvbi1jYW5jZWxlZFwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChFcnJvclRyYW5zYWN0aW9uTm90aWZpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogTm90aWZpY2F0aW9uQ2xhc3NcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZW5lZE5vdGlmaWNhdGlvbi5hY3Rpb24gPT09IFwiY29uZmlybS10cmFuc2FjdGlvblwiO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDb25maXJtT3BlcmF0aW9uTm90aWZpY2F0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIFwiY2xhc3NcIjogTm90aWZpY2F0aW9uQ2xhc3NcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pKTtcbiAgICBjcmVhdGVSZW5kZXJFZmZlY3QoKCkgPT4gY2xhc3NOYW1lKF9lbCQsIHByb3BzLmNsYXNzKSk7XG4gICAgcmV0dXJuIF9lbCQ7XG4gIH0pKCk7XG59O1xuY29uc3QgQWNjb3VudEJ1dHRvblN0eWxlZCA9IHN0eWxlZChCdXR0b24pYFxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuY29ubmVjdEJ1dHRvbi5iYWNrZ3JvdW5kfTtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5jb25uZWN0QnV0dG9uLmZvcmVncm91bmR9O1xuICAgIGJveC1zaGFkb3c6ICR7KHByb3BzKSA9PiBgMCA0cHggMjRweCAke3JnYmEocHJvcHMudGhlbWUuY29sb3JzLmNvbnN0YW50LmJsYWNrLCAwLjE2KX1gfTtcbiAgICBwYWRkaW5nOiA4cHggMTZweCA4cHggMTJweDtcblxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBnYXA6IDRweDtcbiAgICBoZWlnaHQ6IDQwcHg7XG5gO1xuY29uc3QgRHJvcGRvd25CdXR0b25TdHlsZWQgPSBzdHlsZWQoQWNjb3VudEJ1dHRvblN0eWxlZClgXG4gICAgcGFkZGluZzogMTJweCAxNnB4O1xuICAgIG1pbi13aWR0aDogMTQ4cHg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuYDtcbmNvbnN0IExvYWRlckJ1dHRvblN0eWxlZCA9IHN0eWxlZChCdXR0b24pYFxuICAgIG1pbi13aWR0aDogMTQ4cHg7XG4gICAgaGVpZ2h0OiA0MHB4O1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmNvbm5lY3RCdXR0b24uZm9yZWdyb3VuZH07XG4gICAgYm94LXNoYWRvdzogJHsocHJvcHMpID0+IGAwIDRweCAyNHB4ICR7cmdiYShwcm9wcy50aGVtZS5jb2xvcnMuY29uc3RhbnQuYmxhY2ssIDAuMTYpfWB9O1xuXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuYDtcbmNvbnN0IExvYWRlckljb25TdHlsZWQgPSBzdHlsZWQoTG9hZGVySWNvbilgXG4gICAgaGVpZ2h0OiAxOHB4O1xuICAgIHdpZHRoOiAxOHB4O1xuYDtcbmNvbnN0IERyb3Bkb3duQ29udGFpbmVyU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbmA7XG5jb25zdCBEcm9wZG93blN0eWxlZCA9IHN0eWxlZChBY2NvdW50QnV0dG9uRHJvcGRvd24pYFxuICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICBtYXJnaW4tdG9wOiAxMnB4O1xuYDtcbmNvbnN0IE5vdGlmaWNhdGlvbnNTdHlsZWQgPSBzdHlsZWQoTm90aWZpY2F0aW9ucylgXG4gICAgPiBkaXY6Zmlyc3QtY2hpbGQge1xuICAgICAgICBtYXJnaW4tdG9wOiAyMHB4O1xuICAgIH1cbmA7XG5mdW5jdGlvbiBnZXRTaWRlKHBsYWNlbWVudCkge1xuICByZXR1cm4gcGxhY2VtZW50LnNwbGl0KFwiLVwiKVswXTtcbn1cbmZ1bmN0aW9uIGdldEFsaWdubWVudChwbGFjZW1lbnQpIHtcbiAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdChcIi1cIilbMV07XG59XG5mdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBbXCJ0b3BcIiwgXCJib3R0b21cIl0uaW5jbHVkZXMoZ2V0U2lkZShwbGFjZW1lbnQpKSA/IFwieFwiIDogXCJ5XCI7XG59XG5mdW5jdGlvbiBnZXRMZW5ndGhGcm9tQXhpcyhheGlzKSB7XG4gIHJldHVybiBheGlzID09PSBcInlcIiA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCI7XG59XG5mdW5jdGlvbiBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChfcmVmLCBwbGFjZW1lbnQsIHJ0bCkge1xuICBsZXQge1xuICAgIHJlZmVyZW5jZSxcbiAgICBmbG9hdGluZ1xuICB9ID0gX3JlZjtcbiAgY29uc3QgY29tbW9uWCA9IHJlZmVyZW5jZS54ICsgcmVmZXJlbmNlLndpZHRoIC8gMiAtIGZsb2F0aW5nLndpZHRoIC8gMjtcbiAgY29uc3QgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBmbG9hdGluZy5oZWlnaHQgLyAyO1xuICBjb25zdCBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpO1xuICBjb25zdCBsZW5ndGggPSBnZXRMZW5ndGhGcm9tQXhpcyhtYWluQXhpcyk7XG4gIGNvbnN0IGNvbW1vbkFsaWduID0gcmVmZXJlbmNlW2xlbmd0aF0gLyAyIC0gZmxvYXRpbmdbbGVuZ3RoXSAvIDI7XG4gIGNvbnN0IHNpZGUgPSBnZXRTaWRlKHBsYWNlbWVudCk7XG4gIGNvbnN0IGlzVmVydGljYWwgPSBtYWluQXhpcyA9PT0gXCJ4XCI7XG4gIGxldCBjb29yZHM7XG4gIHN3aXRjaCAoc2lkZSkge1xuICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgIGNvb3JkcyA9IHtcbiAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBmbG9hdGluZy5oZWlnaHRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgIHk6IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCxcbiAgICAgICAgeTogY29tbW9uWVxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICBjb29yZHMgPSB7XG4gICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZmxvYXRpbmcud2lkdGgsXG4gICAgICAgIHk6IGNvbW1vbllcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgY29vcmRzID0ge1xuICAgICAgICB4OiByZWZlcmVuY2UueCxcbiAgICAgICAgeTogcmVmZXJlbmNlLnlcbiAgICAgIH07XG4gIH1cbiAgc3dpdGNoIChnZXRBbGlnbm1lbnQocGxhY2VtZW50KSkge1xuICAgIGNhc2UgXCJzdGFydFwiOlxuICAgICAgY29vcmRzW21haW5BeGlzXSAtPSBjb21tb25BbGlnbiAqIChydGwgJiYgaXNWZXJ0aWNhbCA/IC0xIDogMSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW5kXCI6XG4gICAgICBjb29yZHNbbWFpbkF4aXNdICs9IGNvbW1vbkFsaWduICogKHJ0bCAmJiBpc1ZlcnRpY2FsID8gLTEgOiAxKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBjb29yZHM7XG59XG5jb25zdCBjb21wdXRlUG9zaXRpb24kMSA9IChyZWZlcmVuY2UsIGZsb2F0aW5nLCBjb25maWcpID0+IF9fYXN5bmModm9pZCAwLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICBjb25zdCB7XG4gICAgcGxhY2VtZW50ID0gXCJib3R0b21cIixcbiAgICBzdHJhdGVneSA9IFwiYWJzb2x1dGVcIixcbiAgICBtaWRkbGV3YXJlID0gW10sXG4gICAgcGxhdGZvcm06IHBsYXRmb3JtMlxuICB9ID0gY29uZmlnO1xuICBjb25zdCB2YWxpZE1pZGRsZXdhcmUgPSBtaWRkbGV3YXJlLmZpbHRlcihCb29sZWFuKTtcbiAgY29uc3QgcnRsID0geWllbGQgcGxhdGZvcm0yLmlzUlRMID09IG51bGwgPyB2b2lkIDAgOiBwbGF0Zm9ybTIuaXNSVEwoZmxvYXRpbmcpO1xuICBpZiAoe30uTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgaWYgKHBsYXRmb3JtMiA9PSBudWxsKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFtcIkZsb2F0aW5nIFVJOiBgcGxhdGZvcm1gIHByb3BlcnR5IHdhcyBub3QgcGFzc2VkIHRvIGNvbmZpZy4gSWYgeW91XCIsIFwid2FudCB0byB1c2UgRmxvYXRpbmcgVUkgb24gdGhlIHdlYiwgaW5zdGFsbCBAZmxvYXRpbmctdWkvZG9tXCIsIFwiaW5zdGVhZCBvZiB0aGUgL2NvcmUgcGFja2FnZS4gT3RoZXJ3aXNlLCB5b3UgY2FuIGNyZWF0ZSB5b3VyIG93blwiLCBcImBwbGF0Zm9ybWA6IGh0dHBzOi8vZmxvYXRpbmctdWkuY29tL2RvY3MvcGxhdGZvcm1cIl0uam9pbihcIiBcIikpO1xuICAgIH1cbiAgICBpZiAodmFsaWRNaWRkbGV3YXJlLmZpbHRlcigoX3JlZikgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gbmFtZSA9PT0gXCJhdXRvUGxhY2VtZW50XCIgfHwgbmFtZSA9PT0gXCJmbGlwXCI7XG4gICAgfSkubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcIkZsb2F0aW5nIFVJOiBkdXBsaWNhdGUgYGZsaXBgIGFuZC9vciBgYXV0b1BsYWNlbWVudGAgbWlkZGxld2FyZVwiLCBcImRldGVjdGVkLiBUaGlzIHdpbGwgbGVhZCB0byBhbiBpbmZpbml0ZSBsb29wLiBFbnN1cmUgb25seSBvbmUgb2ZcIiwgXCJlaXRoZXIgaGFzIGJlZW4gcGFzc2VkIHRvIHRoZSBgbWlkZGxld2FyZWAgYXJyYXkuXCJdLmpvaW4oXCIgXCIpKTtcbiAgICB9XG4gICAgaWYgKCFyZWZlcmVuY2UgfHwgIWZsb2F0aW5nKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFtcIkZsb2F0aW5nIFVJOiBUaGUgcmVmZXJlbmNlIGFuZC9vciBmbG9hdGluZyBlbGVtZW50IHdhcyBub3QgZGVmaW5lZFwiLCBcIndoZW4gYGNvbXB1dGVQb3NpdGlvbigpYCB3YXMgY2FsbGVkLiBFbnN1cmUgdGhhdCBib3RoIGVsZW1lbnRzIGhhdmVcIiwgXCJiZWVuIGNyZWF0ZWQgYW5kIGNhbiBiZSBtZWFzdXJlZC5cIl0uam9pbihcIiBcIikpO1xuICAgIH1cbiAgfVxuICBsZXQgcmVjdHMgPSB5aWVsZCBwbGF0Zm9ybTIuZ2V0RWxlbWVudFJlY3RzKHtcbiAgICByZWZlcmVuY2UsXG4gICAgZmxvYXRpbmcsXG4gICAgc3RyYXRlZ3lcbiAgfSk7XG4gIGxldCB7XG4gICAgeCxcbiAgICB5XG4gIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgcGxhY2VtZW50LCBydGwpO1xuICBsZXQgc3RhdGVmdWxQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gIGxldCBtaWRkbGV3YXJlRGF0YSA9IHt9O1xuICBsZXQgcmVzZXRDb3VudCA9IDA7XG4gIGZvciAobGV0IGkyID0gMDsgaTIgPCB2YWxpZE1pZGRsZXdhcmUubGVuZ3RoOyBpMisrKSB7XG4gICAgY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIGZuXG4gICAgfSA9IHZhbGlkTWlkZGxld2FyZVtpMl07XG4gICAgY29uc3Qge1xuICAgICAgeDogbmV4dFgsXG4gICAgICB5OiBuZXh0WSxcbiAgICAgIGRhdGEsXG4gICAgICByZXNldFxuICAgIH0gPSB5aWVsZCBmbih7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIGluaXRpYWxQbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgIHBsYWNlbWVudDogc3RhdGVmdWxQbGFjZW1lbnQsXG4gICAgICBzdHJhdGVneSxcbiAgICAgIG1pZGRsZXdhcmVEYXRhLFxuICAgICAgcmVjdHMsXG4gICAgICBwbGF0Zm9ybTogcGxhdGZvcm0yLFxuICAgICAgZWxlbWVudHM6IHtcbiAgICAgICAgcmVmZXJlbmNlLFxuICAgICAgICBmbG9hdGluZ1xuICAgICAgfVxuICAgIH0pO1xuICAgIHggPSBuZXh0WCAhPSBudWxsID8gbmV4dFggOiB4O1xuICAgIHkgPSBuZXh0WSAhPSBudWxsID8gbmV4dFkgOiB5O1xuICAgIG1pZGRsZXdhcmVEYXRhID0gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWlkZGxld2FyZURhdGEpLCB7XG4gICAgICBbbmFtZV06IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCBtaWRkbGV3YXJlRGF0YVtuYW1lXSksIGRhdGEpXG4gICAgfSk7XG4gICAgaWYgKHt9Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgaWYgKHJlc2V0Q291bnQgPiA1MCkge1xuICAgICAgICBjb25zb2xlLndhcm4oW1wiRmxvYXRpbmcgVUk6IFRoZSBtaWRkbGV3YXJlIGxpZmVjeWNsZSBhcHBlYXJzIHRvIGJlIHJ1bm5pbmcgaW4gYW5cIiwgXCJpbmZpbml0ZSBsb29wLiBUaGlzIGlzIHVzdWFsbHkgY2F1c2VkIGJ5IGEgYHJlc2V0YCBjb250aW51YWxseVwiLCBcImJlaW5nIHJldHVybmVkIHdpdGhvdXQgYSBicmVhayBjb25kaXRpb24uXCJdLmpvaW4oXCIgXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc2V0ICYmIHJlc2V0Q291bnQgPD0gNTApIHtcbiAgICAgIHJlc2V0Q291bnQrKztcbiAgICAgIGlmICh0eXBlb2YgcmVzZXQgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKHJlc2V0LnBsYWNlbWVudCkge1xuICAgICAgICAgIHN0YXRlZnVsUGxhY2VtZW50ID0gcmVzZXQucGxhY2VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNldC5yZWN0cykge1xuICAgICAgICAgIHJlY3RzID0gcmVzZXQucmVjdHMgPT09IHRydWUgPyB5aWVsZCBwbGF0Zm9ybTIuZ2V0RWxlbWVudFJlY3RzKHtcbiAgICAgICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgICAgIGZsb2F0aW5nLFxuICAgICAgICAgICAgc3RyYXRlZ3lcbiAgICAgICAgICB9KSA6IHJlc2V0LnJlY3RzO1xuICAgICAgICB9XG4gICAgICAgICh7XG4gICAgICAgICAgeCxcbiAgICAgICAgICB5XG4gICAgICAgIH0gPSBjb21wdXRlQ29vcmRzRnJvbVBsYWNlbWVudChyZWN0cywgc3RhdGVmdWxQbGFjZW1lbnQsIHJ0bCkpO1xuICAgICAgfVxuICAgICAgaTIgPSAtMTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHgsXG4gICAgeSxcbiAgICBwbGFjZW1lbnQ6IHN0YXRlZnVsUGxhY2VtZW50LFxuICAgIHN0cmF0ZWd5LFxuICAgIG1pZGRsZXdhcmVEYXRhXG4gIH07XG59KTtcbmZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xuICByZXR1cm4gX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgcmVjdCksIHtcbiAgICB0b3A6IHJlY3QueSxcbiAgICBsZWZ0OiByZWN0LngsXG4gICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXG4gICAgYm90dG9tOiByZWN0LnkgKyByZWN0LmhlaWdodFxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFdpbmRvdyhub2RlKSB7XG4gIHZhciBfbm9kZSRvd25lckRvY3VtZW50O1xuICByZXR1cm4gKChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX25vZGUkb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldykgfHwgd2luZG93O1xufVxuZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobm9kZSkge1xuICByZXR1cm4gaXNOb2RlKG5vZGUpID8gKG5vZGUubm9kZU5hbWUgfHwgXCJcIikudG9Mb3dlckNhc2UoKSA6IFwiXCI7XG59XG5sZXQgdWFTdHJpbmc7XG5mdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcbiAgaWYgKHVhU3RyaW5nKSB7XG4gICAgcmV0dXJuIHVhU3RyaW5nO1xuICB9XG4gIGNvbnN0IHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuICBpZiAodWFEYXRhICYmIEFycmF5LmlzQXJyYXkodWFEYXRhLmJyYW5kcykpIHtcbiAgICB1YVN0cmluZyA9IHVhRGF0YS5icmFuZHMubWFwKChpdGVtKSA9PiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb24pLmpvaW4oXCIgXCIpO1xuICAgIHJldHVybiB1YVN0cmluZztcbiAgfVxuICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbn1cbmZ1bmN0aW9uIGlzSFRNTEVsZW1lbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5IVE1MRWxlbWVudDtcbn1cbmZ1bmN0aW9uIGlzRWxlbWVudCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBnZXRXaW5kb3codmFsdWUpLkVsZW1lbnQ7XG59XG5mdW5jdGlvbiBpc05vZGUodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgZ2V0V2luZG93KHZhbHVlKS5Ob2RlO1xufVxuZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcbiAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBTaGFkb3dSb290O1xufVxuZnVuY3Rpb24gaXNPdmVyZmxvd0VsZW1lbnQoZWxlbWVudCkge1xuICBjb25zdCB7XG4gICAgb3ZlcmZsb3csXG4gICAgb3ZlcmZsb3dYLFxuICAgIG92ZXJmbG93WSxcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7XG4gIHJldHVybiAvYXV0b3xzY3JvbGx8b3ZlcmxheXxoaWRkZW4vLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpICYmICFbXCJpbmxpbmVcIiwgXCJjb250ZW50c1wiXS5pbmNsdWRlcyhkaXNwbGF5KTtcbn1cbmZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgcmV0dXJuIFtcInRhYmxlXCIsIFwidGRcIiwgXCJ0aFwiXS5pbmNsdWRlcyhnZXROb2RlTmFtZShlbGVtZW50KSk7XG59XG5mdW5jdGlvbiBpc0NvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gIGNvbnN0IGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgY29uc3QgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpO1xuICBjb25zdCBiYWNrZHJvcEZpbHRlciA9IGNzcy5iYWNrZHJvcEZpbHRlciB8fCBjc3MuV2Via2l0QmFja2Ryb3BGaWx0ZXI7XG4gIHJldHVybiBjc3MudHJhbnNmb3JtICE9PSBcIm5vbmVcIiB8fCBjc3MucGVyc3BlY3RpdmUgIT09IFwibm9uZVwiIHx8IChiYWNrZHJvcEZpbHRlciA/IGJhY2tkcm9wRmlsdGVyICE9PSBcIm5vbmVcIiA6IGZhbHNlKSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09IFwiZmlsdGVyXCIgfHwgaXNGaXJlZm94ICYmIChjc3MuZmlsdGVyID8gY3NzLmZpbHRlciAhPT0gXCJub25lXCIgOiBmYWxzZSkgfHwgW1widHJhbnNmb3JtXCIsIFwicGVyc3BlY3RpdmVcIl0uc29tZSgodmFsdWUpID0+IGNzcy53aWxsQ2hhbmdlLmluY2x1ZGVzKHZhbHVlKSkgfHwgW1wicGFpbnRcIiwgXCJsYXlvdXRcIiwgXCJzdHJpY3RcIiwgXCJjb250ZW50XCJdLnNvbWUoXG4gICAgKHZhbHVlKSA9PiB7XG4gICAgICBjb25zdCBjb250YWluID0gY3NzLmNvbnRhaW47XG4gICAgICByZXR1cm4gY29udGFpbiAhPSBudWxsID8gY29udGFpbi5pbmNsdWRlcyh2YWx1ZSkgOiBmYWxzZTtcbiAgICB9XG4gICk7XG59XG5mdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XG59XG5mdW5jdGlvbiBpc0xhc3RUcmF2ZXJzYWJsZU5vZGUobm9kZSkge1xuICByZXR1cm4gW1wiaHRtbFwiLCBcImJvZHlcIiwgXCIjZG9jdW1lbnRcIl0uaW5jbHVkZXMoZ2V0Tm9kZU5hbWUobm9kZSkpO1xufVxuY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcbmNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZDtcbmNvbnN0IEZBTExCQUNLX1NDQUxFID0ge1xuICB4OiAxLFxuICB5OiAxXG59O1xuZnVuY3Rpb24gZ2V0U2NhbGUoZWxlbWVudCkge1xuICBjb25zdCBkb21FbGVtZW50ID0gIWlzRWxlbWVudChlbGVtZW50KSAmJiBlbGVtZW50LmNvbnRleHRFbGVtZW50ID8gZWxlbWVudC5jb250ZXh0RWxlbWVudCA6IGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBudWxsO1xuICBpZiAoIWRvbUVsZW1lbnQpIHtcbiAgICByZXR1cm4gRkFMTEJBQ0tfU0NBTEU7XG4gIH1cbiAgY29uc3QgcmVjdCA9IGRvbUVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIGNvbnN0IGNzcyA9IGdldENvbXB1dGVkU3R5bGUkMShkb21FbGVtZW50KTtcbiAgaWYgKGNzcy5ib3hTaXppbmcgIT09IFwiYm9yZGVyLWJveFwiKSB7XG4gICAgaWYgKCFpc0hUTUxFbGVtZW50KGRvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gRkFMTEJBQ0tfU0NBTEU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB4OiBkb21FbGVtZW50Lm9mZnNldFdpZHRoID4gMCA/IHJvdW5kKHJlY3Qud2lkdGgpIC8gZG9tRWxlbWVudC5vZmZzZXRXaWR0aCB8fCAxIDogMSxcbiAgICAgIHk6IGRvbUVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKHJlY3QuaGVpZ2h0KSAvIGRvbUVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxXG4gICAgfTtcbiAgfVxuICBsZXQgeCA9IHJlY3Qud2lkdGggLyBwYXJzZUZsb2F0KGNzcy53aWR0aCk7XG4gIGxldCB5ID0gcmVjdC5oZWlnaHQgLyBwYXJzZUZsb2F0KGNzcy5oZWlnaHQpO1xuICBpZiAoIXggfHwgIU51bWJlci5pc0Zpbml0ZSh4KSkge1xuICAgIHggPSAxO1xuICB9XG4gIGlmICgheSB8fCAhTnVtYmVyLmlzRmluaXRlKHkpKSB7XG4gICAgeSA9IDE7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSwgb2Zmc2V0UGFyZW50KSB7XG4gIHZhciBfd2luJHZpc3VhbFZpZXdwb3J0JG8sIF93aW4kdmlzdWFsVmlld3BvcnQsIF93aW4kdmlzdWFsVmlld3BvcnQkbzIsIF93aW4kdmlzdWFsVmlld3BvcnQyO1xuICBpZiAoaW5jbHVkZVNjYWxlID09PSB2b2lkIDApIHtcbiAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcbiAgfVxuICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcbiAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjbGllbnRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgbGV0IHNjYWxlID0gRkFMTEJBQ0tfU0NBTEU7XG4gIGlmIChpbmNsdWRlU2NhbGUpIHtcbiAgICBpZiAob2Zmc2V0UGFyZW50KSB7XG4gICAgICBpZiAoaXNFbGVtZW50KG9mZnNldFBhcmVudCkpIHtcbiAgICAgICAgc2NhbGUgPSBnZXRTY2FsZShvZmZzZXRQYXJlbnQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCB3aW4gPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3c7XG4gIGNvbnN0IGFkZFZpc3VhbE9mZnNldHMgPSAhaXNMYXlvdXRWaWV3cG9ydCgpICYmIGlzRml4ZWRTdHJhdGVneTtcbiAgY29uc3QgeCA9IChjbGllbnRSZWN0LmxlZnQgKyAoYWRkVmlzdWFsT2Zmc2V0cyA/IChfd2luJHZpc3VhbFZpZXdwb3J0JG8gPSAoX3dpbiR2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW4kdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdCkgIT0gbnVsbCA/IF93aW4kdmlzdWFsVmlld3BvcnQkbyA6IDAgOiAwKSkgLyBzY2FsZS54O1xuICBjb25zdCB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgPyAoX3dpbiR2aXN1YWxWaWV3cG9ydCRvMiA9IChfd2luJHZpc3VhbFZpZXdwb3J0MiA9IHdpbi52aXN1YWxWaWV3cG9ydCkgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW4kdmlzdWFsVmlld3BvcnQyLm9mZnNldFRvcCkgIT0gbnVsbCA/IF93aW4kdmlzdWFsVmlld3BvcnQkbzIgOiAwIDogMCkpIC8gc2NhbGUueTtcbiAgY29uc3Qgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoIC8gc2NhbGUueDtcbiAgY29uc3QgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZS55O1xuICByZXR1cm4ge1xuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICB0b3A6IHksXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgbGVmdDogeCxcbiAgICB4LFxuICAgIHlcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChub2RlKSB7XG4gIHJldHVybiAoKGlzTm9kZShub2RlKSA/IG5vZGUub3duZXJEb2N1bWVudCA6IG5vZGUuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xufVxuZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KSB7XG4gIGlmIChpc0VsZW1lbnQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogZWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsVG9wOiBlbGVtZW50LnNjcm9sbFRvcFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnBhZ2VYT2Zmc2V0LFxuICAgIHNjcm9sbFRvcDogZWxlbWVudC5wYWdlWU9mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsQmFyWChlbGVtZW50KSB7XG4gIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0Tm9kZVNjcm9sbChlbGVtZW50KS5zY3JvbGxMZWZ0O1xufVxuZnVuY3Rpb24gZ2V0UmVjdFJlbGF0aXZlVG9PZmZzZXRQYXJlbnQoZWxlbWVudCwgb2Zmc2V0UGFyZW50LCBzdHJhdGVneSkge1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09IFwiZml4ZWRcIiwgb2Zmc2V0UGFyZW50KTtcbiAgbGV0IHNjcm9sbCA9IHtcbiAgICBzY3JvbGxMZWZ0OiAwLFxuICAgIHNjcm9sbFRvcDogMFxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIHN0cmF0ZWd5ICE9PSBcImZpeGVkXCIpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gXCJib2R5XCIgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgIG9mZnNldHMueCA9IGdldFdpbmRvd1Njcm9sbEJhclgoZG9jdW1lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB4OiByZWN0LmxlZnQgKyBzY3JvbGwuc2Nyb2xsTGVmdCAtIG9mZnNldHMueCxcbiAgICB5OiByZWN0LnRvcCArIHNjcm9sbC5zY3JvbGxUb3AgLSBvZmZzZXRzLnksXG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShub2RlKSB7XG4gIGlmIChnZXROb2RlTmFtZShub2RlKSA9PT0gXCJodG1sXCIpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSBub2RlLmFzc2lnbmVkU2xvdCB8fCBub2RlLnBhcmVudE5vZGUgfHwgKGlzU2hhZG93Um9vdChub2RlKSA/IG5vZGUuaG9zdCA6IG51bGwpIHx8IGdldERvY3VtZW50RWxlbWVudChub2RlKTtcbiAgcmV0dXJuIGlzU2hhZG93Um9vdChyZXN1bHQpID8gcmVzdWx0Lmhvc3QgOiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8IGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQub2Zmc2V0UGFyZW50O1xufVxuZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcbiAgbGV0IGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcbiAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmICFpc0xhc3RUcmF2ZXJzYWJsZU5vZGUoY3VycmVudE5vZGUpKSB7XG4gICAgaWYgKGlzQ29udGFpbmluZ0Jsb2NrKGN1cnJlbnROb2RlKSkge1xuICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Tm9kZSA9IGdldFBhcmVudE5vZGUoY3VycmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGNvbnN0IHdpbmRvdzIgPSBnZXRXaW5kb3coZWxlbWVudCk7XG4gIGxldCBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuICB3aGlsZSAob2Zmc2V0UGFyZW50ICYmIGlzVGFibGVFbGVtZW50KG9mZnNldFBhcmVudCkgJiYgZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09IFwic3RhdGljXCIpIHtcbiAgICBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cbiAgaWYgKG9mZnNldFBhcmVudCAmJiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gXCJodG1sXCIgfHwgZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSA9PT0gXCJib2R5XCIgJiYgZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09IFwic3RhdGljXCIgJiYgIWlzQ29udGFpbmluZ0Jsb2NrKG9mZnNldFBhcmVudCkpKSB7XG4gICAgcmV0dXJuIHdpbmRvdzI7XG4gIH1cbiAgcmV0dXJuIG9mZnNldFBhcmVudCB8fCBnZXRDb250YWluaW5nQmxvY2soZWxlbWVudCkgfHwgd2luZG93Mjtcbn1cbmZ1bmN0aW9uIGdldERpbWVuc2lvbnMoZWxlbWVudCkge1xuICBpZiAoaXNIVE1MRWxlbWVudChlbGVtZW50KSkge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCxcbiAgICAgIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgICB9O1xuICB9XG4gIGNvbnN0IHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiByZWN0LmhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gY29udmVydE9mZnNldFBhcmVudFJlbGF0aXZlUmVjdFRvVmlld3BvcnRSZWxhdGl2ZVJlY3QoX3JlZikge1xuICBsZXQge1xuICAgIHJlY3QsXG4gICAgb2Zmc2V0UGFyZW50LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBpc09mZnNldFBhcmVudEFuRWxlbWVudCA9IGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgY29uc3QgZG9jdW1lbnRFbGVtZW50ID0gZ2V0RG9jdW1lbnRFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gIGlmIChvZmZzZXRQYXJlbnQgPT09IGRvY3VtZW50RWxlbWVudCkge1xuICAgIHJldHVybiByZWN0O1xuICB9XG4gIGxldCBzY3JvbGwgPSB7XG4gICAgc2Nyb2xsTGVmdDogMCxcbiAgICBzY3JvbGxUb3A6IDBcbiAgfTtcbiAgbGV0IHNjYWxlID0ge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9O1xuICBjb25zdCBvZmZzZXRzID0ge1xuICAgIHg6IDAsXG4gICAgeTogMFxuICB9O1xuICBpZiAoaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgfHwgIWlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ICYmIHN0cmF0ZWd5ICE9PSBcImZpeGVkXCIpIHtcbiAgICBpZiAoZ2V0Tm9kZU5hbWUob2Zmc2V0UGFyZW50KSAhPT0gXCJib2R5XCIgfHwgaXNPdmVyZmxvd0VsZW1lbnQoZG9jdW1lbnRFbGVtZW50KSkge1xuICAgICAgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChvZmZzZXRQYXJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICBjb25zdCBvZmZzZXRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG4gICAgICBzY2FsZSA9IGdldFNjYWxlKG9mZnNldFBhcmVudCk7XG4gICAgICBvZmZzZXRzLnggPSBvZmZzZXRSZWN0LnggKyBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgIG9mZnNldHMueSA9IG9mZnNldFJlY3QueSArIG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGg6IHJlY3Qud2lkdGggKiBzY2FsZS54LFxuICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKiBzY2FsZS55LFxuICAgIHg6IHJlY3QueCAqIHNjYWxlLnggLSBzY3JvbGwuc2Nyb2xsTGVmdCAqIHNjYWxlLnggKyBvZmZzZXRzLngsXG4gICAgeTogcmVjdC55ICogc2NhbGUueSAtIHNjcm9sbC5zY3JvbGxUb3AgKiBzY2FsZS55ICsgb2Zmc2V0cy55XG4gIH07XG59XG5mdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgY29uc3Qgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICBjb25zdCBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICBjb25zdCB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgbGV0IHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcbiAgbGV0IGhlaWdodCA9IGh0bWwuY2xpZW50SGVpZ2h0O1xuICBsZXQgeCA9IDA7XG4gIGxldCB5ID0gMDtcbiAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcbiAgICBoZWlnaHQgPSB2aXN1YWxWaWV3cG9ydC5oZWlnaHQ7XG4gICAgY29uc3QgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XG4gICAgaWYgKGxheW91dFZpZXdwb3J0IHx8ICFsYXlvdXRWaWV3cG9ydCAmJiBzdHJhdGVneSA9PT0gXCJmaXhlZFwiKSB7XG4gICAgICB4ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0TGVmdDtcbiAgICAgIHkgPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3A7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIHgsXG4gICAgeVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcbiAgY29uc3QgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcbiAgY29uc3Qgc2Nyb2xsID0gZ2V0Tm9kZVNjcm9sbChlbGVtZW50KTtcbiAgY29uc3QgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgY29uc3Qgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICBjb25zdCBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgbGV0IHggPSAtc2Nyb2xsLnNjcm9sbExlZnQgKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpO1xuICBjb25zdCB5ID0gLXNjcm9sbC5zY3JvbGxUb3A7XG4gIGlmIChnZXRDb21wdXRlZFN0eWxlJDEoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09IFwicnRsXCIpIHtcbiAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHQsXG4gICAgeCxcbiAgICB5XG4gIH07XG59XG5mdW5jdGlvbiBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKSB7XG4gIGNvbnN0IHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKG5vZGUpO1xuICBpZiAoaXNMYXN0VHJhdmVyc2FibGVOb2RlKHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIG5vZGUub3duZXJEb2N1bWVudC5ib2R5O1xuICB9XG4gIGlmIChpc0hUTUxFbGVtZW50KHBhcmVudE5vZGUpICYmIGlzT3ZlcmZsb3dFbGVtZW50KHBhcmVudE5vZGUpKSB7XG4gICAgcmV0dXJuIHBhcmVudE5vZGU7XG4gIH1cbiAgcmV0dXJuIGdldE5lYXJlc3RPdmVyZmxvd0FuY2VzdG9yKHBhcmVudE5vZGUpO1xufVxuZnVuY3Rpb24gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMobm9kZSwgbGlzdCkge1xuICB2YXIgX25vZGUkb3duZXJEb2N1bWVudDtcbiAgaWYgKGxpc3QgPT09IHZvaWQgMCkge1xuICAgIGxpc3QgPSBbXTtcbiAgfVxuICBjb25zdCBzY3JvbGxhYmxlQW5jZXN0b3IgPSBnZXROZWFyZXN0T3ZlcmZsb3dBbmNlc3Rvcihub2RlKTtcbiAgY29uc3QgaXNCb2R5ID0gc2Nyb2xsYWJsZUFuY2VzdG9yID09PSAoKF9ub2RlJG93bmVyRG9jdW1lbnQgPSBub2RlLm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfbm9kZSRvd25lckRvY3VtZW50LmJvZHkpO1xuICBjb25zdCB3aW4gPSBnZXRXaW5kb3coc2Nyb2xsYWJsZUFuY2VzdG9yKTtcbiAgaWYgKGlzQm9keSkge1xuICAgIHJldHVybiBsaXN0LmNvbmNhdCh3aW4sIHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNPdmVyZmxvd0VsZW1lbnQoc2Nyb2xsYWJsZUFuY2VzdG9yKSA/IHNjcm9sbGFibGVBbmNlc3RvciA6IFtdKTtcbiAgfVxuICByZXR1cm4gbGlzdC5jb25jYXQoc2Nyb2xsYWJsZUFuY2VzdG9yLCBnZXRPdmVyZmxvd0FuY2VzdG9ycyhzY3JvbGxhYmxlQW5jZXN0b3IpKTtcbn1cbmZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gIGNvbnN0IGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgdHJ1ZSwgc3RyYXRlZ3kgPT09IFwiZml4ZWRcIik7XG4gIGNvbnN0IHRvcCA9IGNsaWVudFJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gIGNvbnN0IGxlZnQgPSBjbGllbnRSZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XG4gIGNvbnN0IHNjYWxlID0gaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldFNjYWxlKGVsZW1lbnQpIDoge1xuICAgIHg6IDEsXG4gICAgeTogMVxuICB9O1xuICBjb25zdCB3aWR0aCA9IGVsZW1lbnQuY2xpZW50V2lkdGggKiBzY2FsZS54O1xuICBjb25zdCBoZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodCAqIHNjYWxlLnk7XG4gIGNvbnN0IHggPSBsZWZ0ICogc2NhbGUueDtcbiAgY29uc3QgeSA9IHRvcCAqIHNjYWxlLnk7XG4gIHJldHVybiB7XG4gICAgdG9wOiB5LFxuICAgIGxlZnQ6IHgsXG4gICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICBib3R0b206IHkgKyBoZWlnaHQsXG4gICAgeCxcbiAgICB5LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KSB7XG4gIGlmIChjbGlwcGluZ0FuY2VzdG9yID09PSBcInZpZXdwb3J0XCIpIHtcbiAgICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdChnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpKTtcbiAgfVxuICBpZiAoaXNFbGVtZW50KGNsaXBwaW5nQW5jZXN0b3IpKSB7XG4gICAgcmV0dXJuIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nQW5jZXN0b3IsIHN0cmF0ZWd5KTtcbiAgfVxuICByZXR1cm4gcmVjdFRvQ2xpZW50UmVjdChnZXREb2N1bWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKSk7XG59XG5mdW5jdGlvbiBnZXRDbGlwcGluZ0VsZW1lbnRBbmNlc3RvcnMoZWxlbWVudCwgY2FjaGUpIHtcbiAgY29uc3QgY2FjaGVkUmVzdWx0ID0gY2FjaGUuZ2V0KGVsZW1lbnQpO1xuICBpZiAoY2FjaGVkUmVzdWx0KSB7XG4gICAgcmV0dXJuIGNhY2hlZFJlc3VsdDtcbiAgfVxuICBsZXQgcmVzdWx0ID0gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZWxlbWVudCkuZmlsdGVyKChlbCkgPT4gaXNFbGVtZW50KGVsKSAmJiBnZXROb2RlTmFtZShlbCkgIT09IFwiYm9keVwiKTtcbiAgbGV0IGN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlID0gbnVsbDtcbiAgY29uc3QgZWxlbWVudElzRml4ZWQgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09IFwiZml4ZWRcIjtcbiAgbGV0IGN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgd2hpbGUgKGlzRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgIWlzTGFzdFRyYXZlcnNhYmxlTm9kZShjdXJyZW50Tm9kZSkpIHtcbiAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnROb2RlKTtcbiAgICBjb25zdCBjb250YWluaW5nQmxvY2sgPSBpc0NvbnRhaW5pbmdCbG9jayhjdXJyZW50Tm9kZSk7XG4gICAgY29uc3Qgc2hvdWxkRHJvcEN1cnJlbnROb2RlID0gZWxlbWVudElzRml4ZWQgPyAhY29udGFpbmluZ0Jsb2NrICYmICFjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA6ICFjb250YWluaW5nQmxvY2sgJiYgY29tcHV0ZWRTdHlsZS5wb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiAmJiAhIWN1cnJlbnRDb250YWluaW5nQmxvY2tDb21wdXRlZFN0eWxlICYmIFtcImFic29sdXRlXCIsIFwiZml4ZWRcIl0uaW5jbHVkZXMoY3VycmVudENvbnRhaW5pbmdCbG9ja0NvbXB1dGVkU3R5bGUucG9zaXRpb24pO1xuICAgIGlmIChzaG91bGREcm9wQ3VycmVudE5vZGUpIHtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdC5maWx0ZXIoKGFuY2VzdG9yKSA9PiBhbmNlc3RvciAhPT0gY3VycmVudE5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q29udGFpbmluZ0Jsb2NrQ29tcHV0ZWRTdHlsZSA9IGNvbXB1dGVkU3R5bGU7XG4gICAgfVxuICAgIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShjdXJyZW50Tm9kZSk7XG4gIH1cbiAgY2FjaGUuc2V0KGVsZW1lbnQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoX3JlZikge1xuICBsZXQge1xuICAgIGVsZW1lbnQsXG4gICAgYm91bmRhcnksXG4gICAgcm9vdEJvdW5kYXJ5LFxuICAgIHN0cmF0ZWd5XG4gIH0gPSBfcmVmO1xuICBjb25zdCBlbGVtZW50Q2xpcHBpbmdBbmNlc3RvcnMgPSBib3VuZGFyeSA9PT0gXCJjbGlwcGluZ0FuY2VzdG9yc1wiID8gZ2V0Q2xpcHBpbmdFbGVtZW50QW5jZXN0b3JzKGVsZW1lbnQsIHRoaXMuX2MpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgY29uc3QgY2xpcHBpbmdBbmNlc3RvcnMgPSBbLi4uZWxlbWVudENsaXBwaW5nQW5jZXN0b3JzLCByb290Qm91bmRhcnldO1xuICBjb25zdCBmaXJzdENsaXBwaW5nQW5jZXN0b3IgPSBjbGlwcGluZ0FuY2VzdG9yc1swXTtcbiAgY29uc3QgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdBbmNlc3RvcnMucmVkdWNlKChhY2NSZWN0LCBjbGlwcGluZ0FuY2VzdG9yKSA9PiB7XG4gICAgY29uc3QgcmVjdCA9IGdldENsaWVudFJlY3RGcm9tQ2xpcHBpbmdBbmNlc3RvcihlbGVtZW50LCBjbGlwcGluZ0FuY2VzdG9yLCBzdHJhdGVneSk7XG4gICAgYWNjUmVjdC50b3AgPSBtYXgocmVjdC50b3AsIGFjY1JlY3QudG9wKTtcbiAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgIGFjY1JlY3QuYm90dG9tID0gbWluKHJlY3QuYm90dG9tLCBhY2NSZWN0LmJvdHRvbSk7XG4gICAgYWNjUmVjdC5sZWZ0ID0gbWF4KHJlY3QubGVmdCwgYWNjUmVjdC5sZWZ0KTtcbiAgICByZXR1cm4gYWNjUmVjdDtcbiAgfSwgZ2V0Q2xpZW50UmVjdEZyb21DbGlwcGluZ0FuY2VzdG9yKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdBbmNlc3Rvciwgc3RyYXRlZ3kpKTtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogY2xpcHBpbmdSZWN0LnJpZ2h0IC0gY2xpcHBpbmdSZWN0LmxlZnQsXG4gICAgaGVpZ2h0OiBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcCxcbiAgICB4OiBjbGlwcGluZ1JlY3QubGVmdCxcbiAgICB5OiBjbGlwcGluZ1JlY3QudG9wXG4gIH07XG59XG5jb25zdCBwbGF0Zm9ybSA9IHtcbiAgZ2V0Q2xpcHBpbmdSZWN0LFxuICBjb252ZXJ0T2Zmc2V0UGFyZW50UmVsYXRpdmVSZWN0VG9WaWV3cG9ydFJlbGF0aXZlUmVjdCxcbiAgaXNFbGVtZW50LFxuICBnZXREaW1lbnNpb25zLFxuICBnZXRPZmZzZXRQYXJlbnQsXG4gIGdldERvY3VtZW50RWxlbWVudCxcbiAgZ2V0U2NhbGUsXG4gIGdldEVsZW1lbnRSZWN0cyhfcmVmKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCB7XG4gICAgICAgIHJlZmVyZW5jZSxcbiAgICAgICAgZmxvYXRpbmcsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGNvbnN0IGdldE9mZnNldFBhcmVudEZuID0gdGhpcy5nZXRPZmZzZXRQYXJlbnQgfHwgZ2V0T2Zmc2V0UGFyZW50O1xuICAgICAgY29uc3QgZ2V0RGltZW5zaW9uc0ZuID0gdGhpcy5nZXREaW1lbnNpb25zO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVmZXJlbmNlOiBnZXRSZWN0UmVsYXRpdmVUb09mZnNldFBhcmVudChyZWZlcmVuY2UsIHlpZWxkIGdldE9mZnNldFBhcmVudEZuKGZsb2F0aW5nKSwgc3RyYXRlZ3kpLFxuICAgICAgICBmbG9hdGluZzogX19zcHJlYWRWYWx1ZXMoe1xuICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgeTogMFxuICAgICAgICB9LCB5aWVsZCBnZXREaW1lbnNpb25zRm4oZmxvYXRpbmcpKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfSxcbiAgZ2V0Q2xpZW50UmVjdHM6IChlbGVtZW50KSA9PiBBcnJheS5mcm9tKGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKSksXG4gIGlzUlRMOiAoZWxlbWVudCkgPT4gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLmRpcmVjdGlvbiA9PT0gXCJydGxcIlxufTtcbmZ1bmN0aW9uIGF1dG9VcGRhdGUocmVmZXJlbmNlLCBmbG9hdGluZywgdXBkYXRlLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cbiAgY29uc3Qge1xuICAgIGFuY2VzdG9yU2Nyb2xsOiBfYW5jZXN0b3JTY3JvbGwgPSB0cnVlLFxuICAgIGFuY2VzdG9yUmVzaXplID0gdHJ1ZSxcbiAgICBlbGVtZW50UmVzaXplID0gdHJ1ZSxcbiAgICBhbmltYXRpb25GcmFtZSA9IGZhbHNlXG4gIH0gPSBvcHRpb25zO1xuICBjb25zdCBhbmNlc3RvclNjcm9sbCA9IF9hbmNlc3RvclNjcm9sbCAmJiAhYW5pbWF0aW9uRnJhbWU7XG4gIGNvbnN0IGFuY2VzdG9ycyA9IGFuY2VzdG9yU2Nyb2xsIHx8IGFuY2VzdG9yUmVzaXplID8gWy4uLmlzRWxlbWVudChyZWZlcmVuY2UpID8gZ2V0T3ZlcmZsb3dBbmNlc3RvcnMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGdldE92ZXJmbG93QW5jZXN0b3JzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSwgLi4uZ2V0T3ZlcmZsb3dBbmNlc3RvcnMoZmxvYXRpbmcpXSA6IFtdO1xuICBhbmNlc3RvcnMuZm9yRWFjaCgoYW5jZXN0b3IpID0+IHtcbiAgICBhbmNlc3RvclNjcm9sbCAmJiBhbmNlc3Rvci5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHVwZGF0ZSwge1xuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFuY2VzdG9yUmVzaXplICYmIGFuY2VzdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlKTtcbiAgfSk7XG4gIGxldCBvYnNlcnZlciA9IG51bGw7XG4gIGlmIChlbGVtZW50UmVzaXplKSB7XG4gICAgbGV0IGluaXRpYWxVcGRhdGUgPSB0cnVlO1xuICAgIG9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHtcbiAgICAgIGlmICghaW5pdGlhbFVwZGF0ZSkge1xuICAgICAgICB1cGRhdGUoKTtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxVcGRhdGUgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBpc0VsZW1lbnQocmVmZXJlbmNlKSAmJiAhYW5pbWF0aW9uRnJhbWUgJiYgb2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2UpO1xuICAgIGlmICghaXNFbGVtZW50KHJlZmVyZW5jZSkgJiYgcmVmZXJlbmNlLmNvbnRleHRFbGVtZW50ICYmICFhbmltYXRpb25GcmFtZSkge1xuICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZShyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpO1xuICAgIH1cbiAgICBvYnNlcnZlci5vYnNlcnZlKGZsb2F0aW5nKTtcbiAgfVxuICBsZXQgZnJhbWVJZDtcbiAgbGV0IHByZXZSZWZSZWN0ID0gYW5pbWF0aW9uRnJhbWUgPyBnZXRCb3VuZGluZ0NsaWVudFJlY3QocmVmZXJlbmNlKSA6IG51bGw7XG4gIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgIGZyYW1lTG9vcCgpO1xuICB9XG4gIGZ1bmN0aW9uIGZyYW1lTG9vcCgpIHtcbiAgICBjb25zdCBuZXh0UmVmUmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChyZWZlcmVuY2UpO1xuICAgIGlmIChwcmV2UmVmUmVjdCAmJiAobmV4dFJlZlJlY3QueCAhPT0gcHJldlJlZlJlY3QueCB8fCBuZXh0UmVmUmVjdC55ICE9PSBwcmV2UmVmUmVjdC55IHx8IG5leHRSZWZSZWN0LndpZHRoICE9PSBwcmV2UmVmUmVjdC53aWR0aCB8fCBuZXh0UmVmUmVjdC5oZWlnaHQgIT09IHByZXZSZWZSZWN0LmhlaWdodCkpIHtcbiAgICAgIHVwZGF0ZSgpO1xuICAgIH1cbiAgICBwcmV2UmVmUmVjdCA9IG5leHRSZWZSZWN0O1xuICAgIGZyYW1lSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnJhbWVMb29wKTtcbiAgfVxuICB1cGRhdGUoKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICB2YXIgX29ic2VydmVyO1xuICAgIGFuY2VzdG9ycy5mb3JFYWNoKChhbmNlc3RvcikgPT4ge1xuICAgICAgYW5jZXN0b3JTY3JvbGwgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB1cGRhdGUpO1xuICAgICAgYW5jZXN0b3JSZXNpemUgJiYgYW5jZXN0b3IucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB1cGRhdGUpO1xuICAgIH0pO1xuICAgIChfb2JzZXJ2ZXIgPSBvYnNlcnZlcikgPT0gbnVsbCA/IHZvaWQgMCA6IF9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgb2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmIChhbmltYXRpb25GcmFtZSkge1xuICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoZnJhbWVJZCk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgY29tcHV0ZVBvc2l0aW9uID0gKHJlZmVyZW5jZSwgZmxvYXRpbmcsIG9wdGlvbnMpID0+IHtcbiAgY29uc3QgY2FjaGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCBtZXJnZWRPcHRpb25zID0gX19zcHJlYWRWYWx1ZXMoe1xuICAgIHBsYXRmb3JtXG4gIH0sIG9wdGlvbnMpO1xuICBjb25zdCBwbGF0Zm9ybVdpdGhDYWNoZSA9IF9fc3ByZWFkUHJvcHMoX19zcHJlYWRWYWx1ZXMoe30sIG1lcmdlZE9wdGlvbnMucGxhdGZvcm0pLCB7XG4gICAgX2M6IGNhY2hlXG4gIH0pO1xuICByZXR1cm4gY29tcHV0ZVBvc2l0aW9uJDEocmVmZXJlbmNlLCBmbG9hdGluZywgX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgbWVyZ2VkT3B0aW9ucyksIHtcbiAgICBwbGF0Zm9ybTogcGxhdGZvcm1XaXRoQ2FjaGVcbiAgfSkpO1xufTtcbmZ1bmN0aW9uIFAobDIsIHUyLCBlMikge1xuICBsZXQgYzIgPSAoKSA9PiB7XG4gICAgdmFyIHQyO1xuICAgIHJldHVybiAodDIgPSBlMiA9PSBudWxsID8gdm9pZCAwIDogZTIucGxhY2VtZW50KSAhPSBudWxsID8gdDIgOiBcImJvdHRvbVwiO1xuICB9LCBkID0gKCkgPT4ge1xuICAgIHZhciB0MjtcbiAgICByZXR1cm4gKHQyID0gZTIgPT0gbnVsbCA/IHZvaWQgMCA6IGUyLnN0cmF0ZWd5KSAhPSBudWxsID8gdDIgOiBcImFic29sdXRlXCI7XG4gIH0sIFtuMiwgbzJdID0gY3JlYXRlU2lnbmFsKHsgeDogbnVsbCwgeTogbnVsbCwgcGxhY2VtZW50OiBjMigpLCBzdHJhdGVneTogZCgpLCBtaWRkbGV3YXJlRGF0YToge30gfSksIFt4LCBGXSA9IGNyZWF0ZVNpZ25hbCgpO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4ge1xuICAgIGxldCB0MiA9IHgoKTtcbiAgICBpZiAodDIpXG4gICAgICB0aHJvdyB0Mi52YWx1ZTtcbiAgfSk7XG4gIGxldCBzMiA9IGNyZWF0ZU1lbW8oKCkgPT4gKGwyKCksIHUyKCksIHt9KSk7XG4gIGZ1bmN0aW9uIGkyKCkge1xuICAgIGxldCB0MiA9IGwyKCksIHIgPSB1MigpO1xuICAgIGlmICh0MiAmJiByKSB7XG4gICAgICBsZXQgYTIgPSBzMigpO1xuICAgICAgY29tcHV0ZVBvc2l0aW9uKHQyLCByLCB7IG1pZGRsZXdhcmU6IGUyID09IG51bGwgPyB2b2lkIDAgOiBlMi5taWRkbGV3YXJlLCBwbGFjZW1lbnQ6IGMyKCksIHN0cmF0ZWd5OiBkKCkgfSkudGhlbigobSkgPT4ge1xuICAgICAgICBhMiA9PT0gczIoKSAmJiBvMihtKTtcbiAgICAgIH0sIChtKSA9PiB7XG4gICAgICAgIEYobSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVmZmVjdCgoKSA9PiB7XG4gICAgbGV0IHQyID0gbDIoKSwgciA9IHUyKCk7XG4gICAgaWYgKGUyID09IG51bGwgfHwgZTIubWlkZGxld2FyZSwgYzIoKSwgZCgpLCB0MiAmJiByKVxuICAgICAgaWYgKGUyICE9IG51bGwgJiYgZTIud2hpbGVFbGVtZW50c01vdW50ZWQpIHtcbiAgICAgICAgbGV0IGEyID0gZTIud2hpbGVFbGVtZW50c01vdW50ZWQodDIsIHIsIGkyKTtcbiAgICAgICAgYTIgJiYgb25DbGVhbnVwKGEyKTtcbiAgICAgIH0gZWxzZVxuICAgICAgICBpMigpO1xuICB9KSwgeyBnZXQgeCgpIHtcbiAgICByZXR1cm4gbjIoKS54O1xuICB9LCBnZXQgeSgpIHtcbiAgICByZXR1cm4gbjIoKS55O1xuICB9LCBnZXQgcGxhY2VtZW50KCkge1xuICAgIHJldHVybiBuMigpLnBsYWNlbWVudDtcbiAgfSwgZ2V0IHN0cmF0ZWd5KCkge1xuICAgIHJldHVybiBuMigpLnN0cmF0ZWd5O1xuICB9LCBnZXQgbWlkZGxld2FyZURhdGEoKSB7XG4gICAgcmV0dXJuIG4yKCkubWlkZGxld2FyZURhdGE7XG4gIH0sIHVwZGF0ZTogaTIgfTtcbn1cbmNvbnN0IF90bXBsJCQzID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDx0Yy1yb290IGRhdGEtdGMtZHJvcGRvd24tY29udGFpbmVyPVwidHJ1ZVwiPjwvdGMtcm9vdD5gKTtcbmNvbnN0IEFjY291bnRCdXR0b24gPSAoKSA9PiB7XG4gIGNvbnN0IHRoZW1lID0gdXNlVGhlbWUoKTtcbiAgY29uc3QgY29ubmVjdG9yID0gdXNlQ29udGV4dChDb25uZWN0b3JDb250ZXh0KTtcbiAgY29uc3QgdG9uQ29ubmVjdFVJID0gdXNlQ29udGV4dChUb25Db25uZWN0VWlDb250ZXh0KTtcbiAgY29uc3QgW2lzT3BlbmVkLCBzZXRJc09wZW5lZF0gPSBjcmVhdGVTaWduYWwoZmFsc2UpO1xuICBjb25zdCBbYWNjb3VudCwgc2V0QWNjb3VudF0gPSBjcmVhdGVTaWduYWwoY29ubmVjdG9yLmFjY291bnQpO1xuICBjb25zdCBbcmVzdG9yaW5nUHJvY2Vzcywgc2V0UmVzdG9yaW5nUHJvY2Vzc10gPSBjcmVhdGVTaWduYWwodHJ1ZSk7XG4gIGxldCBkcm9wRG93blJlZjtcbiAgY29uc3QgW2Zsb2F0aW5nLCBzZXRGbG9hdGluZ10gPSBjcmVhdGVTaWduYWwoKTtcbiAgY29uc3QgW2FuY2hvciwgc2V0QW5jaG9yXSA9IGNyZWF0ZVNpZ25hbCgpO1xuICBjb25zdCBwb3NpdGlvbiA9IFAoYW5jaG9yLCBmbG9hdGluZywge1xuICAgIHdoaWxlRWxlbWVudHNNb3VudGVkOiBhdXRvVXBkYXRlLFxuICAgIHBsYWNlbWVudDogXCJib3R0b20tZW5kXCJcbiAgfSk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBZGRyZXNzID0gKCkgPT4ge1xuICAgIGNvbnN0IGFjYyA9IGFjY291bnQoKTtcbiAgICBpZiAoYWNjKSB7XG4gICAgICBjb25zdCB1c2VyRnJpZW5kbHlBZGRyZXNzID0gdG9Vc2VyRnJpZW5kbHlBZGRyZXNzKGFjYy5hZGRyZXNzLCBhY2MuY2hhaW4gPT09IENIQUlOLlRFU1RORVQpO1xuICAgICAgcmV0dXJuIHVzZXJGcmllbmRseUFkZHJlc3Muc2xpY2UoMCwgNCkgKyBcIlxcdTIwMjZcIiArIHVzZXJGcmllbmRseUFkZHJlc3Muc2xpY2UoLTQpO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfTtcbiAgdG9uQ29ubmVjdFVJLmNvbm5lY3Rpb25SZXN0b3JlZC50aGVuKCgpID0+IHNldFJlc3RvcmluZ1Byb2Nlc3MoZmFsc2UpKTtcbiAgY29uc3QgdW5zdWJzY3JpYmUgPSBjb25uZWN0b3Iub25TdGF0dXNDaGFuZ2UoKHdhbGxldCkgPT4ge1xuICAgIGlmICghd2FsbGV0KSB7XG4gICAgICBzZXRJc09wZW5lZChmYWxzZSk7XG4gICAgICBzZXRBY2NvdW50KG51bGwpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzZXRBY2NvdW50KHdhbGxldC5hY2NvdW50KTtcbiAgfSk7XG4gIGNvbnN0IG9uQ2xpY2sgPSAoZTIpID0+IHtcbiAgICBpZiAoIWFjY291bnQoKSB8fCAhaXNPcGVuZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjbGlja1RvQnV0dG9uID0gYW5jaG9yKCkuY29udGFpbnMoZTIudGFyZ2V0KTtcbiAgICBjb25zdCBjbGlja1RvRHJvcGRvd24gPSBkcm9wRG93blJlZi5jb250YWlucyhlMi50YXJnZXQpO1xuICAgIGlmICghY2xpY2tUb0J1dHRvbiAmJiAhY2xpY2tUb0Ryb3Bkb3duKSB7XG4gICAgICBzZXRJc09wZW5lZChmYWxzZSk7XG4gICAgfVxuICB9O1xuICBvbk1vdW50KCgpID0+IHtcbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBvbkNsaWNrKTtcbiAgfSk7XG4gIG9uQ2xlYW51cCgoKSA9PiB7XG4gICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25DbGljayk7XG4gICAgdW5zdWJzY3JpYmUoKTtcbiAgfSk7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoRHluYW1pYywge1xuICAgIGNvbXBvbmVudDogZ2xvYmFsU3R5bGVzVGFnLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3RvcmluZ1Byb2Nlc3MoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoTG9hZGVyQnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICBkaXNhYmxlZDogdHJ1ZSxcbiAgICAgICAgICAgIFwiZGF0YS10Yy1jb25uZWN0LWJ1dHRvbi1sb2FkaW5nXCI6IFwidHJ1ZVwiLFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KExvYWRlckljb25TdHlsZWQsIHt9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiAhcmVzdG9yaW5nUHJvY2VzcygpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhYWNjb3VudCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY2NvdW50QnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gdG9uQ29ubmVjdFVJLmNvbm5lY3RXYWxsZXQoKSxcbiAgICAgICAgICAgICAgICBcImRhdGEtdGMtY29ubmVjdC1idXR0b25cIjogXCJ0cnVlXCIsXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoVG9uSWNvbiwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgZmlsbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbWUuY29sb3JzLmNvbm5lY3RCdXR0b24uZm9yZWdyb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0LCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImJ1dHRvbi5jb25uZWN0V2FsbGV0XCIsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjE1cHhcIixcbiAgICAgICAgICAgICAgICAgICAgbGluZUhlaWdodDogXCIxOHB4XCIsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiNTkwXCIsXG4gICAgICAgICAgICAgICAgICAgIGdldCBjb2xvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhlbWUuY29sb3JzLmNvbm5lY3RCdXR0b24uZm9yZWdyb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ29ubmVjdCB3YWxsZXRcIlxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFjY291bnQoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRHJvcGRvd25Db250YWluZXJTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChEcm9wZG93bkJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBzZXRJc09wZW5lZCgodikgPT4gIXYpLFxuICAgICAgICAgICAgICAgICAgICByZWY6IHNldEFuY2hvcixcbiAgICAgICAgICAgICAgICAgICAgXCJkYXRhLXRjLWRyb3Bkb3duLWJ1dHRvblwiOiBcInRydWVcIixcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFRleHQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiBcIjE1cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvbnRXZWlnaHQ6IFwiNTkwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBcIjE4cHhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZWRBZGRyZXNzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChBcnJvd0ljb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogXCJib3R0b21cIlxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChQb3J0YWwsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9lbCQgPSB1bnRyYWNrKCgpID0+IGRvY3VtZW50LmltcG9ydE5vZGUoX3RtcGwkJDMsIHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICB1c2Uoc2V0RmxvYXRpbmcsIF9lbCQpO1xuICAgICAgICAgICAgICAgICAgICAgIF9lbCQuc3R5bGUuc2V0UHJvcGVydHkoXCJ6LWluZGV4XCIsIFwiOTk5XCIpO1xuICAgICAgICAgICAgICAgICAgICAgIF9lbCQuXyRvd25lciA9IGdldE93bmVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChUcmFuc2l0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZUVudGVyOiAoZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZWwuYW5pbWF0ZShbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLThweClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgwKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1dLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDE1MFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkV4aXQ6IChlbCwgZG9uZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhMiA9IGVsLmFuaW1hdGUoW3tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKDApXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoLThweClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAxNTBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGEyLmZpbmlzaGVkLnRoZW4oZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc09wZW5lZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEcm9wZG93blN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgaGlkZGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhaXNPcGVuZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gc2V0SXNPcGVuZWQoZmFsc2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWYociQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfcmVmJCA9IGRyb3BEb3duUmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBfcmVmJCA9PT0gXCJmdW5jdGlvblwiID8gX3JlZiQociQpIDogZHJvcERvd25SZWYgPSByJDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChOb3RpZmljYXRpb25zU3R5bGVkLCB7fSksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgIGNyZWF0ZVJlbmRlckVmZmVjdCgoX3AkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX3YkID0gcG9zaXRpb24uc3RyYXRlZ3ksIF92JDIgPSBgJHsoX2EgPSBwb3NpdGlvbi55KSAhPSBudWxsID8gX2EgOiAwfXB4YCwgX3YkMyA9IGAkeyhfYiA9IHBvc2l0aW9uLngpICE9IG51bGwgPyBfYiA6IDB9cHhgO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3YkICE9PSBfcCQuX3YkICYmIF9lbCQuc3R5bGUuc2V0UHJvcGVydHkoXCJwb3NpdGlvblwiLCBfcCQuX3YkID0gX3YkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92JDIgIT09IF9wJC5fdiQyICYmIF9lbCQuc3R5bGUuc2V0UHJvcGVydHkoXCJ0b3BcIiwgX3AkLl92JDIgPSBfdiQyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92JDMgIT09IF9wJC5fdiQzICYmIF9lbCQuc3R5bGUuc2V0UHJvcGVydHkoXCJsZWZ0XCIsIF9wJC5fdiQzID0gX3YkMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3AkO1xuICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92JDogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3YkMjogdm9pZCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3YkMzogdm9pZCAwXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSldO1xuICAgIH1cbiAgfSk7XG59O1xuY29uc3QgYm9yZGVycyQxID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBRckNvZGVNb2RhbFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgJHttZWRpYShcIm1vYmlsZVwiKX0ge1xuICAgICAgICBwYWRkaW5nOiAxMHB4IDE2cHggMCAxNnB4O1xuICAgIH1cbmA7XG5jb25zdCBIMVN0eWxlZCQyID0gc3R5bGVkKEgxKWBcbiAgICBtYXgtd2lkdGg6IDMyMHB4O1xuICAgIG1hcmdpbjogMCBhdXRvIDZweDtcbmA7XG5jb25zdCBTdHlsZWRJY29uQnV0dG9uID0gc3R5bGVkKEljb25CdXR0b24pYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICB0b3A6IDE2cHg7XG4gICAgbGVmdDogMTZweDtcbmA7XG5jb25zdCBRUlN0eWxlZCA9IHN0eWxlZChRUkNvZGUpYFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG5gO1xuY29uc3QgQnV0dG9uc0NvbnRhaW5lclN0eWxlZCQxID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGdhcDogMTZweDtcbiAgICBoZWlnaHQ6IDU2cHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMjRweDtcbmA7XG5jb25zdCBBY3Rpb25CdXR0b25TdHlsZWQkMSA9IHN0eWxlZChCdXR0b24pYFxuICAgIHBhZGRpbmc6IDAgMTZweDtcbiAgICBoZWlnaHQ6IDU2cHg7XG4gICAgZm9udC1zaXplOiAxNnB4O1xuICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzJDFbcHJvcHMudGhlbWUuYm9yZGVyUmFkaXVzXX07XG5gO1xuY29uc3QgR2V0V2FsbGV0U3R5bGVkJDEgPSBzdHlsZWQuZGl2YFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5gO1xuY29uc3QgVGV4dFN0eWxlZCQxID0gc3R5bGVkKFRleHQpYFxuICAgIHBhZGRpbmctbGVmdDogOHB4O1xuICAgIGNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLnRleHQuc2Vjb25kYXJ5fTtcbiAgICBmb250LXNpemU6IDE2cHg7XG5gO1xuY29uc3QgW2FwcFN0YXRlLCBzZXRBcHBTdGF0ZV0gPSBjcmVhdGVTdG9yZSh7XG4gIGJ1dHRvblJvb3RJZDogbnVsbCxcbiAgbGFuZ3VhZ2U6IFwiZW5cIixcbiAgcmV0dXJuU3RyYXRlZ3k6IFwiYmFja1wiLFxuICB3YWxsZXRzTGlzdENvbmZpZ3VyYXRpb246IHt9XG59KTtcbmNvbnN0IEFTdHlsZWQgPSBzdHlsZWQuYWBcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICB0ZXh0LWRlY29yYXRpb246IHVuc2V0O1xuYDtcbmNvbnN0IExpbmsgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgYXR0cmlidXRlcyA9ICgpID0+IHByb3BzLmJsYW5rID8ge1xuICAgIHJlbDogXCJub3JlZmVycmVyIG5vb3BlbmVyXCJcbiAgfSA6IHt9O1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFTdHlsZWQsIG1lcmdlUHJvcHMoe1xuICAgIGdldCBocmVmKCkge1xuICAgICAgcmV0dXJuIHByb3BzLmhyZWY7XG4gICAgfSxcbiAgICBnZXQgdGFyZ2V0KCkge1xuICAgICAgcmV0dXJuIHByb3BzLmJsYW5rID8gXCJfYmxhbmtcIiA6IFwiX3NlbGZcIjtcbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMsIHtcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW47XG4gICAgfVxuICB9KSk7XG59O1xuY29uc3QgUXJDb2RlTW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgY29ubmVjdG9yID0gdXNlQ29udGV4dChDb25uZWN0b3JDb250ZXh0KTtcbiAgY29uc3QgdW5pdmVyc2FsTGluayA9IGNyZWF0ZU1lbW8oKCkgPT4gY29ubmVjdG9yLmNvbm5lY3Qoe1xuICAgIHVuaXZlcnNhbExpbms6IHByb3BzLndhbGxldC51bml2ZXJzYWxMaW5rLFxuICAgIGJyaWRnZVVybDogcHJvcHMud2FsbGV0LmJyaWRnZVVybFxuICB9LCBwcm9wcy5hZGRpdGlvbmFsUmVxdWVzdCkpO1xuICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFFyQ29kZU1vZGFsU3R5bGVkLCB7XG4gICAgXCJkYXRhLXRjLXdhbGxldC1xci1tb2RhbC1kZXNrdG9wXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFN0eWxlZEljb25CdXR0b24sIHtcbiAgICAgICAgaWNvbjogXCJhcnJvd1wiLFxuICAgICAgICBvbkNsaWNrOiAoKSA9PiBwcm9wcy5vbkJhY2tDbGljaygpXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEgxU3R5bGVkJDIsIHtcbiAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucXJDb2RlTW9kYWwuY29ubmVjdFdpdGhcIixcbiAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW1wiQ29ubmVjdCB3aXRoIFwiLCBjcmVhdGVNZW1vKCgpID0+IHByb3BzLndhbGxldC5uYW1lKV07XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoSDIsIHtcbiAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucXJDb2RlTW9kYWwuc2NhblwiLFxuICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbXCJTY2FuIFFSIGNvZGUgd2l0aCB5b3VyIHBob25lXFx1MjAxOXMgb3IgXCIsIGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpLCBcIlxcdTIwMTlzIGNhbWVyYS5cIl07XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoUVJTdHlsZWQsIHtcbiAgICAgICAgZGlzYWJsZUNvcHk6IGZhbHNlLFxuICAgICAgICBnZXQgc291cmNlVXJsKCkge1xuICAgICAgICAgIHJldHVybiB1bml2ZXJzYWxMaW5rKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBpbWFnZVVybCgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0LmltYWdlVXJsO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KEJ1dHRvbnNDb250YWluZXJTdHlsZWQkMSwge1xuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoQWN0aW9uQnV0dG9uU3R5bGVkJDEsIHtcbiAgICAgICAgICAgIHNjYWxlOiBcInNcIixcbiAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCBwcm9wcy53YWxsZXQpLCB7XG4gICAgICAgICAgICAgICAgb3Blbk1ldGhvZDogXCJ1bml2ZXJzYWwtbGlua1wiXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgb3BlbkxpbmtCbGFuayhhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rKCksIGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5KSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucXJDb2RlTW9kYWwub3BlbldhbGxldFwiLFxuICAgICAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHByb3BzLndhbGxldC5uYW1lXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcIk9wZW4gXCIsIGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZChwcm9wcy53YWxsZXQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25CdXR0b25TdHlsZWQkMSwge1xuICAgICAgICAgICAgICAgIHNjYWxlOiBcInNcIixcbiAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzZXRMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvKHByb3BzLndhbGxldCk7XG4gICAgICAgICAgICAgICAgICBjb25uZWN0b3IuY29ubmVjdCh7XG4gICAgICAgICAgICAgICAgICAgIGpzQnJpZGdlS2V5OiBwcm9wcy53YWxsZXQuanNCcmlkZ2VLZXlcbiAgICAgICAgICAgICAgICAgIH0sIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLm9wZW5FeHRlbnNpb25cIixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiT3BlbiBFeHRlbnNpb25cIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoR2V0V2FsbGV0U3R5bGVkJDEsIHtcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFRleHRTdHlsZWQkMSwge1xuICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwucXJDb2RlTW9kYWwuZG9udEhhdmVcIixcbiAgICAgICAgICAgIGdldCB0cmFuc2xhdGlvblZhbHVlcygpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwcm9wcy53YWxsZXQubmFtZVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFtcIkRvbid0IGhhdmUgXCIsIGNyZWF0ZU1lbW8oKCkgPT4gcHJvcHMud2FsbGV0Lm5hbWUpLCBcIj9cIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChMaW5rLCB7XG4gICAgICAgICAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BzLndhbGxldC5hYm91dFVybDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBibGFuazogdHJ1ZSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b24sIHtcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5nZXRcIixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiR0VUXCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBTdHlsZWRNb2RhbCA9IHN0eWxlZChNb2RhbClgXG4gICAgcGFkZGluZy1sZWZ0OiAyNHB4O1xuICAgIHBhZGRpbmctcmlnaHQ6IDI0cHg7XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIHBhZGRpbmctbGVmdDogMDtcbiAgICAgICAgcGFkZGluZy1yaWdodDogMDtcblxuICAgICAgICBtaW4taGVpZ2h0OiAzNjRweDtcbiAgICB9XG5gO1xuY29uc3QgSDFTdHlsZWQkMSA9IHN0eWxlZChIMSlgXG4gICAgbWFyZ2luLXRvcDogMTJweDtcblxuICAgICR7bWVkaWEoXCJtb2JpbGVcIil9IHtcbiAgICAgICAgcGFkZGluZzogMCAxMHB4O1xuICAgIH1cbmA7XG5jb25zdCBMb2FkZXJDb250YWluZXJTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIG1hcmdpbjogMzBweCAwO1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cbiAgICAke21lZGlhKFwibW9iaWxlXCIpfSB7XG4gICAgICAgIGhlaWdodDogMTYwcHg7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgfVxuYDtcbmNvbnN0IFRhYlRleHRTdHlsZWQgPSBzdHlsZWQoVGV4dClgXG4gICAgbWluLXdpZHRoOiA4NHB4O1xuICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICBmb250LXdlaWdodDogNTkwO1xuYDtcbmNvbnN0IFRhYkJhclN0eWxlZCA9IHN0eWxlZChUYWJCYXIpYFxuICAgIG1hcmdpbjogMCBhdXRvIDIycHg7XG5gO1xuZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICByZXR1cm4gWy4uLm5ldyBTZXQoYXJyYXkpXTtcbn1cbmZ1bmN0aW9uIG1lcmdlQ29uY2F0KGlkS2V5LCBhcnJheTEsIGFycmF5Mikge1xuICByZXR1cm4gYXJyYXkxLm1hcCgoaXRlbTEpID0+IHtcbiAgICBjb25zdCBpdGVtMiA9IGFycmF5Mi5maW5kKChlbGVtKSA9PiBlbGVtW2lkS2V5XSA9PT0gaXRlbTFbaWRLZXldKTtcbiAgICBhcnJheTIgPSBhcnJheTIuZmlsdGVyKChlbGVtKSA9PiBlbGVtW2lkS2V5XSAhPT0gaXRlbTFbaWRLZXldKTtcbiAgICByZXR1cm4gaXRlbTIgPT09IHZvaWQgMCA/IGl0ZW0xIDogaXRlbTI7XG4gIH0pLmNvbmNhdChhcnJheTIpO1xufVxuZnVuY3Rpb24gdWlXYWxsZXRUb1dhbGxldEluZm8odWlXYWxsZXQpIHtcbiAgaWYgKFwianNCcmlkZ2VLZXlcIiBpbiB1aVdhbGxldCkge1xuICAgIHJldHVybiBfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB1aVdhbGxldCksIHtcbiAgICAgIGluamVjdGVkOiBUb25Db25uZWN0LmlzV2FsbGV0SW5qZWN0ZWQodWlXYWxsZXQuanNCcmlkZ2VLZXkpLFxuICAgICAgZW1iZWRkZWQ6IFRvbkNvbm5lY3QuaXNJbnNpZGVXYWxsZXRCcm93c2VyKHVpV2FsbGV0LmpzQnJpZGdlS2V5KVxuICAgIH0pO1xuICB9XG4gIHJldHVybiB1aVdhbGxldDtcbn1cbmZ1bmN0aW9uIGFwcGx5V2FsbGV0c0xpc3RDb25maWd1cmF0aW9uKHdhbGxldHNMaXN0LCBjb25maWd1cmF0aW9uKSB7XG4gIHZhciBfYTtcbiAgaWYgKCFjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIHdhbGxldHNMaXN0O1xuICB9XG4gIGlmICgoX2EgPSBjb25maWd1cmF0aW9uLmluY2x1ZGVXYWxsZXRzKSA9PSBudWxsID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgd2FsbGV0c0xpc3QgPSBtZXJnZUNvbmNhdChcbiAgICAgIFwibmFtZVwiLFxuICAgICAgd2FsbGV0c0xpc3QsXG4gICAgICBjb25maWd1cmF0aW9uLmluY2x1ZGVXYWxsZXRzLm1hcCh1aVdhbGxldFRvV2FsbGV0SW5mbylcbiAgICApO1xuICB9XG4gIHJldHVybiB3YWxsZXRzTGlzdDtcbn1cbmZ1bmN0aW9uIGVxV2FsbGV0TmFtZSh3YWxsZXQxLCBuYW1lKSB7XG4gIGlmICghbmFtZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gd2FsbGV0MS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKSB8fCB3YWxsZXQxLmFwcE5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufVxuY29uc3QgW2lzTW9iaWxlLCBzZXRJc01vYmlsZV0gPSBjcmVhdGVTaWduYWwoaXNEZXZpY2UoXCJtb2JpbGVcIikpO1xuaWYgKGdldFdpbmRvdyQxKCkpIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgKCkgPT4gc2V0SXNNb2JpbGUoaXNEZXZpY2UoXCJtb2JpbGVcIikpKTtcbn1cbmNvbnN0IFVsU3R5bGVkID0gc3R5bGVkLnVsYFxuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgbWFyZ2luOiAwIGF1dG8gMjRweDtcbiAgICB3aWR0aDogZml0LWNvbnRlbnQ7XG4gICAgbWluLWhlaWdodDogMTI0cHg7XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgIG92ZXJmbG93LXg6IGF1dG87XG4gICAgb3ZlcmZsb3cteTogaGlkZGVuO1xuICAgIHBhZGRpbmc6IDAgMjRweDtcblxuICAgICYmOjotd2Via2l0LXNjcm9sbGJhciB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgfVxuXG4gICAgLW1zLW92ZXJmbG93LXN0eWxlOiBub25lO1xuICAgIHNjcm9sbGJhci13aWR0aDogbm9uZTtcbmA7XG5jb25zdCBEZWZhdWx0V2FsbGV0ID0gc3R5bGVkLmxpYFxuICAgIHdpZHRoOiA4MnB4O1xuICAgIG1pbi13aWR0aDogODJweDtcbiAgICBoZWlnaHQ6IDEyNHB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgIHBhZGRpbmc6IDhweCA0cHg7XG5cbiAgICB0ZXh0LWFsaWduOiBjZW50ZXI7XG4gICAgY3Vyc29yOiBwb2ludGVyO1xuXG4gICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMXMgZWFzZS1pbi1vdXQ7XG5cbiAgICAke21lZGlhTm90VG91Y2h9IHtcbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMDQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgJjphY3RpdmUge1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTYpO1xuICAgIH1cblxuICAgICR7bWVkaWFUb3VjaH0ge1xuICAgICAgICAmOmFjdGl2ZSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAuOTIpO1xuICAgICAgICB9XG4gICAgfVxuYDtcbmNvbnN0IERpdmlkZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiAxcHg7XG4gICAgbWFyZ2luOiAwIDEwcHg7XG4gICAgaGVpZ2h0OiAyNHB4O1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICB0b3A6IDMwcHg7XG5cbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiAkeyhwcm9wcykgPT4gcHJvcHMudGhlbWUuY29sb3JzLmljb24udGVydGlhcnl9O1xuYDtcbmNvbnN0IExvbmdBcnJvd0ljb25Db250YWluZXIgPSBzdHlsZWQuZGl2YFxuICAgIHdpZHRoOiA2NHB4O1xuICAgIGhlaWdodDogNjRweDtcbiAgICBib3JkZXItcmFkaXVzOiAxNnB4O1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblxuICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiByZ2JhKHByb3BzLnRoZW1lLmNvbG9ycy5hY2NlbnQsIDAuMTIpfTtcbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5hY2NlbnR9O1xuXG4gICAgbWFyZ2luLWJvdHRvbTogOHB4O1xuYDtcbmNvbnN0IEgyU3R5bGVkJDIgPSBzdHlsZWQoSDIpYFxuICAgIG1hcmdpbi1ib3R0b206IDI0cHg7XG4gICAgcGFkZGluZzogMCAyNHB4O1xuICAgIG1pbi1oZWlnaHQ6IDQ0cHg7XG5gO1xuY29uc3QgQnV0dG9uU3R5bGVkJDIgPSBzdHlsZWQoQnV0dG9uKWBcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgICBtYXJnaW46IDAgYXV0bztcbmA7XG5jb25zdCBMSU5LUyA9IHtcbiAgTEVBUk5fTU9SRTogXCJodHRwczovL3Rvbi5vcmcvd2FsbGV0c1wiXG59O1xuY29uc3QgX3RtcGwkJDIgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGRpdiBkYXRhLXRjLXdhbGxldHMtbW9kYWwtbW9iaWxlPVwidHJ1ZVwiPjwvZGl2PmApLCBfdG1wbCQyID0gLyogQF9fUFVSRV9fICovIHRlbXBsYXRlJDEoYDxsaT48L2xpPmApO1xuY29uc3QgTW9iaWxlU2VsZWN0V2FsbGV0TW9kYWwgPSAocHJvcHMpID0+IHtcbiAgY29uc3QgY29ubmVjdG9yID0gYXBwU3RhdGUuY29ubmVjdG9yO1xuICBjb25zdCB0aGVtZSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IG9uU2VsZWN0ID0gKHdhbGxldEluZm8pID0+IHtcbiAgICBpZiAoIWlzTW9iaWxlVXNlckFnZW50KCkpIHtcbiAgICAgIHJldHVybiBwcm9wcy5vblNlbGVjdCh3YWxsZXRJbmZvKTtcbiAgICB9XG4gICAgaWYgKFwidW5pdmVyc2FsTGlua1wiIGluIHdhbGxldEluZm8pIHtcbiAgICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oX19zcHJlYWRQcm9wcyhfX3NwcmVhZFZhbHVlcyh7fSwgd2FsbGV0SW5mbyksIHtcbiAgICAgICAgb3Blbk1ldGhvZDogXCJ1bml2ZXJzYWwtbGlua1wiXG4gICAgICB9KSk7XG4gICAgICBjb25zdCB1bml2ZXJzYWxMaW5rID0gY29ubmVjdG9yLmNvbm5lY3Qoe1xuICAgICAgICB1bml2ZXJzYWxMaW5rOiB3YWxsZXRJbmZvLnVuaXZlcnNhbExpbmssXG4gICAgICAgIGJyaWRnZVVybDogd2FsbGV0SW5mby5icmlkZ2VVcmxcbiAgICAgIH0sIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0KTtcbiAgICAgIG9wZW5MaW5rKGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wZW5MaW5rQmxhbmsod2FsbGV0SW5mby5hYm91dFVybCk7XG4gIH07XG4gIGNvbnN0IG9uU2VsZWN0VW5pdmVyc2FsID0gKCkgPT4ge1xuICAgIGNvbnN0IHVuaXZlcnNhbExpbmsgPSBjb25uZWN0b3IuY29ubmVjdChwcm9wcy53YWxsZXRzTGlzdC5maWx0ZXIoaXNXYWxsZXRJbmZvUmVtb3RlKS5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICBicmlkZ2VVcmw6IGl0ZW0uYnJpZGdlVXJsLFxuICAgICAgdW5pdmVyc2FsTGluazogaXRlbS51bml2ZXJzYWxMaW5rXG4gICAgfSkpLCBwcm9wcy5hZGRpdGlvbmFsUmVxdWVzdCk7XG4gICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyh7XG4gICAgICBvcGVuTWV0aG9kOiBcInVuaXZlcnNhbC1saW5rXCJcbiAgICB9KTtcbiAgICBvcGVuTGluayhhZGRSZXR1cm5TdHJhdGVneSh1bml2ZXJzYWxMaW5rLCBhcHBTdGF0ZS5yZXR1cm5TdHJhdGVneSkpO1xuICB9O1xuICByZXR1cm4gKCgpID0+IHtcbiAgICBjb25zdCBfZWwkID0gX3RtcGwkJDIuY2xvbmVOb2RlKHRydWUpO1xuICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoSDEsIHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZVNlbGVjdFdhbGxldE1vZGFsLmNvbm5lY3RXYWxsZXRcIixcbiAgICAgIGNoaWxkcmVuOiBcIkNvbm5lY3QgYSB3YWxsZXRcIlxuICAgIH0pLCBudWxsKTtcbiAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KEgyU3R5bGVkJDIsIHtcbiAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZVNlbGVjdFdhbGxldE1vZGFsLnNlbGVjdFdhbGxldFwiLFxuICAgICAgY2hpbGRyZW46IFwiU2VsZWN0IHlvdXIgd2FsbGV0IGZyb20gdGhlIG9wdGlvbnMgdG8gZ2V0IHN0YXJ0ZWQuXCJcbiAgICB9KSwgbnVsbCk7XG4gICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChVbFN0eWxlZCwge1xuICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChEZWZhdWx0V2FsbGV0LCB7XG4gICAgICAgICAgb25DbGljazogb25TZWxlY3RVbml2ZXJzYWwsXG4gICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTG9uZ0Fycm93SWNvbkNvbnRhaW5lciwge1xuICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb25nQXJyb3dJY29uLCB7XG4gICAgICAgICAgICAgICAgICBnZXQgZmlsbCgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoZW1lLmNvbG9ycy5hY2NlbnQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGV4dCwge1xuICAgICAgICAgICAgICBmb250V2VpZ2h0OiA1OTAsXG4gICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLm1vYmlsZVNlbGVjdFdhbGxldE1vZGFsLmluc3RhbGxlZFdhbGxldFwiLFxuICAgICAgICAgICAgICBjaGlsZHJlbjogXCJJbnN0YWxsZWQgd2FsbGV0XCJcbiAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoRGl2aWRlciwge1xuICAgICAgICAgIGNoaWxkcmVuOiBcIlxceEEwXCJcbiAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChGb3IsIHtcbiAgICAgICAgICBnZXQgZWFjaCgpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wcy53YWxsZXRzTGlzdC5maWx0ZXIoKHdhbGxldCkgPT4gXCJicmlkZ2VVcmxcIiBpbiB3YWxsZXQpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgY2hpbGRyZW46ICh3YWxsZXQpID0+ICgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBfZWwkMiA9IF90bXBsJDIuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgaW5zZXJ0KF9lbCQyLCBjcmVhdGVDb21wb25lbnQoV2FsbGV0SXRlbSwge1xuICAgICAgICAgICAgICBnZXQgaWNvblVybCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0LmltYWdlVXJsO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0Lm5hbWU7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IG9uU2VsZWN0KHdhbGxldClcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHJldHVybiBfZWwkMjtcbiAgICAgICAgICB9KSgpXG4gICAgICAgIH0pXTtcbiAgICAgIH1cbiAgICB9KSwgbnVsbCk7XG4gICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChMaW5rLCB7XG4gICAgICBnZXQgaHJlZigpIHtcbiAgICAgICAgcmV0dXJuIExJTktTLkxFQVJOX01PUkU7XG4gICAgICB9LFxuICAgICAgYmxhbms6IHRydWUsXG4gICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uU3R5bGVkJDIsIHtcbiAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5sZWFybk1vcmVcIixcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTGVhcm4gbW9yZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pLCBudWxsKTtcbiAgICByZXR1cm4gX2VsJDtcbiAgfSkoKTtcbn07XG5jb25zdCBib3JkZXJzID0ge1xuICBtOiBcIjE2cHhcIixcbiAgczogXCI4cHhcIixcbiAgbm9uZTogXCIwXCJcbn07XG5jb25zdCBob3ZlckJvcmRlcnMgPSB7XG4gIG06IFwiOHB4XCIsXG4gIHM6IFwiNHB4XCIsXG4gIG5vbmU6IFwiMFwiXG59O1xuY29uc3QgVW5pdmVyc2FsUXJNb2RhbFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5gO1xuY29uc3QgSDJTdHlsZWQkMSA9IHN0eWxlZChIMilgXG4gICAgbWF4LXdpZHRoOiAzMjBweDtcbiAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xuYDtcbmNvbnN0IFFSQ29kZVN0eWxlZCA9IHN0eWxlZChRUkNvZGUpYFxuICAgIG1hcmdpbi1ib3R0b206IDE2cHg7XG5gO1xuY29uc3QgQnV0dG9uc0NvbnRhaW5lclN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBnYXA6IDE2cHg7XG4gICAgd2lkdGg6IDEwMCU7XG5gO1xuY29uc3QgQWN0aW9uQnV0dG9uU3R5bGVkID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICB3aWR0aDogMTAwJTtcbiAgICBwYWRkaW5nOiAwIDE2cHg7XG4gICAgaGVpZ2h0OiA1NnB4O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuXG4gICAgJjpob3ZlciB7XG4gICAgICAgICR7KHByb3BzKSA9PiBwcm9wcy5kaXNhYmxlRXZlbnRzQW5pbWF0aW9uID8gXCJ0cmFuc2Zvcm06IHVuc2V0O1wiIDogXCJcIn1cbiAgICB9XG5cbiAgICAmOmFjdGl2ZSB7XG4gICAgICAgICR7KHByb3BzKSA9PiBwcm9wcy5kaXNhYmxlRXZlbnRzQW5pbWF0aW9uID8gXCJ0cmFuc2Zvcm06IHVuc2V0O1wiIDogXCJcIn1cbiAgICB9XG5gO1xuY29uc3QgUG9wdXBXcmFwcGVyU3R5bGVkID0gc3R5bGVkLnVsYFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICBib3R0b206IDEwMCU7XG4gICAgbGVmdDogMDtcbiAgICBtYXJnaW46IDA7XG4gICAgcGFkZGluZzogOHB4O1xuICAgIHdpZHRoOiAxODhweDtcbiAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTE2cHgpO1xuXG4gICAgYmFja2dyb3VuZC1jb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy5iYWNrZ3JvdW5kLnByaW1hcnl9O1xuICAgIGJvcmRlci1yYWRpdXM6ICR7KHByb3BzKSA9PiBib3JkZXJzW3Byb3BzLnRoZW1lLmJvcmRlclJhZGl1c119O1xuICAgIGJveC1zaGFkb3c6IDAgNHB4IDI0cHggcmdiYSgwLCAwLCAwLCAwLjE2KTtcbmA7XG5jb25zdCBFeHRlbnNpb25MaVN0eWxlZCA9IHN0eWxlZC5saWBcbiAgICBwYWRkaW5nOiA4cHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgZ2FwOiA4cHg7XG5cbiAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgYm9yZGVyLXJhZGl1czogJHsocHJvcHMpID0+IGhvdmVyQm9yZGVyc1twcm9wcy50aGVtZS5ib3JkZXJSYWRpdXNdfTtcblxuICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IsIHRyYW5zZm9ybSAwLjFzIGVhc2UtaW4tb3V0O1xuXG4gICAgJjpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMuYmFja2dyb3VuZC5zZWNvbmRhcnl9O1xuICAgIH1cblxuICAgICY6YWN0aXZlIHtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLjk2KTtcbiAgICB9XG5gO1xuY29uc3QgSW1hZ2VTdHlsZWQgPSBzdHlsZWQoSW1hZ2UpYFxuICAgIHdpZHRoOiAyNHB4O1xuICAgIGhlaWdodDogMjRweDtcblxuICAgIGJvcmRlci1yYWRpdXM6IDZweDtcbmA7XG5jb25zdCBHZXRXYWxsZXRTdHlsZWQgPSBzdHlsZWQuZGl2YFxuICAgIG1hcmdpbi10b3A6IDIzcHg7XG4gICAgbWFyZ2luLWJvdHRvbTogMXB4O1xuICAgIHdpZHRoOiAxMDAlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbmA7XG5zdHlsZWQoVGV4dClgXG4gICAgY29sb3I6ICR7KHByb3BzKSA9PiBwcm9wcy50aGVtZS5jb2xvcnMudGV4dC5zZWNvbmRhcnl9O1xuICAgIGZvbnQtc2l6ZTogMTZweDtcbmA7XG5jb25zdCBVbml2ZXJzYWxRck1vZGFsID0gKHByb3BzKSA9PiB7XG4gIGNvbnN0IFtwb3B1cE9wZW5lZCwgc2V0UG9wdXBPcGVuZWRdID0gY3JlYXRlU2lnbmFsKGZhbHNlKTtcbiAgY29uc3QgY29ubmVjdG9yID0gYXBwU3RhdGUuY29ubmVjdG9yO1xuICBjb25zdCB3YWxsZXRzQnJpZGdlcyA9IHByb3BzLndhbGxldHNMaXN0LmZpbHRlcihpc1dhbGxldEluZm9SZW1vdGUpLm1hcCgoaXRlbSkgPT4gKHtcbiAgICBicmlkZ2VVcmw6IGl0ZW0uYnJpZGdlVXJsLFxuICAgIHVuaXZlcnNhbExpbms6IGl0ZW0udW5pdmVyc2FsTGlua1xuICB9KSk7XG4gIGNvbnN0IGF2YWlsYWJsZUluamVjdGFibGVXYWxsZXRzID0gcHJvcHMud2FsbGV0c0xpc3QuZmlsdGVyKGlzV2FsbGV0SW5mb0N1cnJlbnRseUluamVjdGVkKTtcbiAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyh7XG4gICAgb3Blbk1ldGhvZDogXCJxcmNvZGVcIlxuICB9KTtcbiAgY29uc3QgcmVxdWVzdCA9IGNyZWF0ZU1lbW8oKCkgPT4gY29ubmVjdG9yLmNvbm5lY3Qod2FsbGV0c0JyaWRnZXMsIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0KSk7XG4gIGNvbnN0IG9uT3BlbldhbGxldENsaWNrID0gKCkgPT4ge1xuICAgIGxldCBibHVycmVkID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gYmx1ckhhbmRsZXIoKSB7XG4gICAgICBibHVycmVkID0gdHJ1ZTtcbiAgICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oe1xuICAgICAgICBvcGVuTWV0aG9kOiBcInVuaXZlcnNhbC1saW5rXCJcbiAgICAgIH0pO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJIYW5kbGVyKTtcbiAgICB9XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJIYW5kbGVyKTtcbiAgICBvcGVuTGluayhhZGRSZXR1cm5TdHJhdGVneShyZXF1ZXN0KCksIGFwcFN0YXRlLnJldHVyblN0cmF0ZWd5KSk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAoIWJsdXJyZWQpIHtcbiAgICAgICAgcHJvcHMub3BlbldhbGxldEZhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgYmx1ckhhbmRsZXIpO1xuICAgIH0sIDIwMCk7XG4gIH07XG4gIGNvbnN0IG9uT3BlbkV4dGVuc2lvbkNsaWNrID0gKGUyKSA9PiB7XG4gICAgZTIuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgaWYgKGF2YWlsYWJsZUluamVjdGFibGVXYWxsZXRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3Qgd2FsbGV0SW5mbyA9IGF2YWlsYWJsZUluamVjdGFibGVXYWxsZXRzWzBdO1xuICAgICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXRJbmZvKTtcbiAgICAgIGNvbm5lY3Rvci5jb25uZWN0KHtcbiAgICAgICAganNCcmlkZ2VLZXk6IHdhbGxldEluZm8uanNCcmlkZ2VLZXlcbiAgICAgIH0sIHByb3BzLmFkZGl0aW9uYWxSZXF1ZXN0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0UG9wdXBPcGVuZWQoKG9wZW5lZCkgPT4gIW9wZW5lZCk7XG4gIH07XG4gIGNvbnN0IG9uRXh0ZW5zaW9uQ2xpY2sgPSAod2FsbGV0SW5mbykgPT4ge1xuICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0SW5mbyk7XG4gICAgY29ubmVjdG9yLmNvbm5lY3Qoe1xuICAgICAganNCcmlkZ2VLZXk6IHdhbGxldEluZm8uanNCcmlkZ2VLZXlcbiAgICB9LCBwcm9wcy5hZGRpdGlvbmFsUmVxdWVzdCk7XG4gIH07XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoVW5pdmVyc2FsUXJNb2RhbFN0eWxlZCwge1xuICAgIG9uQ2xpY2s6ICgpID0+IHNldFBvcHVwT3BlbmVkKGZhbHNlKSxcbiAgICBcImRhdGEtdGMtdW5pdmVyc2FsLXFyLWRlc2t0b3BcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSDJTdHlsZWQkMSwge1xuICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC51bml2ZXJzYWxRUk1vZGFsLnNjYW5RUlwiLFxuICAgICAgICBjaGlsZHJlbjogXCJTY2FuIFFSIGNvZGUgd2l0aCBhIFRPTiBDb25uZWN0IGNvbXBhdGlibGUgd2FsbGV0LlwiXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFFSQ29kZVN0eWxlZCwge1xuICAgICAgICBnZXQgc291cmNlVXJsKCkge1xuICAgICAgICAgIHJldHVybiByZXF1ZXN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBkaXNhYmxlQ29weSgpIHtcbiAgICAgICAgICByZXR1cm4gcG9wdXBPcGVuZWQoKTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChCdXR0b25zQ29udGFpbmVyU3R5bGVkLCB7XG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChBY3Rpb25CdXR0b25TdHlsZWQsIHtcbiAgICAgICAgICAgIG9uQ2xpY2s6IG9uT3BlbldhbGxldENsaWNrLFxuICAgICAgICAgICAgc2NhbGU6IFwic1wiLFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYXZhaWxhYmxlSW5qZWN0YWJsZVdhbGxldHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC51bml2ZXJzYWxRUk1vZGFsLm9wZW5XYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiT3BlbiBXYWxsZXRcIlxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiAhYXZhaWxhYmxlSW5qZWN0YWJsZVdhbGxldHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC51bml2ZXJzYWxRUk1vZGFsLm9wZW5JbnN0YWxsZWRXYWxsZXRcIixcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiT3BlbiBJbnN0YWxsZWQgV2FsbGV0XCJcbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhdmFpbGFibGVJbmplY3RhYmxlV2FsbGV0cy5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEFjdGlvbkJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2s6IG9uT3BlbkV4dGVuc2lvbkNsaWNrLFxuICAgICAgICAgICAgICAgIGdldCBkaXNhYmxlRXZlbnRzQW5pbWF0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvcHVwT3BlbmVkKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzY2FsZTogXCJzXCIsXG4gICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoVHJhbnNpdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICBvbkJlZm9yZUVudGVyOiAoZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICBlbC5hbmltYXRlKFt7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5OiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZVkoMClcIlxuICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IFwidHJhbnNsYXRlWSgtMTZweClcIlxuICAgICAgICAgICAgICAgICAgICAgIH1dLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkdXJhdGlvbjogMTUwXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uRXhpdDogKGVsLCBkb25lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgZWwuYW5pbWF0ZShbe1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKC0xNnB4KVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGVZKDApXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZHVyYXRpb246IDE1MFxuICAgICAgICAgICAgICAgICAgICAgIH0pLmZpbmlzaGVkLnRoZW4oZG9uZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcG9wdXBPcGVuZWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoUG9wdXBXcmFwcGVyU3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChGb3IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWFjaDogYXZhaWxhYmxlSW5qZWN0YWJsZVdhbGxldHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiAod2FsbGV0KSA9PiBjcmVhdGVDb21wb25lbnQoRXh0ZW5zaW9uTGlTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrOiAoKSA9PiBvbkV4dGVuc2lvbkNsaWNrKHdhbGxldCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoSW1hZ2VTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHNyYygpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0LmltYWdlVXJsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHQ6IFwiXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoVGV4dCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiA1OTAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2FsbGV0Lm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcImNvbW1vbi5vcGVuRXh0ZW5zaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIk9wZW4gRXh0ZW5zaW9uXCJcbiAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiAhYXZhaWxhYmxlSW5qZWN0YWJsZVdhbGxldHMubGVuZ3RoO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChHZXRXYWxsZXRTdHlsZWQsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMaW5rLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gTElOS1MuTEVBUk5fTU9SRTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJsYW5rOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uLCB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVhcmFuY2U6IFwiZmxhdFwiLFxuICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IHVgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvbnQtc2l6ZTogMTVweDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBgLFxuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2xhdGlvbiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLmxlYXJuTW9yZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTGVhcm4gbW9yZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IERlc2t0b3BTZWxlY3RXYWxsZXRNb2RhbFN0eWxlZCA9IHN0eWxlZC5kaXZgXG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG5gO1xuY29uc3QgSDJTdHlsZWQgPSBzdHlsZWQoSDIpYFxuICAgIG1hcmdpbi1ib3R0b206IDI2cHg7XG5gO1xuY29uc3QgV2FsbGV0c1VsID0gc3R5bGVkLnVsYFxuICAgIGRpc3BsYXk6IGdyaWQ7XG4gICAgZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zOiByZXBlYXQoYXV0by1maXQsIDkycHgpO1xuICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgIHJvdy1nYXA6IDhweDtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIG1heC1oZWlnaHQ6IDQxMHB4O1xuICAgIHdpZHRoOiBjYWxjKDEwMCUgKyAxMnB4KTtcbiAgICBtYXJnaW4tYm90dG9tOiAzMHB4O1xuICAgIHBhZGRpbmc6IDEwcHggMDtcbiAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuXG4gICAgJiY6Oi13ZWJraXQtc2Nyb2xsYmFyIHtcbiAgICAgICAgd2lkdGg6IDhweDtcbiAgICB9XG5cbiAgICAmJjo6LXdlYmtpdC1zY3JvbGxiYXItdHJhY2sge1xuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICB9XG5cbiAgICAmJjo6LXdlYmtpdC1zY3JvbGxiYXItdGh1bWIge1xuICAgICAgICBiYWNrZ3JvdW5kOiAjY2FjYWNhO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAxMnB4O1xuICAgIH1cbmA7XG5jb25zdCBCdXR0b25TdHlsZWQkMSA9IHN0eWxlZChCdXR0b24pYFxuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIG1hcmdpbjogMCBhdXRvIDFweDtcbiAgICBmb250LXNpemU6IDE1cHg7XG5gO1xuY29uc3QgX3RtcGwkJDEgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGxpPjwvbGk+YCk7XG5jb25zdCBEZXNrdG9wU2VsZWN0V2FsbGV0TW9kYWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChEZXNrdG9wU2VsZWN0V2FsbGV0TW9kYWxTdHlsZWQsIHtcbiAgICBcImRhdGEtdGMtc2VsZWN0LXdhbGxldC1kZXNrdG9wXCI6IFwidHJ1ZVwiLFxuICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KEgyU3R5bGVkLCB7XG4gICAgICAgIHRyYW5zbGF0aW9uS2V5OiBcIndhbGxldE1vZGFsLmRlc2t0b3BTZWxlY3RXYWxsZXRNb2RhbC5zZWxlY3RXYWxsZXRcIixcbiAgICAgICAgY2hpbGRyZW46IFwiQ2hvb3NlIHlvdXIgcHJlZmVycmVkIHdhbGxldCBmcm9tIHRoZSBvcHRpb25zIHRvIGdldCBzdGFydGVkLlwiXG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFdhbGxldHNVbCwge1xuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChGb3IsIHtcbiAgICAgICAgICAgIGdldCBlYWNoKCkge1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcHMud2FsbGV0c0xpc3Q7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2hpbGRyZW46ICh3YWxsZXQpID0+ICgoKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IF9lbCQgPSBfdG1wbCQkMS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgIGluc2VydChfZWwkLCBjcmVhdGVDb21wb25lbnQoV2FsbGV0SXRlbSwge1xuICAgICAgICAgICAgICAgIGdldCBpY29uVXJsKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5pbWFnZVVybDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBuYW1lKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldC5uYW1lO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25TZWxlY3Qod2FsbGV0KVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIHJldHVybiBfZWwkO1xuICAgICAgICAgICAgfSkoKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KExpbmssIHtcbiAgICAgICAgZ2V0IGhyZWYoKSB7XG4gICAgICAgICAgcmV0dXJuIExJTktTLkxFQVJOX01PUkU7XG4gICAgICAgIH0sXG4gICAgICAgIGJsYW5rOiB0cnVlLFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChCdXR0b25TdHlsZWQkMSwge1xuICAgICAgICAgICAgYXBwZWFyYW5jZTogXCJmbGF0XCIsXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24ubGVhcm5Nb3JlXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiTGVhcm4gbW9yZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KV07XG4gICAgfVxuICB9KTtcbn07XG5jb25zdCBfdG1wbCQgPSAvKiBAX19QVVJFX18gKi8gdGVtcGxhdGUkMShgPGRpdiBkYXRhLXRjLXdhbGxldHMtbW9kYWwtZGVza3RvcD1cInRydWVcIj48L2Rpdj5gKTtcbmNvbnN0IFdhbGxldHNNb2RhbCA9ICgpID0+IHtcbiAgY29uc3Qge1xuICAgIGxvY2FsZVxuICB9ID0gdXNlSTE4bigpWzFdO1xuICBjcmVhdGVFZmZlY3QoKCkgPT4gbG9jYWxlKGFwcFN0YXRlLmxhbmd1YWdlKSk7XG4gIGNvbnN0IGNvbm5lY3RvciA9IHVzZUNvbnRleHQoQ29ubmVjdG9yQ29udGV4dCk7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFtmZXRjaGVkV2FsbGV0c0xpc3RdID0gY3JlYXRlUmVzb3VyY2UoKCkgPT4gdG9uQ29ubmVjdFVJLmdldFdhbGxldHMoKSk7XG4gIGNvbnN0IFtzZWxlY3RlZFdhbGxldEluZm8sIHNldFNlbGVjdGVkV2FsbGV0SW5mb10gPSBjcmVhdGVTaWduYWwobnVsbCk7XG4gIGNvbnN0IFtzZWxlY3RlZFRhYkluZGV4LCBzZXRTZWxlY3RlZFRhYkluZGV4XSA9IGNyZWF0ZVNpZ25hbCgwKTtcbiAgY29uc3Qgd2FsbGV0c0xpc3QgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICBpZiAoZmV0Y2hlZFdhbGxldHNMaXN0LnN0YXRlICE9PSBcInJlYWR5XCIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgd2FsbGV0c0xpc3QyID0gYXBwbHlXYWxsZXRzTGlzdENvbmZpZ3VyYXRpb24oZmV0Y2hlZFdhbGxldHNMaXN0KCksIGFwcFN0YXRlLndhbGxldHNMaXN0Q29uZmlndXJhdGlvbik7XG4gICAgY29uc3QgcHJlZmVycmVkV2FsbGV0TmFtZSA9IGFwcFN0YXRlLnByZWZlcnJlZFdhbGxldE5hbWU7XG4gICAgY29uc3QgcHJlZmVycmVkV2FsbGV0ID0gd2FsbGV0c0xpc3QyLmZpbmQoKGl0ZW0pID0+IGVxV2FsbGV0TmFtZShpdGVtLCBwcmVmZXJyZWRXYWxsZXROYW1lKSk7XG4gICAgY29uc3Qgc29tZVdhbGxldHNXaXRoU2FtZU5hbWUgPSB3YWxsZXRzTGlzdDIuZmlsdGVyKChpdGVtKSA9PiBlcVdhbGxldE5hbWUoaXRlbSwgcHJlZmVycmVkV2FsbGV0TmFtZSkpLmxlbmd0aCA+PSAyO1xuICAgIGlmIChwcmVmZXJyZWRXYWxsZXROYW1lICYmIHByZWZlcnJlZFdhbGxldCAmJiAhc29tZVdhbGxldHNXaXRoU2FtZU5hbWUpIHtcbiAgICAgIHdhbGxldHNMaXN0MiA9IFtwcmVmZXJyZWRXYWxsZXRdLmNvbmNhdCh3YWxsZXRzTGlzdDIuZmlsdGVyKChpdGVtKSA9PiAhZXFXYWxsZXROYW1lKGl0ZW0sIHByZWZlcnJlZFdhbGxldE5hbWUpKSk7XG4gICAgfVxuICAgIHJldHVybiB3YWxsZXRzTGlzdDI7XG4gIH0pO1xuICBjb25zdCBhZGRpdGlvbmFsUmVxdWVzdExvYWRpbmcgPSAoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc3RhdGUpID09PSBcImxvYWRpbmdcIjtcbiAgfTtcbiAgY29uc3QgYWRkaXRpb25hbFJlcXVlc3QgPSBjcmVhdGVNZW1vKCgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGFkZGl0aW9uYWxSZXF1ZXN0TG9hZGluZygpKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gKF9hID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSA9PSBudWxsID8gdm9pZCAwIDogX2EudmFsdWU7XG4gIH0pO1xuICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgIHNldFdhbGxldHNNb2RhbE9wZW4oZmFsc2UpO1xuICAgIHNldFNlbGVjdGVkV2FsbGV0SW5mbyhudWxsKTtcbiAgfTtcbiAgY29uc3Qgb25TZWxlY3RJbkRlc2t0b3BMaXN0ID0gKHdhbGxldEluZm8pID0+IHtcbiAgICBpZiAoaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQod2FsbGV0SW5mbykpIHtcbiAgICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0SW5mbyk7XG4gICAgICBjb25uZWN0b3IuY29ubmVjdCh7XG4gICAgICAgIGpzQnJpZGdlS2V5OiB3YWxsZXRJbmZvLmpzQnJpZGdlS2V5XG4gICAgICB9LCBhZGRpdGlvbmFsUmVxdWVzdCgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlzV2FsbGV0SW5mb1JlbW90ZSh3YWxsZXRJbmZvKSkge1xuICAgICAgc2V0TGFzdFNlbGVjdGVkV2FsbGV0SW5mbyhfX3NwcmVhZFByb3BzKF9fc3ByZWFkVmFsdWVzKHt9LCB3YWxsZXRJbmZvKSwge1xuICAgICAgICBvcGVuTWV0aG9kOiBcInFyY29kZVwiXG4gICAgICB9KSk7XG4gICAgICBzZXRTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0SW5mbyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG9wZW5MaW5rQmxhbmsod2FsbGV0SW5mby5hYm91dFVybCk7XG4gIH07XG4gIGNvbnN0IHVuc3Vic2NyaWJlID0gY29ubmVjdG9yLm9uU3RhdHVzQ2hhbmdlKCh3YWxsZXQpID0+IHtcbiAgICBpZiAod2FsbGV0KSB7XG4gICAgICBvbkNsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgb25DbGVhbnVwKHVuc3Vic2NyaWJlKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChTdHlsZWRNb2RhbCwge1xuICAgIGdldCBvcGVuZWQoKSB7XG4gICAgICByZXR1cm4gd2FsbGV0c01vZGFsT3BlbigpO1xuICAgIH0sXG4gICAgb25DbG9zZSxcbiAgICBcImRhdGEtdGMtd2FsbGV0cy1tb2RhbC1jb250YWluZXJcIjogXCJ0cnVlXCIsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nKCkgfHwgIXdhbGxldHNMaXN0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChIMVN0eWxlZCQxLCB7XG4gICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5sb2FkaW5nXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogXCJXYWxsZXRzIGxpc3QgaXMgbG9hZGluZ1wiXG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJDb250YWluZXJTdHlsZWQsIHtcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJJY29uLCB7XG4gICAgICAgICAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZU1lbW8oKCkgPT4gISEhYWRkaXRpb25hbFJlcXVlc3RMb2FkaW5nKCkpKCkgJiYgd2FsbGV0c0xpc3QoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBbY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiAhIWlzTW9iaWxlKCkpKCkgJiYgIXNlbGVjdGVkV2FsbGV0SW5mbygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChNb2JpbGVTZWxlY3RXYWxsZXRNb2RhbCwge1xuICAgICAgICAgICAgICAgIG9uU2VsZWN0OiBvblNlbGVjdEluRGVza3RvcExpc3QsXG4gICAgICAgICAgICAgICAgZ2V0IHdhbGxldHNMaXN0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldHNMaXN0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgYWRkaXRpb25hbFJlcXVlc3QoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiAhaXNNb2JpbGUoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU2hvdywge1xuICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuICFzZWxlY3RlZFdhbGxldEluZm8oKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IF9lbCQgPSBfdG1wbCQuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgaW5zZXJ0KF9lbCQsIGNyZWF0ZUNvbXBvbmVudChUYWJCYXJTdHlsZWQsIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHRhYjEoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUYWJUZXh0U3R5bGVkLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJ3YWxsZXRNb2RhbC5xckNvZGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnNvcjogXCJ1bnNldFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiUVIgQ29kZVwiXG4gICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCB0YWIyKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVGFiVGV4dFN0eWxlZCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwid2FsbGV0TW9kYWwud2FsbGV0c1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yOiBcInVuc2V0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbjogXCJXYWxsZXRzXCJcbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0IHNlbGVjdGVkVGFiSW5kZXgoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVGFiSW5kZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3RlZFRhYkluZGV4Q2hhbmdlOiBzZXRTZWxlY3RlZFRhYkluZGV4XG4gICAgICAgICAgICAgICAgICB9KSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICBpbnNlcnQoX2VsJCwgY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRUYWJJbmRleCgpID09PSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChVbml2ZXJzYWxRck1vZGFsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdhbGxldHNMaXN0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldHNMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgYWRkaXRpb25hbFJlcXVlc3QoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWRkaXRpb25hbFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wZW5XYWxsZXRGYWxsYmFjazogKCkgPT4gc2V0U2VsZWN0ZWRUYWJJbmRleCgxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KE1hdGNoLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgd2hlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkVGFiSW5kZXgoKSA9PT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRGVza3RvcFNlbGVjdFdhbGxldE1vZGFsLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IHdhbGxldHNMaXN0KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdhbGxldHNMaXN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNlbGVjdDogb25TZWxlY3RJbkRlc2t0b3BMaXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSksIG51bGwpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9lbCQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KFNob3csIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0ZWRXYWxsZXRJbmZvKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFFyQ29kZU1vZGFsLCB7XG4gICAgICAgICAgICAgICAgZ2V0IGFkZGl0aW9uYWxSZXF1ZXN0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZGl0aW9uYWxSZXF1ZXN0KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBnZXQgd2FsbGV0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGVkV2FsbGV0SW5mbygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25CYWNrQ2xpY2s6ICgpID0+IHNldFNlbGVjdGVkV2FsbGV0SW5mbyhudWxsKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KV07XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IEFjdGlvbk1vZGFsU3R5bGVkID0gc3R5bGVkLmRpdmBcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICBwYWRkaW5nLWJvdHRvbTogOHB4O1xuYDtcbmNvbnN0IEgxU3R5bGVkID0gc3R5bGVkKEgxKWBcbiAgICBtYXJnaW4tdG9wOiAxNnB4O1xuYDtcbmNvbnN0IFRleHRTdHlsZWQgPSBzdHlsZWQoVGV4dClgXG4gICAgZm9udC13ZWlnaHQ6IDUxMDtcbiAgICBmb250LXNpemU6IDE2cHg7XG4gICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgdGV4dC1hbGlnbjogY2VudGVyO1xuICAgIG1heC13aWR0aDogMjUwcHg7XG5cbiAgICBjb2xvcjogJHsocHJvcHMpID0+IHByb3BzLnRoZW1lLmNvbG9ycy50ZXh0LnNlY29uZGFyeX07XG5gO1xuY29uc3QgQnV0dG9uU3R5bGVkID0gc3R5bGVkKEJ1dHRvbilgXG4gICAgbWFyZ2luLXRvcDogMzJweDtcbmA7XG5jb25zdCBBY3Rpb25Nb2RhbCA9IChwcm9wcykgPT4ge1xuICBjb25zdCBkYXRhQXR0cnMgPSB1c2VEYXRhQXR0cmlidXRlcyhwcm9wcyk7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGxldCB1bml2ZXJzYWxMaW5rO1xuICBpZiAoKHRvbkNvbm5lY3RVSSA9PSBudWxsID8gdm9pZCAwIDogdG9uQ29ubmVjdFVJLndhbGxldCkgJiYgXCJ1bml2ZXJzYWxMaW5rXCIgaW4gdG9uQ29ubmVjdFVJLndhbGxldCAmJiB0b25Db25uZWN0VUkud2FsbGV0Lm9wZW5NZXRob2QgPT09IFwidW5pdmVyc2FsLWxpbmtcIikge1xuICAgIHVuaXZlcnNhbExpbmsgPSB0b25Db25uZWN0VUkud2FsbGV0LnVuaXZlcnNhbExpbms7XG4gIH1cbiAgY29uc3Qgb25PcGVuV2FsbGV0ID0gKCkgPT4ge1xuICAgIG9wZW5MaW5rKGFkZFJldHVyblN0cmF0ZWd5KHVuaXZlcnNhbExpbmssIFwiYmFja1wiKSk7XG4gIH07XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWN0aW9uTW9kYWxTdHlsZWQsIG1lcmdlUHJvcHMoZGF0YUF0dHJzLCB7XG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIFtjcmVhdGVNZW1vKCgpID0+IHByb3BzLmljb24pLCBjcmVhdGVDb21wb25lbnQoSDFTdHlsZWQsIHtcbiAgICAgICAgZ2V0IHRyYW5zbGF0aW9uS2V5KCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5oZWFkZXJUcmFuc2xhdGlvbktleTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IHRyYW5zbGF0aW9uVmFsdWVzKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5oZWFkZXJUcmFuc2xhdGlvblZhbHVlcztcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChUZXh0U3R5bGVkLCB7XG4gICAgICAgIGdldCB0cmFuc2xhdGlvbktleSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMudGV4dFRyYW5zbGF0aW9uS2V5O1xuICAgICAgICB9LFxuICAgICAgICBnZXQgdHJhbnNsYXRpb25WYWx1ZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BzLnRleHRUcmFuc2xhdGlvblZhbHVlcztcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5zaG93QnV0dG9uICE9PSBcIm9wZW4td2FsbGV0XCI7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KEJ1dHRvblN0eWxlZCwge1xuICAgICAgICAgICAgb25DbGljazogKCkgPT4gcHJvcHMub25DbG9zZSgpLFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zbGF0aW9uLCB7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25LZXk6IFwiY29tbW9uLmNsb3NlXCIsXG4gICAgICAgICAgICAgICAgY2hpbGRyZW46IFwiQ2xvc2VcIlxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgIHJldHVybiBwcm9wcy5zaG93QnV0dG9uID09PSBcIm9wZW4td2FsbGV0XCIgJiYgdW5pdmVyc2FsTGluaztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQnV0dG9uU3R5bGVkLCB7XG4gICAgICAgICAgICBvbkNsaWNrOiBvbk9wZW5XYWxsZXQsXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoVHJhbnNsYXRpb24sIHtcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvbktleTogXCJjb21tb24ub3BlbldhbGxldFwiLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBcIk9wZW4gd2FsbGV0XCJcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pXTtcbiAgICB9XG4gIH0pKTtcbn07XG5jb25zdCBDb25maXJtVHJhbnNhY3Rpb25Nb2RhbCA9IChwcm9wcykgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHRvbkNvbm5lY3RVSSA9IHVzZUNvbnRleHQoVG9uQ29ubmVjdFVpQ29udGV4dCk7XG4gIGNvbnN0IFt0Ml0gPSB1c2VJMThuKCk7XG4gIGNvbnN0IG5hbWUgPSAoKF9hID0gdG9uQ29ubmVjdFVJLndhbGxldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLm5hbWUpIHx8IHQyKFwiY29tbW9uLnlvdXJXYWxsZXRcIiwge30sIFwieW91ciB3YWxsZXRcIik7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWN0aW9uTW9kYWwsIHtcbiAgICBoZWFkZXJUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC5jb25maXJtVHJhbnNhY3Rpb24uaGVhZGVyXCIsXG4gICAgaGVhZGVyVHJhbnNsYXRpb25WYWx1ZXM6IHtcbiAgICAgIG5hbWVcbiAgICB9LFxuICAgIHRleHRUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC5jb25maXJtVHJhbnNhY3Rpb24udGV4dFwiLFxuICAgIGdldCBpY29uKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChMb2FkZXJJY29uLCB7XG4gICAgICAgIHNpemU6IFwibVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uQ2xvc2U6ICgpID0+IHByb3BzLm9uQ2xvc2UoKSxcbiAgICBzaG93QnV0dG9uOiBcIm9wZW4td2FsbGV0XCIsXG4gICAgXCJkYXRhLXRjLWNvbmZpcm0tbW9kYWxcIjogXCJ0cnVlXCJcbiAgfSk7XG59O1xuY29uc3QgVHJhbnNhY3Rpb25DYW5jZWxlZE1vZGFsID0gKHByb3BzKSA9PiB7XG4gIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWN0aW9uTW9kYWwsIHtcbiAgICBoZWFkZXJUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC50cmFuc2FjdGlvbkNhbmNlbGVkLmhlYWRlclwiLFxuICAgIHRleHRUcmFuc2xhdGlvbktleTogXCJhY3Rpb25Nb2RhbC50cmFuc2FjdGlvbkNhbmNlbGVkLnRleHRcIixcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoRXJyb3JJY29uLCB7XG4gICAgICAgIHNpemU6IFwibVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIG9uQ2xvc2U6ICgpID0+IHByb3BzLm9uQ2xvc2UoKSxcbiAgICBcImRhdGEtdGMtdHJhbnNhY3Rpb24tY2FuY2VsZWQtbW9kYWxcIjogXCJ0cnVlXCJcbiAgfSk7XG59O1xuY29uc3QgVHJhbnNhY3Rpb25TZW50TW9kYWwgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChBY3Rpb25Nb2RhbCwge1xuICAgIGhlYWRlclRyYW5zbGF0aW9uS2V5OiBcImFjdGlvbk1vZGFsLnRyYW5zYWN0aW9uU2VudC5oZWFkZXJcIixcbiAgICB0ZXh0VHJhbnNsYXRpb25LZXk6IFwiYWN0aW9uTW9kYWwudHJhbnNhY3Rpb25TZW50LnRleHRcIixcbiAgICBnZXQgaWNvbigpIHtcbiAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoU3VjY2Vzc0ljb24sIHtcbiAgICAgICAgc2l6ZTogXCJtXCJcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgb25DbG9zZTogKCkgPT4gcHJvcHMub25DbG9zZSgpLFxuICAgIFwiZGF0YS10Yy10cmFuc2FjdGlvbi1zZW50LW1vZGFsXCI6IFwidHJ1ZVwiXG4gIH0pO1xufTtcbmNvbnN0IEFjdGlvbnNNb2RhbCA9ICgpID0+IHtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChNb2RhbCwge1xuICAgIGdldCBvcGVuZWQoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gY3JlYXRlTWVtbygoKSA9PiBhY3Rpb24oKSAhPT0gbnVsbCkoKSAmJiAoKF9hID0gYWN0aW9uKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5vcGVuTW9kYWwpID09PSB0cnVlO1xuICAgIH0sXG4gICAgb25DbG9zZTogKCkgPT4gc2V0QWN0aW9uKG51bGwpLFxuICAgIFwiZGF0YS10Yy1hY3Rpb25zLW1vZGFsLWNvbnRhaW5lclwiOiBcInRydWVcIixcbiAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFN3aXRjaCwge1xuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIFtjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKCkubmFtZSA9PT0gXCJ0cmFuc2FjdGlvbi1zZW50XCI7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFRyYW5zYWN0aW9uU2VudE1vZGFsLCB7XG4gICAgICAgICAgICAgICAgb25DbG9zZTogKCkgPT4gc2V0QWN0aW9uKG51bGwpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLCBjcmVhdGVDb21wb25lbnQoTWF0Y2gsIHtcbiAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uKCkubmFtZSA9PT0gXCJ0cmFuc2FjdGlvbi1jYW5jZWxlZFwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUcmFuc2FjdGlvbkNhbmNlbGVkTW9kYWwsIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBzZXRBY3Rpb24obnVsbClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSksIGNyZWF0ZUNvbXBvbmVudChNYXRjaCwge1xuICAgICAgICAgICAgZ2V0IHdoZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhY3Rpb24oKS5uYW1lID09PSBcImNvbmZpcm0tdHJhbnNhY3Rpb25cIjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQ29uZmlybVRyYW5zYWN0aW9uTW9kYWwsIHtcbiAgICAgICAgICAgICAgICBvbkNsb3NlOiAoKSA9PiBzZXRBY3Rpb24obnVsbClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IEFwcCA9IChwcm9wcykgPT4ge1xuICBjb25zdCB0cmFuc2xhdGlvbnMgPSBjcmVhdGVJMThuQ29udGV4dChpMThuRGljdGlvbmFyeSwgYXBwU3RhdGUubGFuZ3VhZ2UpO1xuICBkZWZpbmVTdHlsZXNSb290KCk7XG4gIGZpeE1vYmlsZVNhZmFyaUFjdGl2ZVRyYW5zaXRpb24oKTtcbiAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChJMThuQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiB0cmFuc2xhdGlvbnMsXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChUb25Db25uZWN0VWlDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcHMudG9uQ29ubmVjdFVJO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUNvbXBvbmVudChDb25uZWN0b3JDb250ZXh0LlByb3ZpZGVyLCB7XG4gICAgICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcHBTdGF0ZS5jb25uZWN0b3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChHbG9iYWxTdHlsZXMsIHt9KSwgY3JlYXRlQ29tcG9uZW50KFRoZW1lUHJvdmlkZXIsIHtcbiAgICAgICAgICAgICAgICB0aGVtZTogdGhlbWVTdGF0ZSxcbiAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChTaG93LCB7XG4gICAgICAgICAgICAgICAgICAgIGdldCB3aGVuKCkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcHBTdGF0ZS5idXR0b25Sb290SWQ7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlQ29tcG9uZW50KFBvcnRhbCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IG1vdW50KCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoYXBwU3RhdGUuYnV0dG9uUm9vdElkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgY2hpbGRyZW4oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVDb21wb25lbnQoQWNjb3VudEJ1dHRvbiwge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KSwgY3JlYXRlQ29tcG9uZW50KER5bmFtaWMsIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50OiBnbG9iYWxTdHlsZXNUYWcsXG4gICAgICAgICAgICAgICAgICAgIGdldCBjaGlsZHJlbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2NyZWF0ZUNvbXBvbmVudChXYWxsZXRzTW9kYWwsIHt9KSwgY3JlYXRlQ29tcG9uZW50KEFjdGlvbnNNb2RhbCwge30pXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcbmNvbnN0IHdpZGdldENvbnRyb2xsZXIgPSB7XG4gIG9wZW5XYWxsZXRzTW9kYWw6ICgpID0+IHZvaWQgc2V0VGltZW91dCgoKSA9PiBzZXRXYWxsZXRzTW9kYWxPcGVuKHRydWUpKSxcbiAgY2xvc2VXYWxsZXRzTW9kYWw6ICgpID0+IHZvaWQgc2V0VGltZW91dCgoKSA9PiBzZXRXYWxsZXRzTW9kYWxPcGVuKGZhbHNlKSksXG4gIHNldEFjdGlvbjogKGFjdGlvbjIpID0+IHZvaWQgc2V0VGltZW91dCgoKSA9PiBzZXRBY3Rpb24oYWN0aW9uMikpLFxuICBjbGVhckFjdGlvbjogKCkgPT4gdm9pZCBzZXRUaW1lb3V0KCgpID0+IHNldEFjdGlvbihudWxsKSksXG4gIGdldFNlbGVjdGVkV2FsbGV0SW5mbzogKCkgPT4gbGFzdFNlbGVjdGVkV2FsbGV0SW5mbygpLFxuICByZW5kZXJBcHA6IChyb290LCB0b25Db25uZWN0VUkpID0+IHJlbmRlcigoKSA9PiBjcmVhdGVDb21wb25lbnQoQXBwLCB7XG4gICAgdG9uQ29ubmVjdFVJXG4gIH0pLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChyb290KSlcbn07XG5jbGFzcyBXYWxsZXRJbmZvU3RvcmFnZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJsb2NhbFN0b3JhZ2VcIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0b3JhZ2VLZXlcIiwgXCJ0b24tY29ubmVjdC11aV93YWxsZXQtaW5mb1wiKTtcbiAgICBjaGVja0xvY2FsU3RvcmFnZUV4aXN0cygpO1xuICAgIHRoaXMubG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlO1xuICB9XG4gIHNldFdhbGxldEluZm8od2FsbGV0SW5mbykge1xuICAgIHRoaXMubG9jYWxTdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yYWdlS2V5LCBKU09OLnN0cmluZ2lmeSh3YWxsZXRJbmZvKSk7XG4gIH1cbiAgZ2V0V2FsbGV0SW5mbygpIHtcbiAgICBjb25zdCB3YWxsZXRJbmZvU3RyaW5nID0gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICAgIGlmICghd2FsbGV0SW5mb1N0cmluZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBKU09OLnBhcnNlKHdhbGxldEluZm9TdHJpbmcpO1xuICB9XG4gIHJlbW92ZVdhbGxldEluZm8oKSB7XG4gICAgdGhpcy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0aGlzLnN0b3JhZ2VLZXkpO1xuICB9XG59XG5jbGFzcyBQcmVmZXJyZWRXYWxsZXRTdG9yYWdlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImxvY2FsU3RvcmFnZVwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RvcmFnZUtleVwiLCBcInRvbi1jb25uZWN0LXVpX3ByZWZlcnJlZC13YWxsZXRcIik7XG4gICAgY2hlY2tMb2NhbFN0b3JhZ2VFeGlzdHMoKTtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZTtcbiAgfVxuICBzZXRQcmVmZXJyZWRXYWxsZXROYW1lKG5hbWUpIHtcbiAgICB0aGlzLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmFnZUtleSwgbmFtZSk7XG4gIH1cbiAgZ2V0UHJlZmVycmVkV2FsbGV0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JhZ2VLZXkpIHx8IHZvaWQgMDtcbiAgfVxufVxuY2xhc3MgVG9uQ29ubmVjdFVJIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJ3YWxsZXRJbmZvU3RvcmFnZVwiLCBuZXcgV2FsbGV0SW5mb1N0b3JhZ2UoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInByZWZlcnJlZFdhbGxldFN0b3JhZ2VcIiwgbmV3IFByZWZlcnJlZFdhbGxldFN0b3JhZ2UoKSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcImNvbm5lY3RvclwiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwid2FsbGV0SW5mb1wiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3lzdGVtVGhlbWVDaGFuZ2VVbnN1YnNjcmliZVwiLCBudWxsKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYWN0aW9uc0NvbmZpZ3VyYXRpb25cIik7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcIndhbGxldHNMaXN0XCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFja1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiY29ubmVjdGlvblJlc3RvcmVkXCIsIFByb21pc2UucmVzb2x2ZShmYWxzZSkpO1xuICAgIGlmIChvcHRpb25zICYmIFwiY29ubmVjdG9yXCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmNvbm5lY3Rvcikge1xuICAgICAgdGhpcy5jb25uZWN0b3IgPSBvcHRpb25zLmNvbm5lY3RvcjtcbiAgICB9IGVsc2UgaWYgKG9wdGlvbnMgJiYgXCJtYW5pZmVzdFVybFwiIGluIG9wdGlvbnMgJiYgb3B0aW9ucy5tYW5pZmVzdFVybCkge1xuICAgICAgdGhpcy5jb25uZWN0b3IgPSBuZXcgVG9uQ29ubmVjdCh7IG1hbmlmZXN0VXJsOiBvcHRpb25zLm1hbmlmZXN0VXJsIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXG4gICAgICAgIFwiWW91IGhhdmUgdG8gc3BlY2lmeSBhIGBtYW5pZmVzdFVybGAgb3IgYSBgY29ubmVjdG9yYCBpbiB0aGUgb3B0aW9ucy5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy53YWxsZXRzTGlzdCA9IHRoaXMuZ2V0V2FsbGV0cygpO1xuICAgIHRoaXMud2FsbGV0c0xpc3QudGhlbigobGlzdCkgPT4gcHJlbG9hZEltYWdlcyh1bmlxKGxpc3QubWFwKChpdGVtKSA9PiBpdGVtLmltYWdlVXJsKSkpKTtcbiAgICBjb25zdCByb290SWQgPSB0aGlzLm5vcm1hbGl6ZVdpZGdldFJvb3Qob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy53aWRnZXRSb290SWQpO1xuICAgIHRoaXMuc3Vic2NyaWJlVG9XYWxsZXRDaGFuZ2UoKTtcbiAgICBpZiAoKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucmVzdG9yZUNvbm5lY3Rpb24pICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5jb25uZWN0aW9uUmVzdG9yZWQgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rvci5yZXN0b3JlQ29ubmVjdGlvbigpO1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdG9yLmNvbm5lY3RlZCkge1xuICAgICAgICAgIHRoaXMud2FsbGV0SW5mb1N0b3JhZ2UucmVtb3ZlV2FsbGV0SW5mbygpO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUodGhpcy5jb25uZWN0b3IuY29ubmVjdGVkKTtcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgdGhpcy51aU9wdGlvbnMgPSBtZXJnZU9wdGlvbnMob3B0aW9ucywgeyB1aVByZWZlcmVuY2VzOiB7IHRoZW1lOiBcIlNZU1RFTVwiIH0gfSk7XG4gICAgY29uc3QgcHJlZmVycmVkV2FsbGV0TmFtZSA9IHRoaXMucHJlZmVycmVkV2FsbGV0U3RvcmFnZS5nZXRQcmVmZXJyZWRXYWxsZXROYW1lKCk7XG4gICAgc2V0QXBwU3RhdGUoe1xuICAgICAgY29ubmVjdG9yOiB0aGlzLmNvbm5lY3RvcixcbiAgICAgIHByZWZlcnJlZFdhbGxldE5hbWVcbiAgICB9KTtcbiAgICB3aWRnZXRDb250cm9sbGVyLnJlbmRlckFwcChyb290SWQsIHRoaXMpO1xuICB9XG4gIHN0YXRpYyBnZXRXYWxsZXRzKCkge1xuICAgIHJldHVybiBUb25Db25uZWN0LmdldFdhbGxldHMoKTtcbiAgfVxuICBnZXQgY29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5jb25uZWN0ZWQ7XG4gIH1cbiAgZ2V0IGFjY291bnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLmFjY291bnQ7XG4gIH1cbiAgZ2V0IHdhbGxldCgpIHtcbiAgICBpZiAoIXRoaXMuY29ubmVjdG9yLndhbGxldCB8fCAhdGhpcy53YWxsZXRJbmZvKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB0aGlzLmNvbm5lY3Rvci53YWxsZXQpLCB0aGlzLndhbGxldEluZm8pO1xuICB9XG4gIHNldCB1aU9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgdGhpcy5jaGVja0J1dHRvblJvb3RFeGlzdChvcHRpb25zLmJ1dHRvblJvb3RJZCk7XG4gICAgdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbiA9IG9wdGlvbnMuYWN0aW9uc0NvbmZpZ3VyYXRpb247XG4gICAgaWYgKChfYSA9IG9wdGlvbnMudWlQcmVmZXJlbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRoZW1lKSB7XG4gICAgICBpZiAoKChfYiA9IG9wdGlvbnMudWlQcmVmZXJlbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnRoZW1lKSAhPT0gXCJTWVNURU1cIikge1xuICAgICAgICAoX2MgPSB0aGlzLnN5c3RlbVRoZW1lQ2hhbmdlVW5zdWJzY3JpYmUpID09IG51bGwgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMpO1xuICAgICAgICBzZXRUaGVtZShvcHRpb25zLnVpUHJlZmVyZW5jZXMudGhlbWUsIG9wdGlvbnMudWlQcmVmZXJlbmNlcy5jb2xvcnNTZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGhlbWUoZ2V0U3lzdGVtVGhlbWUoKSwgb3B0aW9ucy51aVByZWZlcmVuY2VzLmNvbG9yc1NldCk7XG4gICAgICAgIGlmICghdGhpcy5zeXN0ZW1UaGVtZUNoYW5nZVVuc3Vic2NyaWJlKSB7XG4gICAgICAgICAgdGhpcy5zeXN0ZW1UaGVtZUNoYW5nZVVuc3Vic2NyaWJlID0gc3Vic2NyaWJlVG9UaGVtZUNoYW5nZShzZXRUaGVtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKChfZCA9IG9wdGlvbnMudWlQcmVmZXJlbmNlcykgPT0gbnVsbCA/IHZvaWQgMCA6IF9kLmNvbG9yc1NldCkge1xuICAgICAgICBzZXRDb2xvcnMob3B0aW9ucy51aVByZWZlcmVuY2VzLmNvbG9yc1NldCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoX2UgPSBvcHRpb25zLnVpUHJlZmVyZW5jZXMpID09IG51bGwgPyB2b2lkIDAgOiBfZS5ib3JkZXJSYWRpdXMpIHtcbiAgICAgIHNldEJvcmRlclJhZGl1cyhvcHRpb25zLnVpUHJlZmVyZW5jZXMuYm9yZGVyUmFkaXVzKTtcbiAgICB9XG4gICAgc2V0QXBwU3RhdGUoKHN0YXRlKSA9PiB7XG4gICAgICB2YXIgX2EyO1xuICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VPcHRpb25zKFxuICAgICAgICBfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgb3B0aW9ucy5sYW5ndWFnZSAmJiB7IGxhbmd1YWdlOiBvcHRpb25zLmxhbmd1YWdlIH0pLCAhISgoX2EyID0gb3B0aW9ucy5hY3Rpb25zQ29uZmlndXJhdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMi5yZXR1cm5TdHJhdGVneSkgJiYge1xuICAgICAgICAgIHJldHVyblN0cmF0ZWd5OiBvcHRpb25zLmFjdGlvbnNDb25maWd1cmF0aW9uLnJldHVyblN0cmF0ZWd5XG4gICAgICAgIH0pLCAhIW9wdGlvbnMud2FsbGV0c0xpc3RDb25maWd1cmF0aW9uICYmIHtcbiAgICAgICAgICB3YWxsZXRzTGlzdENvbmZpZ3VyYXRpb246IG9wdGlvbnMud2FsbGV0c0xpc3RDb25maWd1cmF0aW9uXG4gICAgICAgIH0pLFxuICAgICAgICB1bndyYXAoc3RhdGUpXG4gICAgICApO1xuICAgICAgaWYgKG9wdGlvbnMuYnV0dG9uUm9vdElkICE9PSB2b2lkIDApIHtcbiAgICAgICAgbWVyZ2VkLmJ1dHRvblJvb3RJZCA9IG9wdGlvbnMuYnV0dG9uUm9vdElkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9KTtcbiAgfVxuICBzZXRDb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMoY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzKSB7XG4gICAgdmFyIF9hO1xuICAgIHNldEFwcFN0YXRlKHsgY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzIH0pO1xuICAgIGlmICgoY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMuc3RhdGUpID09PSBcInJlYWR5XCIgfHwgIWNvbm5lY3RSZXF1ZXN0UGFyYW1ldGVycykge1xuICAgICAgKF9hID0gdGhpcy5jb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjaykgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzID09IG51bGwgPyB2b2lkIDAgOiBjb25uZWN0UmVxdWVzdFBhcmFtZXRlcnMudmFsdWUpO1xuICAgIH1cbiAgfVxuICBnZXRXYWxsZXRzKCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb25uZWN0b3IuZ2V0V2FsbGV0cygpO1xuICAgIH0pO1xuICB9XG4gIG9uU3RhdHVzQ2hhbmdlKGNhbGxiYWNrLCBlcnJvcnNIYW5kbGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuY29ubmVjdG9yLm9uU3RhdHVzQ2hhbmdlKCh3YWxsZXQpID0+IF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh3YWxsZXQpIHtcbiAgICAgICAgY29uc3QgbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIgPSB5aWVsZCB0aGlzLmdldFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXQpO1xuICAgICAgICBjYWxsYmFjayhfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgd2FsbGV0KSwgbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIgfHwgdGhpcy53YWxsZXRJbmZvU3RvcmFnZS5nZXRXYWxsZXRJbmZvKCkpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrKHdhbGxldCk7XG4gICAgICB9XG4gICAgfSksIGVycm9yc0hhbmRsZXIpO1xuICB9XG4gIGNvbm5lY3RXYWxsZXQoKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHdhbGxldHNMaXN0ID0geWllbGQgdGhpcy5nZXRXYWxsZXRzKCk7XG4gICAgICBjb25zdCBlbWJlZGRlZFdhbGxldCA9IHdhbGxldHNMaXN0LmZpbmQoaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQpO1xuICAgICAgaWYgKGVtYmVkZGVkV2FsbGV0KSB7XG4gICAgICAgIGNvbnN0IGNvbm5lY3QgPSAocGFyYW1ldGVycykgPT4ge1xuICAgICAgICAgIHNldExhc3RTZWxlY3RlZFdhbGxldEluZm8oZW1iZWRkZWRXYWxsZXQpO1xuICAgICAgICAgIHRoaXMuY29ubmVjdG9yLmNvbm5lY3QoeyBqc0JyaWRnZUtleTogZW1iZWRkZWRXYWxsZXQuanNCcmlkZ2VLZXkgfSwgcGFyYW1ldGVycyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFkZGl0aW9uYWxSZXF1ZXN0ID0gYXBwU3RhdGUuY29ubmVjdFJlcXVlc3RQYXJhbWV0ZXJzO1xuICAgICAgICBpZiAoKGFkZGl0aW9uYWxSZXF1ZXN0ID09IG51bGwgPyB2b2lkIDAgOiBhZGRpdGlvbmFsUmVxdWVzdC5zdGF0ZSkgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgdGhpcy5jb25uZWN0UmVxdWVzdFBhcmFtZXRlcnNDYWxsYmFjayA9IGNvbm5lY3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29ubmVjdChhZGRpdGlvbmFsUmVxdWVzdCA9PSBudWxsID8gdm9pZCAwIDogYWRkaXRpb25hbFJlcXVlc3QudmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aWRnZXRDb250cm9sbGVyLm9wZW5XYWxsZXRzTW9kYWwoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5jb25uZWN0b3Iub25TdGF0dXNDaGFuZ2UoKHdhbGxldCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgaWYgKHdhbGxldCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIgPSB5aWVsZCB0aGlzLmdldFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXQpO1xuICAgICAgICAgICAgcmVzb2x2ZShfX3NwcmVhZFZhbHVlcyhfX3NwcmVhZFZhbHVlcyh7fSwgd2FsbGV0KSwgbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIgfHwgdGhpcy53YWxsZXRJbmZvU3RvcmFnZS5nZXRXYWxsZXRJbmZvKCkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBUb25Db25uZWN0VUlFcnJvcihcIldhbGxldCB3YXMgbm90IGNvbm5lY3RlZFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgd2lkZ2V0Q29udHJvbGxlci5jbGVhckFjdGlvbigpO1xuICAgIHRoaXMud2FsbGV0SW5mb1N0b3JhZ2UucmVtb3ZlV2FsbGV0SW5mbygpO1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gIH1cbiAgc2VuZFRyYW5zYWN0aW9uKHR4LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQgfHwgIXRoaXMud2FsbGV0SW5mbykge1xuICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoXCJDb25uZWN0IHdhbGxldCB0byBzZW5kIGEgdHJhbnNhY3Rpb24uXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgeyBub3RpZmljYXRpb25zOiBub3RpZmljYXRpb25zMiwgbW9kYWxzLCByZXR1cm5TdHJhdGVneSwgc2tpcFJlZGlyZWN0VG9XYWxsZXQgfSA9IHRoaXMuZ2V0TW9kYWxzQW5kTm90aWZpY2F0aW9uc0NvbmZpZ3VyYXRpb24ob3B0aW9ucyk7XG4gICAgICBjb25zdCB1c2VyT1NJc0lvcyA9IGdldFVzZXJBZ2VudCgpLm9zID09PSBcImlvc1wiO1xuICAgICAgY29uc3Qgc2hvdWxkU2tpcFJlZGlyZWN0VG9XYWxsZXQgPSBza2lwUmVkaXJlY3RUb1dhbGxldCA9PT0gXCJpb3NcIiAmJiB1c2VyT1NJc0lvcyB8fCBza2lwUmVkaXJlY3RUb1dhbGxldCA9PT0gXCJhbHdheXNcIjtcbiAgICAgIGlmIChcInVuaXZlcnNhbExpbmtcIiBpbiB0aGlzLndhbGxldEluZm8gJiYgdGhpcy53YWxsZXRJbmZvLm9wZW5NZXRob2QgPT09IFwidW5pdmVyc2FsLWxpbmtcIiAmJiAhc2hvdWxkU2tpcFJlZGlyZWN0VG9XYWxsZXQpIHtcbiAgICAgICAgb3BlbkxpbmsoYWRkUmV0dXJuU3RyYXRlZ3kodGhpcy53YWxsZXRJbmZvLnVuaXZlcnNhbExpbmssIHJldHVyblN0cmF0ZWd5KSk7XG4gICAgICB9XG4gICAgICB3aWRnZXRDb250cm9sbGVyLnNldEFjdGlvbih7XG4gICAgICAgIG5hbWU6IFwiY29uZmlybS10cmFuc2FjdGlvblwiLFxuICAgICAgICBzaG93Tm90aWZpY2F0aW9uOiBub3RpZmljYXRpb25zMi5pbmNsdWRlcyhcImJlZm9yZVwiKSxcbiAgICAgICAgb3Blbk1vZGFsOiBtb2RhbHMuaW5jbHVkZXMoXCJiZWZvcmVcIilcbiAgICAgIH0pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5jb25uZWN0b3Iuc2VuZFRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgd2lkZ2V0Q29udHJvbGxlci5zZXRBY3Rpb24oe1xuICAgICAgICAgIG5hbWU6IFwidHJhbnNhY3Rpb24tc2VudFwiLFxuICAgICAgICAgIHNob3dOb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbnMyLmluY2x1ZGVzKFwic3VjY2Vzc1wiKSxcbiAgICAgICAgICBvcGVuTW9kYWw6IG1vZGFscy5pbmNsdWRlcyhcInN1Y2Nlc3NcIilcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlMikge1xuICAgICAgICB3aWRnZXRDb250cm9sbGVyLnNldEFjdGlvbih7XG4gICAgICAgICAgbmFtZTogXCJ0cmFuc2FjdGlvbi1jYW5jZWxlZFwiLFxuICAgICAgICAgIHNob3dOb3RpZmljYXRpb246IG5vdGlmaWNhdGlvbnMyLmluY2x1ZGVzKFwiZXJyb3JcIiksXG4gICAgICAgICAgb3Blbk1vZGFsOiBtb2RhbHMuaW5jbHVkZXMoXCJlcnJvclwiKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGUyIGluc3RhbmNlb2YgVG9uQ29ubmVjdEVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgZTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihlMik7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKFwiVW5oYW5kbGVkIGVycm9yOlwiICsgZTIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3Vic2NyaWJlVG9XYWxsZXRDaGFuZ2UoKSB7XG4gICAgdGhpcy5jb25uZWN0b3Iub25TdGF0dXNDaGFuZ2UoKHdhbGxldCkgPT4gX19hc3luYyh0aGlzLCBudWxsLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKHdhbGxldCkge1xuICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZVdhbGxldEluZm8od2FsbGV0KTtcbiAgICAgICAgdGhpcy5zZXRQcmVmZXJyZWRXYWxsZXROYW1lKCgoX2EgPSB0aGlzLndhbGxldEluZm8pID09IG51bGwgPyB2b2lkIDAgOiBfYS5hcHBOYW1lKSB8fCB3YWxsZXQuZGV2aWNlLmFwcE5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YWxsZXRJbmZvU3RvcmFnZS5yZW1vdmVXYWxsZXRJbmZvKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIHNldFByZWZlcnJlZFdhbGxldE5hbWUodmFsdWUpIHtcbiAgICB0aGlzLnByZWZlcnJlZFdhbGxldFN0b3JhZ2Uuc2V0UHJlZmVycmVkV2FsbGV0TmFtZSh2YWx1ZSk7XG4gICAgc2V0QXBwU3RhdGUoeyBwcmVmZXJyZWRXYWxsZXROYW1lOiB2YWx1ZSB9KTtcbiAgfVxuICBnZXRTZWxlY3RlZFdhbGxldEluZm8od2FsbGV0KSB7XG4gICAgcmV0dXJuIF9fYXN5bmModGhpcywgbnVsbCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGxldCBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvMiA9IHdpZGdldENvbnRyb2xsZXIuZ2V0U2VsZWN0ZWRXYWxsZXRJbmZvKCk7XG4gICAgICBpZiAoIWxhc3RTZWxlY3RlZFdhbGxldEluZm8yKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbGV0IGZ1bGxMYXN0U2VsZWN0ZWRXYWxsZXRJbmZvO1xuICAgICAgaWYgKCEoXCJuYW1lXCIgaW4gbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIpKSB7XG4gICAgICAgIGNvbnN0IHdhbGxldHNMaXN0ID0gYXBwbHlXYWxsZXRzTGlzdENvbmZpZ3VyYXRpb24oXG4gICAgICAgICAgeWllbGQgdGhpcy53YWxsZXRzTGlzdCxcbiAgICAgICAgICBhcHBTdGF0ZS53YWxsZXRzTGlzdENvbmZpZ3VyYXRpb25cbiAgICAgICAgKTtcbiAgICAgICAgY29uc3Qgd2FsbGV0SW5mbyA9IHdhbGxldHNMaXN0LmZpbmQoKGl0ZW0pID0+IGVxV2FsbGV0TmFtZShpdGVtLCB3YWxsZXQuZGV2aWNlLmFwcE5hbWUpKTtcbiAgICAgICAgaWYgKCF3YWxsZXRJbmZvKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RVSUVycm9yKFxuICAgICAgICAgICAgYENhbm5vdCBmaW5kIFdhbGxldEluZm8gZm9yIHRoZSAnJHt3YWxsZXQuZGV2aWNlLmFwcE5hbWV9JyB3YWxsZXRgXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBmdWxsTGFzdFNlbGVjdGVkV2FsbGV0SW5mbyA9IF9fc3ByZWFkVmFsdWVzKF9fc3ByZWFkVmFsdWVzKHt9LCB3YWxsZXRJbmZvKSwgbGFzdFNlbGVjdGVkV2FsbGV0SW5mbzIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnVsbExhc3RTZWxlY3RlZFdhbGxldEluZm8gPSBsYXN0U2VsZWN0ZWRXYWxsZXRJbmZvMjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdWxsTGFzdFNlbGVjdGVkV2FsbGV0SW5mbztcbiAgICB9KTtcbiAgfVxuICB1cGRhdGVXYWxsZXRJbmZvKHdhbGxldCkge1xuICAgIHJldHVybiBfX2FzeW5jKHRoaXMsIG51bGwsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzZWxlY3RlZFdhbGxldEluZm8gPSB5aWVsZCB0aGlzLmdldFNlbGVjdGVkV2FsbGV0SW5mbyh3YWxsZXQpO1xuICAgICAgaWYgKHNlbGVjdGVkV2FsbGV0SW5mbykge1xuICAgICAgICB0aGlzLndhbGxldEluZm8gPSBzZWxlY3RlZFdhbGxldEluZm87XG4gICAgICAgIHRoaXMud2FsbGV0SW5mb1N0b3JhZ2Uuc2V0V2FsbGV0SW5mbyhzZWxlY3RlZFdhbGxldEluZm8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53YWxsZXRJbmZvID0gdGhpcy53YWxsZXRJbmZvU3RvcmFnZS5nZXRXYWxsZXRJbmZvKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbm9ybWFsaXplV2lkZ2V0Um9vdChyb290SWQpIHtcbiAgICBpZiAoIXJvb3RJZCB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocm9vdElkKSkge1xuICAgICAgcm9vdElkID0gXCJ0Yy13aWRnZXQtcm9vdFwiO1xuICAgICAgY29uc3Qgcm9vdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcm9vdEVsZW1lbnQuaWQgPSByb290SWQ7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHJvb3RFbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RJZDtcbiAgfVxuICBjaGVja0J1dHRvblJvb3RFeGlzdChidXR0b25Sb290SWQpIHtcbiAgICBpZiAoYnV0dG9uUm9vdElkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFkb2N1bWVudC5nZXRFbGVtZW50QnlJZChidXR0b25Sb290SWQpKSB7XG4gICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdFVJRXJyb3IoYCR7YnV0dG9uUm9vdElkfSBlbGVtZW50IG5vdCBmb3VuZCBpbiB0aGUgZG9jdW1lbnQuYCk7XG4gICAgfVxuICB9XG4gIGdldE1vZGFsc0FuZE5vdGlmaWNhdGlvbnNDb25maWd1cmF0aW9uKG9wdGlvbnMpIHtcbiAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgIGNvbnN0IGFsbEFjdGlvbnMgPSBbXG4gICAgICBcImJlZm9yZVwiLFxuICAgICAgXCJzdWNjZXNzXCIsXG4gICAgICBcImVycm9yXCJcbiAgICBdO1xuICAgIGxldCBub3RpZmljYXRpb25zMiA9IGFsbEFjdGlvbnM7XG4gICAgaWYgKCgoX2EgPSB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uKSA9PSBudWxsID8gdm9pZCAwIDogX2Eubm90aWZpY2F0aW9ucykgJiYgKChfYiA9IHRoaXMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYi5ub3RpZmljYXRpb25zKSAhPT0gXCJhbGxcIikge1xuICAgICAgbm90aWZpY2F0aW9uczIgPSB0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uLm5vdGlmaWNhdGlvbnM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm5vdGlmaWNhdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLm5vdGlmaWNhdGlvbnMgPT09IFwiYWxsXCIpIHtcbiAgICAgICAgbm90aWZpY2F0aW9uczIgPSBhbGxBY3Rpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm90aWZpY2F0aW9uczIgPSBvcHRpb25zLm5vdGlmaWNhdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBtb2RhbHMgPSBbXCJiZWZvcmVcIl07XG4gICAgaWYgKChfYyA9IHRoaXMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfYy5tb2RhbHMpIHtcbiAgICAgIGlmICh0aGlzLmFjdGlvbnNDb25maWd1cmF0aW9uLm1vZGFscyA9PT0gXCJhbGxcIikge1xuICAgICAgICBtb2RhbHMgPSBhbGxBY3Rpb25zO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9kYWxzID0gdGhpcy5hY3Rpb25zQ29uZmlndXJhdGlvbi5tb2RhbHM7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLm1vZGFscykge1xuICAgICAgaWYgKG9wdGlvbnMubW9kYWxzID09PSBcImFsbFwiKSB7XG4gICAgICAgIG1vZGFscyA9IGFsbEFjdGlvbnM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtb2RhbHMgPSBvcHRpb25zLm1vZGFscztcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcmV0dXJuU3RyYXRlZ3kgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5yZXR1cm5TdHJhdGVneSkgfHwgKChfZCA9IHRoaXMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZC5yZXR1cm5TdHJhdGVneSkgfHwgXCJiYWNrXCI7XG4gICAgY29uc3Qgc2tpcFJlZGlyZWN0VG9XYWxsZXQgPSAob3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5za2lwUmVkaXJlY3RUb1dhbGxldCkgfHwgKChfZSA9IHRoaXMuYWN0aW9uc0NvbmZpZ3VyYXRpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZS5za2lwUmVkaXJlY3RUb1dhbGxldCkgfHwgXCJpb3NcIjtcbiAgICByZXR1cm4ge1xuICAgICAgbm90aWZpY2F0aW9uczogbm90aWZpY2F0aW9uczIsXG4gICAgICBtb2RhbHMsXG4gICAgICByZXR1cm5TdHJhdGVneSxcbiAgICAgIHNraXBSZWRpcmVjdFRvV2FsbGV0XG4gICAgfTtcbiAgfVxufVxuZXhwb3J0IHtcbiAgVEhFTUUsXG4gIFRvbkNvbm5lY3RVSSxcbiAgVG9uQ29ubmVjdFVJRXJyb3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tonconnect/ui/lib/index.js\n");

/***/ }),

/***/ "./node_modules/@tonconnect/ui/node_modules/@tonconnect/isomorphic-eventsource/index.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@tonconnect/ui/node_modules/@tonconnect/isomorphic-eventsource/index.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var eventsource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventsource */ \"eventsource\");\n\n\nif (!global.EventSource) {\n    global.EventSource = eventsource__WEBPACK_IMPORTED_MODULE_0__;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWkvbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L2lzb21vcnBoaWMtZXZlbnRzb3VyY2UvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7O0FBQXNDOztBQUV0QztBQUNBLHlCQUF5Qix3Q0FBVztBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL21lbWVpbmRleC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC91aS9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvaXNvbW9ycGhpYy1ldmVudHNvdXJjZS9pbmRleC5tanM/MjY4NSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgRXZlbnRTb3VyY2UgZnJvbSAnZXZlbnRzb3VyY2UnO1xuXG5pZiAoIWdsb2JhbC5FdmVudFNvdXJjZSkge1xuICAgIGdsb2JhbC5FdmVudFNvdXJjZSA9IEV2ZW50U291cmNlO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@tonconnect/ui/node_modules/@tonconnect/isomorphic-eventsource/index.mjs\n");

/***/ }),

/***/ "./node_modules/@tonconnect/ui/node_modules/@tonconnect/isomorphic-fetch/index.mjs":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@tonconnect/ui/node_modules/@tonconnect/isomorphic-fetch/index.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var node_fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node-fetch */ \"node-fetch\");\n\nfunction fetch(url, options) {\n    if (/^\\/\\//.test(url)) {\n        url = 'https:' + url;\n    }\n    return node_fetch__WEBPACK_IMPORTED_MODULE_0__.call(this, url, options);\n}\n\nif (!global.fetch) {\n    global.fetch = fetch;\n    global.Response = node_fetch__WEBPACK_IMPORTED_MODULE_0__.Response;\n    global.Headers = node_fetch__WEBPACK_IMPORTED_MODULE_0__.Headers;\n    global.Request = node_fetch__WEBPACK_IMPORTED_MODULE_0__.Request;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWkvbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L2lzb21vcnBoaWMtZmV0Y2gvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7O0FBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw0Q0FBYztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLGdEQUFrQjtBQUN4QyxxQkFBcUIsK0NBQWlCO0FBQ3RDLHFCQUFxQiwrQ0FBaUI7QUFDdEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9tZW1laW5kZXgtZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWkvbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L2lzb21vcnBoaWMtZmV0Y2gvaW5kZXgubWpzP2MxODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJlYWxGZXRjaCBmcm9tICdub2RlLWZldGNoJztcbmZ1bmN0aW9uIGZldGNoKHVybCwgb3B0aW9ucykge1xuICAgIGlmICgvXlxcL1xcLy8udGVzdCh1cmwpKSB7XG4gICAgICAgIHVybCA9ICdodHRwczonICsgdXJsO1xuICAgIH1cbiAgICByZXR1cm4gcmVhbEZldGNoLmNhbGwodGhpcywgdXJsLCBvcHRpb25zKTtcbn1cblxuaWYgKCFnbG9iYWwuZmV0Y2gpIHtcbiAgICBnbG9iYWwuZmV0Y2ggPSBmZXRjaDtcbiAgICBnbG9iYWwuUmVzcG9uc2UgPSByZWFsRmV0Y2guUmVzcG9uc2U7XG4gICAgZ2xvYmFsLkhlYWRlcnMgPSByZWFsRmV0Y2guSGVhZGVycztcbiAgICBnbG9iYWwuUmVxdWVzdCA9IHJlYWxGZXRjaC5SZXF1ZXN0O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@tonconnect/ui/node_modules/@tonconnect/isomorphic-fetch/index.mjs\n");

/***/ }),

/***/ "./node_modules/@tonconnect/ui/node_modules/@tonconnect/sdk/lib/esm/index.mjs":
/*!************************************************************************************!*\
  !*** ./node_modules/@tonconnect/ui/node_modules/@tonconnect/sdk/lib/esm/index.mjs ***!
  \************************************************************************************/
/***/ ((__webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(__webpack_module__, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BadRequestError: () => (/* binding */ BadRequestError),\n/* harmony export */   CHAIN: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CHAIN),\n/* harmony export */   CONNECT_ITEM_ERROR_CODES: () => (/* reexport safe */ _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_ITEM_ERROR_CODES),\n/* harmony export */   FetchWalletsError: () => (/* binding */ FetchWalletsError),\n/* harmony export */   LocalstorageNotFoundError: () => (/* binding */ LocalstorageNotFoundError),\n/* harmony export */   ParseHexError: () => (/* binding */ ParseHexError),\n/* harmony export */   TonConnect: () => (/* binding */ TonConnect),\n/* harmony export */   TonConnectError: () => (/* binding */ TonConnectError),\n/* harmony export */   UnknownAppError: () => (/* binding */ UnknownAppError),\n/* harmony export */   UnknownError: () => (/* binding */ UnknownError),\n/* harmony export */   UserRejectsError: () => (/* binding */ UserRejectsError),\n/* harmony export */   WalletAlreadyConnectedError: () => (/* binding */ WalletAlreadyConnectedError),\n/* harmony export */   WalletNotConnectedError: () => (/* binding */ WalletNotConnectedError),\n/* harmony export */   WalletNotInjectedError: () => (/* binding */ WalletNotInjectedError),\n/* harmony export */   WalletsListManager: () => (/* binding */ WalletsListManager),\n/* harmony export */   WrongAddressError: () => (/* binding */ WrongAddressError),\n/* harmony export */   \"default\": () => (/* binding */ TonConnect),\n/* harmony export */   isTelegramUrl: () => (/* binding */ isTelegramUrl),\n/* harmony export */   isWalletInfoCurrentlyEmbedded: () => (/* binding */ isWalletInfoCurrentlyEmbedded),\n/* harmony export */   isWalletInfoCurrentlyInjected: () => (/* binding */ isWalletInfoCurrentlyInjected),\n/* harmony export */   isWalletInfoInjectable: () => (/* binding */ isWalletInfoInjectable),\n/* harmony export */   isWalletInfoInjected: () => (/* binding */ isWalletInfoInjected),\n/* harmony export */   isWalletInfoRemote: () => (/* binding */ isWalletInfoRemote),\n/* harmony export */   toUserFriendlyAddress: () => (/* binding */ toUserFriendlyAddress)\n/* harmony export */ });\n/* harmony import */ var _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tonconnect/protocol */ \"@tonconnect/protocol\");\n/* harmony import */ var _tonconnect_isomorphic_eventsource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @tonconnect/isomorphic-eventsource */ \"./node_modules/@tonconnect/ui/node_modules/@tonconnect/isomorphic-eventsource/index.mjs\");\n/* harmony import */ var _tonconnect_isomorphic_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @tonconnect/isomorphic-fetch */ \"./node_modules/@tonconnect/ui/node_modules/@tonconnect/isomorphic-fetch/index.mjs\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__]);\n_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n/**\n * Base class for TonConnect errors. You can check if the error was triggered by the @tonconnect/sdk using `err instanceof TonConnectError`.\n */\nclass TonConnectError extends Error {\n    constructor(message, options) {\n        super(message, options);\n        this.message = `${TonConnectError.prefix} ${this.constructor.name}${this.info ? ': ' + this.info : ''}${message ? '\\n' + message : ''}`;\n        Object.setPrototypeOf(this, TonConnectError.prototype);\n    }\n    get info() {\n        return '';\n    }\n}\nTonConnectError.prefix = '[TON_CONNECT_SDK_ERROR]';\n\n/**\n * Thrown when passed DappMetadata is in incorrect format.\n */\nclass DappMetadataError extends TonConnectError {\n    get info() {\n        return 'Passed DappMetadata is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, DappMetadataError.prototype);\n    }\n}\n\n/**\n * Thrown when passed manifest contains errors.\n */\nclass ManifestContentErrorError extends TonConnectError {\n    get info() {\n        return 'Passed `tonconnect-manifest.json` contains errors. Check format of your manifest. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ManifestContentErrorError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet can't get manifest by passed manifestUrl.\n */\nclass ManifestNotFoundError extends TonConnectError {\n    get info() {\n        return 'Manifest not found. Make sure you added `tonconnect-manifest.json` to the root of your app or passed correct manifestUrl. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ManifestNotFoundError.prototype);\n    }\n}\n\n/**\n * Thrown when wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.\n */\nclass WalletAlreadyConnectedError extends TonConnectError {\n    get info() {\n        return 'Wallet connection called but wallet already connected. To avoid the error, disconnect the wallet before doing a new connection.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletAlreadyConnectedError.prototype);\n    }\n}\n\n/**\n * Thrown when send transaction or other protocol methods called while wallet is not connected.\n */\nclass WalletNotConnectedError extends TonConnectError {\n    get info() {\n        return 'Send transaction or other protocol methods called while wallet is not connected.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotConnectedError.prototype);\n    }\n}\n\nfunction isWalletConnectionSourceJS(value) {\n    return 'jsBridgeKey' in value;\n}\n\n/**\n * Thrown when user rejects the action in the wallet.\n */\nclass UserRejectsError extends TonConnectError {\n    get info() {\n        return 'User rejects the action in the wallet.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UserRejectsError.prototype);\n    }\n}\n\n/**\n * Thrown when request to the wallet contains errors.\n */\nclass BadRequestError extends TonConnectError {\n    get info() {\n        return 'Request to the wallet contains errors.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, BadRequestError.prototype);\n    }\n}\n\n/**\n * Thrown when app tries to send rpc request to the injected wallet while not connected.\n */\nclass UnknownAppError extends TonConnectError {\n    get info() {\n        return 'App tries to send rpc request to the injected wallet while not connected.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UnknownAppError.prototype);\n    }\n}\n\n/**\n * Thrown when there is an attempt to connect to the injected wallet while it is not exists in the webpage.\n */\nclass WalletNotInjectedError extends TonConnectError {\n    get info() {\n        return 'There is an attempt to connect to the injected wallet while it is not exists in the webpage.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotInjectedError.prototype);\n    }\n}\n\n/**\n * Thrown when `Storage` was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment.\n */\nclass LocalstorageNotFoundError extends TonConnectError {\n    get info() {\n        return 'Storage was not specified in the `DappMetadata` and default `localStorage` was not detected in the environment.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, LocalstorageNotFoundError.prototype);\n    }\n}\n\n/**\n * Thrown when an error occurred while fetching the wallets list.\n */\nclass FetchWalletsError extends TonConnectError {\n    get info() {\n        return 'An error occurred while fetching the wallets list.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, FetchWalletsError.prototype);\n    }\n}\n\n/**\n * Thrown when passed address is in incorrect format.\n */\nclass WrongAddressError extends TonConnectError {\n    get info() {\n        return 'Passed address is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WrongAddressError.prototype);\n    }\n}\n\n/**\n * Thrown when passed hex is in incorrect format.\n */\nclass ParseHexError extends TonConnectError {\n    get info() {\n        return 'Passed hex is in incorrect format.';\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, ParseHexError.prototype);\n    }\n}\n\n/**\n * Unhanded unknown error.\n */\nclass UnknownError extends TonConnectError {\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, UnknownError.prototype);\n    }\n}\n\nconst connectEventErrorsCodes = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_NOT_FOUND_ERROR]: ManifestNotFoundError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.CONNECT_EVENT_ERROR_CODES.MANIFEST_CONTENT_ERROR]: ManifestContentErrorError\n};\nclass ConnectErrorsParser {\n    parseError(error) {\n        let ErrorConstructor = UnknownError;\n        if (error.code in connectEventErrorsCodes) {\n            ErrorConstructor = connectEventErrorsCodes[error.code] || UnknownError;\n        }\n        return new ErrorConstructor(error.message);\n    }\n}\nconst connectErrorsParser = new ConnectErrorsParser();\n\nclass RpcParser {\n    isError(response) {\n        return 'error' in response;\n    }\n}\n\nconst sendTransactionErrors = {\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_ERROR]: UnknownError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.USER_REJECTS_ERROR]: UserRejectsError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.BAD_REQUEST_ERROR]: BadRequestError,\n    [_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SEND_TRANSACTION_ERROR_CODES.UNKNOWN_APP_ERROR]: UnknownAppError\n};\nclass SendTransactionParser extends RpcParser {\n    convertToRpcRequest(request) {\n        return {\n            method: 'sendTransaction',\n            params: [JSON.stringify(request)]\n        };\n    }\n    parseAndThrowError(response) {\n        let ErrorConstructor = UnknownError;\n        if (response.error.code in sendTransactionErrors) {\n            ErrorConstructor = sendTransactionErrors[response.error.code] || UnknownError;\n        }\n        throw new ErrorConstructor(response.error.message);\n    }\n    convertFromRpcResponse(rpcResponse) {\n        return {\n            boc: rpcResponse.result\n        };\n    }\n}\nconst sendTransactionParser = new SendTransactionParser();\n\nclass HttpBridgeGatewayStorage {\n    constructor(storage, bridgeUrl) {\n        this.storage = storage;\n        this.storeKey = 'ton-connect-storage_http-bridge-gateway::' + bridgeUrl;\n    }\n    storeLastEventId(lastEventId) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.setItem(this.storeKey, lastEventId);\n        });\n    }\n    removeLastEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.removeItem(this.storeKey);\n        });\n    }\n    getLastEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            return stored;\n        });\n    }\n}\n\nfunction removeUrlLastSlash(url) {\n    if (url.slice(-1) === '/') {\n        return url.slice(0, -1);\n    }\n    return url;\n}\nfunction addPathToUrl(url, path) {\n    return removeUrlLastSlash(url) + '/' + path;\n}\nfunction isTelegramUrl(link) {\n    const url = new URL(link);\n    return url.protocol === 'tg:' || url.hostname === 't.me';\n}\n\nclass BridgeGateway {\n    constructor(storage, bridgeUrl, sessionId, listener, errorsListener) {\n        this.bridgeUrl = bridgeUrl;\n        this.sessionId = sessionId;\n        this.listener = listener;\n        this.errorsListener = errorsListener;\n        this.ssePath = 'events';\n        this.postPath = 'message';\n        this.heartbeatMessage = 'heartbeat';\n        this.defaultTtl = 300;\n        this.isClosed = false;\n        this.bridgeGatewayStorage = new HttpBridgeGatewayStorage(storage, bridgeUrl);\n    }\n    registerSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = new URL(addPathToUrl(this.bridgeUrl, this.ssePath));\n            url.searchParams.append('client_id', this.sessionId);\n            const lastEventId = yield this.bridgeGatewayStorage.getLastEventId();\n            if (this.isClosed) {\n                return;\n            }\n            if (lastEventId) {\n                url.searchParams.append('last_event_id', lastEventId);\n            }\n            this.eventSource = new EventSource(url.toString());\n            return new Promise((resolve, reject) => {\n                this.eventSource.onerror = reject;\n                this.eventSource.onopen = () => {\n                    this.eventSource.onerror = this.errorsHandler.bind(this);\n                    this.eventSource.onmessage = this.messagesHandler.bind(this);\n                    resolve();\n                };\n            });\n        });\n    }\n    send(message, receiver, topic, ttl) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const url = new URL(addPathToUrl(this.bridgeUrl, this.postPath));\n            url.searchParams.append('client_id', this.sessionId);\n            url.searchParams.append('to', receiver);\n            url.searchParams.append('ttl', (ttl || this.defaultTtl).toString());\n            url.searchParams.append('topic', topic);\n            yield fetch(url, {\n                method: 'post',\n                body: _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.encode(message)\n            });\n        });\n    }\n    pause() {\n        var _a;\n        (_a = this.eventSource) === null || _a === void 0 ? void 0 : _a.close();\n    }\n    unPause() {\n        return this.registerSession();\n    }\n    close() {\n        var _a;\n        this.isClosed = true;\n        (_a = this.eventSource) === null || _a === void 0 ? void 0 : _a.close();\n    }\n    setListener(listener) {\n        this.listener = listener;\n    }\n    setErrorsListener(errorsListener) {\n        this.errorsListener = errorsListener;\n    }\n    errorsHandler(e) {\n        var _a, _b;\n        if (!this.isClosed) {\n            if (((_a = this.eventSource) === null || _a === void 0 ? void 0 : _a.readyState) === EventSource.CLOSED) {\n                this.eventSource.close();\n                this.registerSession();\n                return;\n            }\n            if (((_b = this.eventSource) === null || _b === void 0 ? void 0 : _b.readyState) === EventSource.CONNECTING) {\n                console.debug('[TON_CONNET_SDK_ERROR]: Bridge error', JSON.stringify(e));\n                return;\n            }\n            this.errorsListener(e);\n        }\n    }\n    messagesHandler(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (e.data === this.heartbeatMessage) {\n                return;\n            }\n            yield this.bridgeGatewayStorage.storeLastEventId(e.lastEventId);\n            if (!this.isClosed) {\n                let bridgeIncomingMessage;\n                try {\n                    bridgeIncomingMessage = JSON.parse(e.data);\n                }\n                catch (e) {\n                    throw new TonConnectError(`Bridge message parse failed, message ${e.data}`);\n                }\n                this.listener(bridgeIncomingMessage);\n            }\n        });\n    }\n}\n\nclass BridgeConnectionStorage {\n    constructor(storage) {\n        this.storage = storage;\n        this.storeKey = 'ton-connect-storage_bridge-connection';\n    }\n    storeConnection(connection) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (connection.type === 'injected') {\n                return this.storage.setItem(this.storeKey, JSON.stringify(connection));\n            }\n            const rawSession = {\n                sessionKeyPair: connection.session.sessionCrypto.stringifyKeypair(),\n                walletPublicKey: connection.session.walletPublicKey,\n                bridgeUrl: connection.session.bridgeUrl\n            };\n            const rawConnection = {\n                type: 'http',\n                connectEvent: connection.connectEvent,\n                session: rawSession,\n                lastWalletEventId: connection.lastWalletEventId,\n                nextRpcRequestId: connection.nextRpcRequestId\n            };\n            return this.storage.setItem(this.storeKey, JSON.stringify(rawConnection));\n        });\n    }\n    removeConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.storage.removeItem(this.storeKey);\n        });\n    }\n    getConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            const connection = JSON.parse(stored);\n            if (connection.type === 'injected') {\n                return connection;\n            }\n            const sessionCrypto = new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto(connection.session.sessionKeyPair);\n            return {\n                type: 'http',\n                connectEvent: connection.connectEvent,\n                lastWalletEventId: connection.lastWalletEventId,\n                nextRpcRequestId: connection.nextRpcRequestId,\n                session: {\n                    sessionCrypto,\n                    bridgeUrl: connection.session.bridgeUrl,\n                    walletPublicKey: connection.session.walletPublicKey\n                }\n            };\n        });\n    }\n    getHttpConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read HTTP connection source while nothing is stored');\n            }\n            if (connection.type === 'injected') {\n                throw new TonConnectError('Trying to read HTTP connection source while injected connection is stored');\n            }\n            return connection;\n        });\n    }\n    getInjectedConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (!connection) {\n                throw new TonConnectError('Trying to read Injected bridge connection source while nothing is stored');\n            }\n            if ((connection === null || connection === void 0 ? void 0 : connection.type) === 'http') {\n                throw new TonConnectError('Trying to read Injected bridge connection source while HTTP connection is stored');\n            }\n            return connection;\n        });\n    }\n    storedConnectionType() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const stored = yield this.storage.getItem(this.storeKey);\n            if (!stored) {\n                return null;\n            }\n            const connection = JSON.parse(stored);\n            return connection.type;\n        });\n    }\n    storeLastWalletEventId(id) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && connection.type === 'http') {\n                connection.lastWalletEventId = id;\n                return this.storeConnection(connection);\n            }\n        });\n    }\n    getLastWalletEventId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection && 'lastWalletEventId' in connection) {\n                return connection.lastWalletEventId;\n            }\n            return undefined;\n        });\n    }\n    increaseNextRpcRequestId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection) {\n                const lastId = connection.nextRpcRequestId || 0;\n                connection.nextRpcRequestId = lastId + 1;\n                return this.storeConnection(connection);\n            }\n        });\n    }\n    getNextRpcRequestId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const connection = yield this.getConnection();\n            if (connection) {\n                return connection.nextRpcRequestId || 0;\n            }\n            return 0;\n        });\n    }\n}\n\nconst PROTOCOL_VERSION = 2;\n\nfunction logDebug(...args) {\n    {\n        try {\n            console.debug('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\nfunction logError(...args) {\n    {\n        try {\n            console.error('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\nfunction logWarning(...args) {\n    {\n        try {\n            console.warn('[TON_CONNECT_SDK]', ...args);\n        }\n        catch (_a) { }\n    }\n}\n\nclass BridgeProvider {\n    constructor(storage, walletConnectionSource) {\n        this.storage = storage;\n        this.walletConnectionSource = walletConnectionSource;\n        this.type = 'http';\n        this.standardUniversalLink = 'tc://';\n        this.pendingRequests = new Map();\n        this.session = null;\n        this.gateway = null;\n        this.pendingGateways = [];\n        this.listeners = [];\n        this.connectionStorage = new BridgeConnectionStorage(storage);\n    }\n    static fromStorage(storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bridgeConnectionStorage = new BridgeConnectionStorage(storage);\n            const connection = yield bridgeConnectionStorage.getHttpConnection();\n            return new BridgeProvider(storage, { bridgeUrl: connection.session.bridgeUrl });\n        });\n    }\n    connect(message) {\n        this.closeGateways();\n        const sessionCrypto = new _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.SessionCrypto();\n        let bridgeUrl = '';\n        let universalLink = this.standardUniversalLink;\n        if (Array.isArray(this.walletConnectionSource)) {\n            this.pendingGateways = this.walletConnectionSource.map(source => {\n                const gateway = new BridgeGateway(this.storage, source.bridgeUrl, sessionCrypto.sessionId, () => { }, e => {\n                    console.error(e);\n                });\n                gateway.setListener(message => this.pendingGatewaysListener(gateway, source.bridgeUrl, message));\n                return gateway;\n            });\n            this.pendingGateways.forEach(bridge => bridge.registerSession());\n        }\n        else {\n            bridgeUrl = this.walletConnectionSource.bridgeUrl;\n            if (this.walletConnectionSource.universalLink) {\n                universalLink = this.walletConnectionSource.universalLink;\n            }\n            this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));\n            this.gateway.registerSession();\n        }\n        this.session = {\n            sessionCrypto,\n            bridgeUrl\n        };\n        return this.generateUniversalLink(universalLink, message);\n    }\n    restoreConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (Array.isArray(this.walletConnectionSource)) {\n                throw new TonConnectError('Internal error. Connection source is array while WalletConnectionSourceHTTP was expected.');\n            }\n            this.closeGateways();\n            const storedConnection = yield this.connectionStorage.getHttpConnection();\n            if (!storedConnection) {\n                return;\n            }\n            this.session = storedConnection.session;\n            this.gateway = new BridgeGateway(this.storage, this.walletConnectionSource.bridgeUrl, storedConnection.session.sessionCrypto.sessionId, this.gatewayListener.bind(this), this.gatewayErrorsListener.bind(this));\n            yield this.gateway.registerSession();\n            this.listeners.forEach(listener => listener(storedConnection.connectEvent));\n        });\n    }\n    sendRequest(request, onRequestSent) {\n        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n            if (!this.gateway || !this.session || !('walletPublicKey' in this.session)) {\n                throw new TonConnectError('Trying to send bridge request without session');\n            }\n            const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n            yield this.connectionStorage.increaseNextRpcRequestId();\n            logDebug('Send http-bridge request:', Object.assign(Object.assign({}, request), { id }));\n            const encodedRequest = this.session.sessionCrypto.encrypt(JSON.stringify(Object.assign(Object.assign({}, request), { id })), (0,_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.hexToByteArray)(this.session.walletPublicKey));\n            this.gateway\n                .send(encodedRequest, this.session.walletPublicKey, request.method)\n                .catch(reject);\n            this.pendingRequests.set(id.toString(), resolve);\n            onRequestSent === null || onRequestSent === void 0 ? void 0 : onRequestSent();\n        }));\n    }\n    closeConnection() {\n        this.closeGateways();\n        this.listeners = [];\n        this.session = null;\n        this.gateway = null;\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let called = false;\n                const onRequestSent = () => {\n                    called = true;\n                    this.removeBridgeAndSession().then(resolve);\n                };\n                try {\n                    yield this.sendRequest({ method: 'disconnect', params: [] }, onRequestSent);\n                }\n                catch (e) {\n                    console.debug(e);\n                    if (!called) {\n                        this.removeBridgeAndSession().then(resolve);\n                    }\n                }\n            }));\n        });\n    }\n    listen(callback) {\n        this.listeners.push(callback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== callback));\n    }\n    pause() {\n        var _a;\n        (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.pause();\n        this.pendingGateways.forEach(bridge => bridge.pause());\n    }\n    unPause() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const promises = this.pendingGateways.map(bridge => bridge.unPause());\n            if (this.gateway) {\n                promises.push(this.gateway.unPause());\n            }\n            yield Promise.all(promises);\n        });\n    }\n    pendingGatewaysListener(gateway, bridgeUrl, bridgeIncomingMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.pendingGateways.includes(gateway)) {\n                gateway.close();\n                return;\n            }\n            this.closeGateways({ except: gateway });\n            this.session.bridgeUrl = bridgeUrl;\n            this.gateway = gateway;\n            this.gateway.setErrorsListener(this.gatewayErrorsListener.bind(this));\n            this.gateway.setListener(this.gatewayListener.bind(this));\n            return this.gatewayListener(bridgeIncomingMessage);\n        });\n    }\n    gatewayListener(bridgeIncomingMessage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletMessage = JSON.parse(this.session.sessionCrypto.decrypt(_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.decode(bridgeIncomingMessage.message).toUint8Array(), (0,_tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.hexToByteArray)(bridgeIncomingMessage.from)));\n            logDebug('Wallet message received:', walletMessage);\n            if (!('event' in walletMessage)) {\n                const id = walletMessage.id.toString();\n                const resolve = this.pendingRequests.get(id);\n                if (!resolve) {\n                    logDebug(`Response id ${id} doesn't match any request's id`);\n                    return;\n                }\n                resolve(walletMessage);\n                this.pendingRequests.delete(id);\n                return;\n            }\n            if (walletMessage.id !== undefined) {\n                const lastId = yield this.connectionStorage.getLastWalletEventId();\n                if (lastId !== undefined && walletMessage.id <= lastId) {\n                    logError(`Received event id (=${walletMessage.id}) must be greater than stored last wallet event id (=${lastId}) `);\n                    return;\n                }\n                if (walletMessage.event !== 'connect') {\n                    yield this.connectionStorage.storeLastWalletEventId(walletMessage.id);\n                }\n            }\n            // `this.listeners` might be modified in the event handler\n            const listeners = this.listeners;\n            if (walletMessage.event === 'connect') {\n                yield this.updateSession(walletMessage, bridgeIncomingMessage.from);\n            }\n            if (walletMessage.event === 'disconnect') {\n                yield this.removeBridgeAndSession();\n            }\n            listeners.forEach(listener => listener(walletMessage));\n        });\n    }\n    gatewayErrorsListener(e) {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new TonConnectError(`Bridge error ${JSON.stringify(e)}`);\n        });\n    }\n    updateSession(connectEvent, walletPublicKey) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.session = Object.assign(Object.assign({}, this.session), { walletPublicKey });\n            const tonAddrItem = connectEvent.payload.items.find(item => item.name === 'ton_addr');\n            const connectEventToSave = Object.assign(Object.assign({}, connectEvent), { payload: Object.assign(Object.assign({}, connectEvent.payload), { items: [tonAddrItem] }) });\n            yield this.connectionStorage.storeConnection({\n                type: 'http',\n                session: this.session,\n                lastWalletEventId: connectEvent.id,\n                connectEvent: connectEventToSave,\n                nextRpcRequestId: 0\n            });\n        });\n    }\n    removeBridgeAndSession() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.closeConnection();\n            yield this.connectionStorage.removeConnection();\n        });\n    }\n    generateUniversalLink(universalLink, message) {\n        if (isTelegramUrl(universalLink)) {\n            return this.generateTGUniversalLink(universalLink, message);\n        }\n        return this.generateRegularUniversalLink(universalLink, message);\n    }\n    generateRegularUniversalLink(universalLink, message) {\n        const url = new URL(universalLink);\n        url.searchParams.append('v', PROTOCOL_VERSION.toString());\n        url.searchParams.append('id', this.session.sessionCrypto.sessionId);\n        url.searchParams.append('r', JSON.stringify(message));\n        return url.toString();\n    }\n    generateTGUniversalLink(universalLink, message) {\n        const urlToWrap = this.generateRegularUniversalLink('about:blank', message);\n        const linkParams = urlToWrap.split('?')[1];\n        const startattach = 'tonconnect-' +\n            linkParams\n                .replaceAll('.', '%2E')\n                .replaceAll('-', '%2D')\n                .replaceAll('_', '%5F')\n                .replaceAll('&', '-')\n                .replaceAll('=', '__')\n                .replaceAll('%', '--');\n        const url = new URL(universalLink);\n        url.searchParams.append('startattach', startattach);\n        return url.toString();\n    }\n    closeGateways(options) {\n        var _a;\n        (_a = this.gateway) === null || _a === void 0 ? void 0 : _a.close();\n        this.pendingGateways\n            .filter(item => item !== (options === null || options === void 0 ? void 0 : options.except))\n            .forEach(bridge => bridge.close());\n        this.pendingGateways = [];\n    }\n}\n\nfunction hasProperty(value, propertyKey) {\n    return hasProperties(value, [propertyKey]);\n}\nfunction hasProperties(value, propertyKeys) {\n    if (!value || typeof value !== 'object') {\n        return false;\n    }\n    return propertyKeys.every(propertyKey => propertyKey in value);\n}\n\nfunction isJSBridgeWithMetadata(value) {\n    try {\n        if (!hasProperty(value, 'tonconnect') || !hasProperty(value.tonconnect, 'walletInfo')) {\n            return false;\n        }\n        return hasProperties(value.tonconnect.walletInfo, [\n            'name',\n            'app_name',\n            'image',\n            'about_url',\n            'platforms'\n        ]);\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\nfunction getWindow() {\n    if (typeof window === 'undefined') {\n        return undefined;\n    }\n    return window;\n}\nfunction getDocument() {\n    if (typeof document === 'undefined') {\n        return undefined;\n    }\n    return document;\n}\nfunction getWebPageManifest() {\n    var _a;\n    const origin = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.location.origin;\n    if (origin) {\n        return origin + '/tonconnect-manifest.json';\n    }\n    return '';\n}\n\nclass InjectedProvider {\n    constructor(storage, injectedWalletKey) {\n        this.injectedWalletKey = injectedWalletKey;\n        this.type = 'injected';\n        this.unsubscribeCallback = null;\n        this.listenSubscriptions = false;\n        this.listeners = [];\n        const window = InjectedProvider.window;\n        if (!InjectedProvider.isWindowContainsWallet(window, injectedWalletKey)) {\n            throw new WalletNotInjectedError();\n        }\n        this.connectionStorage = new BridgeConnectionStorage(storage);\n        this.injectedWallet = window[injectedWalletKey].tonconnect;\n    }\n    static fromStorage(storage) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const bridgeConnectionStorage = new BridgeConnectionStorage(storage);\n            const connection = yield bridgeConnectionStorage.getInjectedConnection();\n            return new InjectedProvider(storage, connection.jsBridgeKey);\n        });\n    }\n    static isWalletInjected(injectedWalletKey) {\n        return InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey);\n    }\n    static isInsideWalletBrowser(injectedWalletKey) {\n        if (InjectedProvider.isWindowContainsWallet(this.window, injectedWalletKey)) {\n            return this.window[injectedWalletKey].tonconnect.isWalletBrowser;\n        }\n        return false;\n    }\n    static getCurrentlyInjectedWallets() {\n        if (!this.window) {\n            return [];\n        }\n        const wallets = Object.entries(this.window).filter(([_, value]) => isJSBridgeWithMetadata(value));\n        return wallets.map(([jsBridgeKey, wallet]) => ({\n            name: wallet.tonconnect.walletInfo.name,\n            appName: wallet.tonconnect.walletInfo.app_name,\n            aboutUrl: wallet.tonconnect.walletInfo.about_url,\n            imageUrl: wallet.tonconnect.walletInfo.image,\n            tondns: wallet.tonconnect.walletInfo.tondns,\n            jsBridgeKey,\n            injected: true,\n            embedded: wallet.tonconnect.isWalletBrowser,\n            platforms: wallet.tonconnect.walletInfo.platforms\n        }));\n    }\n    static isWindowContainsWallet(window, injectedWalletKey) {\n        return (!!window &&\n            injectedWalletKey in window &&\n            typeof window[injectedWalletKey] === 'object' &&\n            'tonconnect' in window[injectedWalletKey]);\n    }\n    connect(message) {\n        this._connect(PROTOCOL_VERSION, message);\n    }\n    restoreConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                logDebug(`Injected Provider restoring connection...`);\n                const connectEvent = yield this.injectedWallet.restoreConnection();\n                logDebug('Injected Provider restoring connection response', connectEvent);\n                if (connectEvent.event === 'connect') {\n                    this.makeSubscriptions();\n                    this.listeners.forEach(listener => listener(connectEvent));\n                }\n                else {\n                    yield this.connectionStorage.removeConnection();\n                }\n            }\n            catch (e) {\n                yield this.connectionStorage.removeConnection();\n                console.error(e);\n            }\n        });\n    }\n    closeConnection() {\n        if (this.listenSubscriptions) {\n            this.injectedWallet.disconnect();\n        }\n        this.closeAllListeners();\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise(resolve => {\n                const onRequestSent = () => {\n                    this.closeAllListeners();\n                    this.connectionStorage.removeConnection().then(resolve);\n                };\n                try {\n                    this.injectedWallet.disconnect();\n                    onRequestSent();\n                }\n                catch (e) {\n                    logDebug(e);\n                    this.sendRequest({\n                        method: 'disconnect',\n                        params: []\n                    }, onRequestSent);\n                }\n            });\n        });\n    }\n    closeAllListeners() {\n        var _a;\n        this.listenSubscriptions = false;\n        this.listeners = [];\n        (_a = this.unsubscribeCallback) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n    listen(eventsCallback) {\n        this.listeners.push(eventsCallback);\n        return () => (this.listeners = this.listeners.filter(listener => listener !== eventsCallback));\n    }\n    sendRequest(request, onRequestSent) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const id = (yield this.connectionStorage.getNextRpcRequestId()).toString();\n            yield this.connectionStorage.increaseNextRpcRequestId();\n            logDebug('Send injected-bridge request:', Object.assign(Object.assign({}, request), { id }));\n            const result = this.injectedWallet.send(Object.assign(Object.assign({}, request), { id }));\n            result.then(response => logDebug('Wallet message received:', response));\n            onRequestSent === null || onRequestSent === void 0 ? void 0 : onRequestSent();\n            return result;\n        });\n    }\n    _connect(protocolVersion, message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                logDebug(`Injected Provider connect request: protocolVersion: ${protocolVersion}, message:`, message);\n                const connectEvent = yield this.injectedWallet.connect(protocolVersion, message);\n                logDebug('Injected Provider connect response:', connectEvent);\n                if (connectEvent.event === 'connect') {\n                    yield this.updateSession();\n                    this.makeSubscriptions();\n                }\n                this.listeners.forEach(listener => listener(connectEvent));\n            }\n            catch (e) {\n                logDebug(e);\n                const connectEventError = {\n                    event: 'connect_error',\n                    payload: {\n                        code: 0,\n                        message: e === null || e === void 0 ? void 0 : e.toString()\n                    }\n                };\n                this.listeners.forEach(listener => listener(connectEventError));\n            }\n        });\n    }\n    makeSubscriptions() {\n        this.listenSubscriptions = true;\n        this.unsubscribeCallback = this.injectedWallet.listen(e => {\n            logDebug('Wallet message received:', e);\n            if (this.listenSubscriptions) {\n                this.listeners.forEach(listener => listener(e));\n            }\n            if (e.event === 'disconnect') {\n                this.disconnect();\n            }\n        });\n    }\n    updateSession() {\n        return this.connectionStorage.storeConnection({\n            type: 'injected',\n            jsBridgeKey: this.injectedWalletKey,\n            nextRpcRequestId: 0\n        });\n    }\n}\nInjectedProvider.window = getWindow();\n\nclass DefaultStorage {\n    constructor() {\n        const window = getWindow();\n        if (!(window === null || window === void 0 ? void 0 : window.localStorage)) {\n            throw new LocalstorageNotFoundError();\n        }\n        this.window = window;\n    }\n    getItem(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return Promise.resolve(this.window.localStorage.getItem(key));\n        });\n    }\n    removeItem(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.window.localStorage.removeItem(key);\n            return Promise.resolve();\n        });\n    }\n    setItem(key, value) {\n        this.window.localStorage.setItem(key, value);\n        return Promise.resolve();\n    }\n}\n\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and `WalletInfo` is injected to the current webpage (`walletInfo.injected === true`).\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyInjected(value) {\n    return isWalletInfoInjectable(value) && value.injected;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjectable` and dApp is opened inside this wallet's browser.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoCurrentlyEmbedded(value) {\n    return isWalletInfoCurrentlyInjected(value) && value.embedded;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoInjected`, but doesn't check if it is injected to the page or not.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjectable(value) {\n    return 'jsBridgeKey' in value;\n}\n/**\n * Checks if `WalletInfo` is `WalletInfoRemote`.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoRemote(value) {\n    return 'bridgeUrl' in value;\n}\n/**\n * @deprecated use `isWalletInfoInjectable` or `isWalletInfoCurrentlyInjected` instead.\n * @param value WalletInfo to check.\n */\nfunction isWalletInfoInjected(value) {\n    return 'jsBridgeKey' in value;\n}\n\nconst FALLBACK_WALLETS_LIST = [\n    {\n        app_name: 'tonkeeper',\n        name: 'Tonkeeper',\n        image: 'https://tonkeeper.com/assets/tonconnect-icon.png',\n        tondns: 'tonkeeper.ton',\n        about_url: 'https://tonkeeper.com',\n        universal_url: 'https://app.tonkeeper.com/ton-connect',\n        bridge: [\n            {\n                type: 'sse',\n                url: 'https://bridge.tonapi.io/bridge'\n            },\n            {\n                type: 'js',\n                key: 'tonkeeper'\n            }\n        ],\n        platforms: ['ios', 'android', 'chrome', 'firefox']\n    },\n    {\n        app_name: 'openmask',\n        name: 'OpenMask',\n        image: 'https://raw.githubusercontent.com/OpenProduct/openmask-extension/main/public/openmask-logo-288.png',\n        about_url: 'https://www.openmask.app/',\n        bridge: [\n            {\n                type: 'js',\n                key: 'openmask'\n            }\n        ],\n        platforms: ['chrome']\n    },\n    {\n        app_name: 'mytonwallet',\n        name: 'MyTonWallet',\n        image: 'https://mytonwallet.io/icon-256.png',\n        about_url: 'https://mytonwallet.io',\n        universal_url: 'https://connect.mytonwallet.org',\n        bridge: [\n            {\n                type: 'js',\n                key: 'mytonwallet'\n            },\n            {\n                type: 'sse',\n                url: 'https://tonconnectbridge.mytonwallet.org/bridge/'\n            }\n        ],\n        platforms: ['chrome', 'windows', 'macos', 'linux']\n    },\n    {\n        app_name: 'tonhub',\n        name: 'Tonhub',\n        image: 'https://tonhub.com/tonconnect_logo.png',\n        about_url: 'https://tonhub.com',\n        universal_url: 'https://tonhub.com/ton-connect',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonhub'\n            },\n            {\n                type: 'sse',\n                url: 'https://connect.tonhubapi.com/tonconnect'\n            }\n        ],\n        platforms: ['ios', 'android']\n    },\n    {\n        app_name: 'tonflow',\n        name: 'TonFlow',\n        image: 'https://tonflow.net/assets/images/tonflow_ico_192.png',\n        about_url: 'https://tonflow.net',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonflow'\n            }\n        ],\n        platforms: ['chrome']\n    },\n    {\n        app_name: 'dewallet',\n        name: 'DeWallet',\n        image: 'https://app.delabwallet.com/logo_black.png',\n        about_url: 'https://delabwallet.com',\n        bridge: [\n            {\n                type: 'js',\n                key: 'dewallet'\n            }\n        ],\n        platforms: ['chrome']\n    },\n    {\n        app_name: 'xtonwallet',\n        name: 'XTONWallet',\n        image: 'https://xtonwallet.com/assets/img/icon-256-back.png',\n        about_url: 'https://xtonwallet.com',\n        bridge: [\n            {\n                type: 'js',\n                key: 'xtonwallet'\n            }\n        ],\n        platforms: ['chrome', 'firefox']\n    },\n    {\n        app_name: 'tonwallet',\n        name: 'TON Wallet',\n        image: 'https://wallet.ton.org/assets/ui/qr-logo.png',\n        about_url: 'https://chrome.google.com/webstore/detail/ton-wallet/nphplpgoakhhjchkkhmiggakijnkhfnd',\n        bridge: [\n            {\n                type: 'js',\n                key: 'tonwallet'\n            }\n        ],\n        platforms: ['chrome']\n    }\n];\n\nclass WalletsListManager {\n    constructor(options) {\n        this.walletsListCache = null;\n        this.walletsListCacheCreationTimestamp = null;\n        this.walletsListSource = 'https://raw.githubusercontent.com/ton-blockchain/wallets-list/main/wallets.json';\n        if (options === null || options === void 0 ? void 0 : options.walletsListSource) {\n            this.walletsListSource = options.walletsListSource;\n        }\n        if (options === null || options === void 0 ? void 0 : options.cacheTTLMs) {\n            this.cacheTTLMs = options.cacheTTLMs;\n        }\n    }\n    getWallets() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.cacheTTLMs &&\n                this.walletsListCacheCreationTimestamp &&\n                Date.now() > this.walletsListCacheCreationTimestamp + this.cacheTTLMs) {\n                this.walletsListCache = null;\n            }\n            if (!this.walletsListCache) {\n                this.walletsListCache = this.fetchWalletsList();\n                this.walletsListCache\n                    .then(() => {\n                    this.walletsListCacheCreationTimestamp = Date.now();\n                })\n                    .catch(() => {\n                    this.walletsListCache = null;\n                    this.walletsListCacheCreationTimestamp = null;\n                });\n            }\n            return this.walletsListCache;\n        });\n    }\n    getEmbeddedWallet() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletsList = yield this.getWallets();\n            const embeddedWallets = walletsList.filter(isWalletInfoCurrentlyEmbedded);\n            if (embeddedWallets.length !== 1) {\n                return null;\n            }\n            return embeddedWallets[0];\n        });\n    }\n    fetchWalletsList() {\n        return __awaiter(this, void 0, void 0, function* () {\n            let walletsList = [];\n            try {\n                const walletsResponse = yield fetch(this.walletsListSource);\n                walletsList = yield walletsResponse.json();\n                if (!Array.isArray(walletsList)) {\n                    throw new FetchWalletsError('Wrong wallets list format, wallets list must be an array.');\n                }\n                const wrongFormatWallets = walletsList.filter(wallet => !this.isCorrectWalletConfigDTO(wallet));\n                if (wrongFormatWallets.length) {\n                    logError(`Wallet(s) ${wrongFormatWallets\n                        .map(wallet => wallet.name)\n                        .join(', ')} config format is wrong. They were removed from the wallets list.`);\n                    walletsList = walletsList.filter(wallet => this.isCorrectWalletConfigDTO(wallet));\n                }\n            }\n            catch (e) {\n                logError(e);\n                walletsList = FALLBACK_WALLETS_LIST;\n            }\n            let currentlyInjectedWallets = [];\n            try {\n                currentlyInjectedWallets = InjectedProvider.getCurrentlyInjectedWallets();\n            }\n            catch (e) {\n                logError(e);\n            }\n            return this.mergeWalletsLists(this.walletConfigDTOListToWalletConfigList(walletsList), currentlyInjectedWallets);\n        });\n    }\n    walletConfigDTOListToWalletConfigList(walletConfigDTO) {\n        return walletConfigDTO.map(walletConfigDTO => {\n            const walletConfigBase = {\n                name: walletConfigDTO.name,\n                appName: walletConfigDTO.app_name,\n                imageUrl: walletConfigDTO.image,\n                aboutUrl: walletConfigDTO.about_url,\n                tondns: walletConfigDTO.tondns,\n                platforms: walletConfigDTO.platforms\n            };\n            const walletConfig = walletConfigBase;\n            walletConfigDTO.bridge.forEach(bridge => {\n                if (bridge.type === 'sse') {\n                    walletConfig.bridgeUrl = bridge.url;\n                    walletConfig.universalLink =\n                        walletConfigDTO.universal_url;\n                    walletConfig.deepLink = walletConfigDTO.deepLink;\n                }\n                if (bridge.type === 'js') {\n                    const jsBridgeKey = bridge.key;\n                    walletConfig.jsBridgeKey = jsBridgeKey;\n                    walletConfig.injected =\n                        InjectedProvider.isWalletInjected(jsBridgeKey);\n                    walletConfig.embedded =\n                        InjectedProvider.isInsideWalletBrowser(jsBridgeKey);\n                }\n            });\n            return walletConfig;\n        });\n    }\n    mergeWalletsLists(list1, list2) {\n        const names = new Set(list1.concat(list2).map(item => item.name));\n        return [...names.values()].map(name => {\n            const list1Item = list1.find(item => item.name === name);\n            const list2Item = list2.find(item => item.name === name);\n            return Object.assign(Object.assign({}, (list1Item && Object.assign({}, list1Item))), (list2Item && Object.assign({}, list2Item)));\n        });\n    }\n    // eslint-disable-next-line complexity\n    isCorrectWalletConfigDTO(value) {\n        if (!value || !(typeof value === 'object')) {\n            return false;\n        }\n        const containsName = 'name' in value;\n        const containsAppName = 'app_name' in value;\n        const containsImage = 'image' in value;\n        const containsAbout = 'about_url' in value;\n        const containsPlatforms = 'platforms' in value;\n        if (!containsName ||\n            !containsImage ||\n            !containsAbout ||\n            !containsPlatforms ||\n            !containsAppName) {\n            return false;\n        }\n        if (!value.platforms ||\n            !Array.isArray(value.platforms) ||\n            !value.platforms.length) {\n            return false;\n        }\n        if (!('bridge' in value) ||\n            !Array.isArray(value.bridge) ||\n            !value.bridge.length) {\n            return false;\n        }\n        const bridge = value.bridge;\n        if (bridge.some(item => !item || typeof item !== 'object' || !('type' in item))) {\n            return false;\n        }\n        const sseBridge = bridge.find(item => item.type === 'sse');\n        if (sseBridge) {\n            if (!('url' in sseBridge) ||\n                !sseBridge.url ||\n                !value.universal_url) {\n                return false;\n            }\n        }\n        const jsBridge = bridge.find(item => item.type === 'js');\n        if (jsBridge) {\n            if (!('key' in jsBridge) || !jsBridge.key) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * Thrown when wallet doesn't support requested feature method.\n */\nclass WalletNotSupportFeatureError extends TonConnectError {\n    get info() {\n        return \"Wallet doesn't support requested feature method.\";\n    }\n    constructor(...args) {\n        super(...args);\n        Object.setPrototypeOf(this, WalletNotSupportFeatureError.prototype);\n    }\n}\n\nfunction checkSendTransactionSupport(features, options) {\n    const supportsDeprecatedSendTransactionFeature = features.includes('SendTransaction');\n    const sendTransactionFeature = features.find(feature => feature && typeof feature === 'object' && feature.name === 'SendTransaction');\n    if (!supportsDeprecatedSendTransactionFeature && !sendTransactionFeature) {\n        throw new WalletNotSupportFeatureError(\"Wallet doesn't support SendTransaction feature.\");\n    }\n    if (sendTransactionFeature && sendTransactionFeature.maxMessages !== undefined) {\n        if (sendTransactionFeature.maxMessages < options.requiredMessagesNumber) {\n            throw new WalletNotSupportFeatureError(`Wallet is not able to handle such SendTransaction request. Max support messages number is ${sendTransactionFeature.maxMessages}, but ${options.requiredMessagesNumber} is required.`);\n        }\n        return;\n    }\n    logWarning(\"Connected wallet didn't provide information about max allowed messages in the SendTransaction request. Request may be rejected by the wallet.\");\n}\n\nclass TonConnect {\n    constructor(options) {\n        this.walletsList = new WalletsListManager();\n        this._wallet = null;\n        this.provider = null;\n        this.statusChangeSubscriptions = [];\n        this.statusChangeErrorSubscriptions = [];\n        this.dappSettings = {\n            manifestUrl: (options === null || options === void 0 ? void 0 : options.manifestUrl) || getWebPageManifest(),\n            storage: (options === null || options === void 0 ? void 0 : options.storage) || new DefaultStorage()\n        };\n        this.walletsList = new WalletsListManager({\n            walletsListSource: options === null || options === void 0 ? void 0 : options.walletsListSource,\n            cacheTTLMs: options === null || options === void 0 ? void 0 : options.walletsListCacheTTLMs\n        });\n        if (!this.dappSettings.manifestUrl) {\n            throw new DappMetadataError('Dapp tonconnect-manifest.json must be specified if window.location.origin is undefined. See more https://github.com/ton-connect/docs/blob/main/requests-responses.md#app-manifest');\n        }\n        this.bridgeConnectionStorage = new BridgeConnectionStorage(this.dappSettings.storage);\n        if (!(options === null || options === void 0 ? void 0 : options.disableAutoPauseConnection)) {\n            this.addWindowFocusAndBlurSubscriptions();\n        }\n    }\n    /**\n     * Returns available wallets list.\n     */\n    static getWallets() {\n        return this.walletsList.getWallets();\n    }\n    /**\n     * Shows if the wallet is connected right now.\n     */\n    get connected() {\n        return this._wallet !== null;\n    }\n    /**\n     * Current connected account or null if no account is connected.\n     */\n    get account() {\n        var _a;\n        return ((_a = this._wallet) === null || _a === void 0 ? void 0 : _a.account) || null;\n    }\n    /**\n     * Current connected wallet or null if no account is connected.\n     */\n    get wallet() {\n        return this._wallet;\n    }\n    set wallet(value) {\n        this._wallet = value;\n        this.statusChangeSubscriptions.forEach(callback => callback(this._wallet));\n    }\n    /**\n     * Returns available wallets list.\n     */\n    getWallets() {\n        return this.walletsList.getWallets();\n    }\n    /**\n     * Allows to subscribe to connection status changes and handle connection errors.\n     * @param callback will be called after connections status changes with actual wallet or null.\n     * @param errorsHandler (optional) will be called with some instance of TonConnectError when connect error is received.\n     * @returns unsubscribe callback.\n     */\n    onStatusChange(callback, errorsHandler) {\n        this.statusChangeSubscriptions.push(callback);\n        if (errorsHandler) {\n            this.statusChangeErrorSubscriptions.push(errorsHandler);\n        }\n        return () => {\n            this.statusChangeSubscriptions = this.statusChangeSubscriptions.filter(item => item !== callback);\n            if (errorsHandler) {\n                this.statusChangeErrorSubscriptions = this.statusChangeErrorSubscriptions.filter(item => item !== errorsHandler);\n            }\n        };\n    }\n    connect(wallet, request) {\n        var _a;\n        if (this.connected) {\n            throw new WalletAlreadyConnectedError();\n        }\n        (_a = this.provider) === null || _a === void 0 ? void 0 : _a.closeConnection();\n        this.provider = this.createProvider(wallet);\n        return this.provider.connect(this.createConnectRequest(request));\n    }\n    /**\n     * Try to restore existing session and reconnect to the corresponding wallet. Call it immediately when your app is loaded.\n     */\n    restoreConnection() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const [bridgeConnectionType, embeddedWallet] = yield Promise.all([\n                this.bridgeConnectionStorage.storedConnectionType(),\n                this.walletsList.getEmbeddedWallet()\n            ]);\n            try {\n                switch (bridgeConnectionType) {\n                    case 'http':\n                        this.provider = yield BridgeProvider.fromStorage(this.dappSettings.storage);\n                        break;\n                    case 'injected':\n                        this.provider = yield InjectedProvider.fromStorage(this.dappSettings.storage);\n                        break;\n                    default:\n                        if (embeddedWallet) {\n                            this.provider = yield this.createProvider(embeddedWallet);\n                        }\n                        else {\n                            return;\n                        }\n                }\n            }\n            catch (_a) {\n                yield this.bridgeConnectionStorage.removeConnection();\n                this.provider = null;\n                return;\n            }\n            this.provider.listen(this.walletEventsListener.bind(this));\n            return this.provider.restoreConnection();\n        });\n    }\n    /**\n     * Asks connected wallet to sign and send the transaction.\n     * @param transaction transaction to send.\n     * @returns signed transaction boc that allows you to find the transaction in the blockchain.\n     * If user rejects transaction, method will throw the corresponding error.\n     */\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.checkConnection();\n            checkSendTransactionSupport(this.wallet.device.features, {\n                requiredMessagesNumber: transaction.messages.length\n            });\n            const { validUntil } = transaction, tx = __rest(transaction, [\"validUntil\"]);\n            const from = transaction.from || this.account.address;\n            const network = transaction.network || this.account.chain;\n            const response = yield this.provider.sendRequest(sendTransactionParser.convertToRpcRequest(Object.assign(Object.assign({}, tx), { valid_until: validUntil, from,\n                network })));\n            if (sendTransactionParser.isError(response)) {\n                return sendTransactionParser.parseAndThrowError(response);\n            }\n            return sendTransactionParser.convertFromRpcResponse(response);\n        });\n    }\n    /**\n     * Disconnect form thw connected wallet and drop current session.\n     */\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!this.connected) {\n                throw new WalletNotConnectedError();\n            }\n            yield this.provider.disconnect();\n            this.onWalletDisconnected();\n        });\n    }\n    /**\n     * Pause bridge HTTP connection. Might be helpful, if you want to pause connections while browser tab is unfocused,\n     * or if you use SDK with NodeJS and want to save server resources.\n     */\n    pauseConnection() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return;\n        }\n        this.provider.pause();\n    }\n    /**\n     * Unpause bridge HTTP connection if it is paused.\n     */\n    unPauseConnection() {\n        var _a;\n        if (((_a = this.provider) === null || _a === void 0 ? void 0 : _a.type) !== 'http') {\n            return Promise.resolve();\n        }\n        return this.provider.unPause();\n    }\n    addWindowFocusAndBlurSubscriptions() {\n        const document = getDocument();\n        if (!document) {\n            return;\n        }\n        try {\n            document.addEventListener('visibilitychange', () => {\n                if (document.hidden) {\n                    this.pauseConnection();\n                }\n                else {\n                    this.unPauseConnection();\n                }\n            });\n        }\n        catch (e) {\n            console.error('Cannot subscribe to the document.visibilitychange: ', e);\n        }\n    }\n    createProvider(wallet) {\n        let provider;\n        if (!Array.isArray(wallet) && isWalletConnectionSourceJS(wallet)) {\n            provider = new InjectedProvider(this.dappSettings.storage, wallet.jsBridgeKey);\n        }\n        else {\n            provider = new BridgeProvider(this.dappSettings.storage, wallet);\n        }\n        provider.listen(this.walletEventsListener.bind(this));\n        return provider;\n    }\n    walletEventsListener(e) {\n        switch (e.event) {\n            case 'connect':\n                this.onWalletConnected(e.payload);\n                break;\n            case 'connect_error':\n                this.onWalletConnectError(e.payload);\n                break;\n            case 'disconnect':\n                this.onWalletDisconnected();\n        }\n    }\n    onWalletConnected(connectEvent) {\n        const tonAccountItem = connectEvent.items.find(item => item.name === 'ton_addr');\n        const tonProofItem = connectEvent.items.find(item => item.name === 'ton_proof');\n        if (!tonAccountItem) {\n            throw new TonConnectError('ton_addr connection item was not found');\n        }\n        const wallet = {\n            device: connectEvent.device,\n            provider: this.provider.type,\n            account: {\n                address: tonAccountItem.address,\n                chain: tonAccountItem.network,\n                walletStateInit: tonAccountItem.walletStateInit,\n                publicKey: tonAccountItem.publicKey\n            }\n        };\n        if (tonProofItem) {\n            wallet.connectItems = {\n                tonProof: tonProofItem\n            };\n        }\n        this.wallet = wallet;\n    }\n    onWalletConnectError(connectEventError) {\n        const error = connectErrorsParser.parseError(connectEventError);\n        this.statusChangeErrorSubscriptions.forEach(errorsHandler => errorsHandler(error));\n        console.debug(error);\n        if (error instanceof ManifestNotFoundError || error instanceof ManifestContentErrorError) {\n            console.error(error);\n            throw error;\n        }\n    }\n    onWalletDisconnected() {\n        this.wallet = null;\n    }\n    checkConnection() {\n        if (!this.connected) {\n            throw new WalletNotConnectedError();\n        }\n    }\n    createConnectRequest(request) {\n        const items = [\n            {\n                name: 'ton_addr'\n            }\n        ];\n        if (request === null || request === void 0 ? void 0 : request.tonProof) {\n            items.push({\n                name: 'ton_proof',\n                payload: request.tonProof\n            });\n        }\n        return {\n            manifestUrl: this.dappSettings.manifestUrl,\n            items\n        };\n    }\n}\nTonConnect.walletsList = new WalletsListManager();\n/**\n * Check if specified wallet is injected and available to use with the app.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isWalletInjected = (walletJSKey) => InjectedProvider.isWalletInjected(walletJSKey);\n/**\n * Check if the app is opened inside specified wallet's browser.\n * @param walletJSKey target wallet's js bridge key.\n */\nTonConnect.isInsideWalletBrowser = (walletJSKey) => InjectedProvider.isInsideWalletBrowser(walletJSKey);\n\nconst bounceableTag = 0x11;\nconst testOnlyTag = 0x80;\n/**\n * Converts raw TON address to bounceable user-friendly format. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n * @param hexAddress raw TON address formatted as \"0:<hex string without 0x>\".\n * @param [testOnly=false] convert address to test-only form. [See details]{@link https://ton.org/docs/learn/overviews/addresses#user-friendly-address}\n */\nfunction toUserFriendlyAddress(hexAddress, testOnly = false) {\n    const { wc, hex } = parseHexAddress(hexAddress);\n    let tag = bounceableTag;\n    if (testOnly) {\n        tag |= testOnlyTag;\n    }\n    const addr = new Int8Array(34);\n    addr[0] = tag;\n    addr[1] = wc;\n    addr.set(hex, 2);\n    const addressWithChecksum = new Uint8Array(36);\n    addressWithChecksum.set(addr);\n    addressWithChecksum.set(crc16(addr), 34);\n    let addressBase64 = _tonconnect_protocol__WEBPACK_IMPORTED_MODULE_0__.Base64.encode(addressWithChecksum);\n    return addressBase64.replace(/\\+/g, '-').replace(/\\//g, '_');\n}\nfunction parseHexAddress(hexAddress) {\n    if (!hexAddress.includes(':')) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\".`);\n    }\n    const parts = hexAddress.split(':');\n    if (parts.length !== 2) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Address must include \":\" only once.`);\n    }\n    const wc = parseInt(parts[0]);\n    if (wc !== 0 && wc !== -1) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. WC must be eq 0 or -1, but ${wc} received.`);\n    }\n    const hex = parts[1];\n    if ((hex === null || hex === void 0 ? void 0 : hex.length) !== 64) {\n        throw new WrongAddressError(`Wrong address ${hexAddress}. Hex part must be 64bytes length, but ${hex === null || hex === void 0 ? void 0 : hex.length} received.`);\n    }\n    return {\n        wc,\n        hex: hexToBytes(hex)\n    };\n}\nfunction crc16(data) {\n    const poly = 0x1021;\n    let reg = 0;\n    const message = new Uint8Array(data.length + 2);\n    message.set(data);\n    for (let byte of message) {\n        let mask = 0x80;\n        while (mask > 0) {\n            reg <<= 1;\n            if (byte & mask) {\n                reg += 1;\n            }\n            mask >>= 1;\n            if (reg > 0xffff) {\n                reg &= 0xffff;\n                reg ^= poly;\n            }\n        }\n    }\n    return new Uint8Array([Math.floor(reg / 256), reg % 256]);\n}\nconst toByteMap = {};\nfor (let ord = 0; ord <= 0xff; ord++) {\n    let s = ord.toString(16);\n    if (s.length < 2) {\n        s = '0' + s;\n    }\n    toByteMap[s] = ord;\n}\nfunction hexToBytes(hex) {\n    hex = hex.toLowerCase();\n    const length2 = hex.length;\n    if (length2 % 2 !== 0) {\n        throw new ParseHexError('Hex string must have length a multiple of 2: ' + hex);\n    }\n    const length = length2 / 2;\n    const result = new Uint8Array(length);\n    for (let i = 0; i < length; i++) {\n        const doubled = i * 2;\n        const hexSubstring = hex.substring(doubled, doubled + 2);\n        if (!toByteMap.hasOwnProperty(hexSubstring)) {\n            throw new ParseHexError('Invalid hex character: ' + hexSubstring);\n        }\n        result[i] = toByteMap[hexSubstring];\n    }\n    return result;\n}\n\n\n//# sourceMappingURL=index.mjs.map\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3QvdWkvbm9kZV9tb2R1bGVzL0B0b25jb25uZWN0L3Nkay9saWIvZXNtL2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBc0k7QUFDL0Q7QUFDM0I7QUFDTjs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdCQUF3QixFQUFFLHNCQUFzQixFQUFFLGtDQUFrQyxFQUFFLDhCQUE4QjtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCLEtBQUssMkVBQXlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssOEVBQTRCO0FBQ2pDLEtBQUssOEVBQTRCO0FBQ2pDLEtBQUssOEVBQTRCO0FBQ2pDLEtBQUssOEVBQTRCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdEQUFNO0FBQzVCLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0YsT0FBTztBQUM3RjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsK0RBQWE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlDQUF5QztBQUMxRixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLCtEQUFhO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9IO0FBQ3BIO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsY0FBYyxJQUFJO0FBQ2xHLG1IQUFtSCxjQUFjLElBQUksSUFBSSxvRUFBYztBQUN2SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtDQUFrQztBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Ysd0RBQU0sdURBQXVELG9FQUFjO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsSUFBSTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsaUJBQWlCLHVEQUF1RCxPQUFPO0FBQ25JO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsbUJBQW1CLGlCQUFpQjtBQUM3RjtBQUNBLHFFQUFxRSxtQkFBbUIsdUNBQXVDLDJCQUEyQixzQkFBc0IsR0FBRztBQUNuTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixjQUFjLElBQUk7QUFDdEcsa0ZBQWtGLGNBQWMsSUFBSTtBQUNwRztBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsZ0JBQWdCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELGdDQUFnQyw4Q0FBOEM7QUFDL0gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0pBQWdKLG1DQUFtQyxRQUFRLGdDQUFnQztBQUMzTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQSxxSUFBcUksU0FBUztBQUM5SSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEVBQThFO0FBQzlFO0FBQ0EsNEVBQTRFO0FBQzVFO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3REFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXLCtCQUErQixJQUFJO0FBQ25HO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXLHlDQUF5QyxzREFBc0Q7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV3ZDtBQUN4ZCIsInNvdXJjZXMiOlsid2VicGFjazovL21lbWVpbmRleC1mcm9udGVuZC8uL25vZGVfbW9kdWxlcy9AdG9uY29ubmVjdC91aS9ub2RlX21vZHVsZXMvQHRvbmNvbm5lY3Qvc2RrL2xpYi9lc20vaW5kZXgubWpzP2M2MWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUywgU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUywgQmFzZTY0LCBTZXNzaW9uQ3J5cHRvLCBoZXhUb0J5dGVBcnJheSB9IGZyb20gJ0B0b25jb25uZWN0L3Byb3RvY29sJztcbmV4cG9ydCB7IENIQUlOLCBDT05ORUNUX0lURU1fRVJST1JfQ09ERVMgfSBmcm9tICdAdG9uY29ubmVjdC9wcm90b2NvbCc7XG5pbXBvcnQgJ0B0b25jb25uZWN0L2lzb21vcnBoaWMtZXZlbnRzb3VyY2UnO1xuaW1wb3J0ICdAdG9uY29ubmVjdC9pc29tb3JwaGljLWZldGNoJztcblxuLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFRvbkNvbm5lY3QgZXJyb3JzLiBZb3UgY2FuIGNoZWNrIGlmIHRoZSBlcnJvciB3YXMgdHJpZ2dlcmVkIGJ5IHRoZSBAdG9uY29ubmVjdC9zZGsgdXNpbmcgYGVyciBpbnN0YW5jZW9mIFRvbkNvbm5lY3RFcnJvcmAuXG4gKi9cbmNsYXNzIFRvbkNvbm5lY3RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgJHtUb25Db25uZWN0RXJyb3IucHJlZml4fSAke3RoaXMuY29uc3RydWN0b3IubmFtZX0ke3RoaXMuaW5mbyA/ICc6ICcgKyB0aGlzLmluZm8gOiAnJ30ke21lc3NhZ2UgPyAnXFxuJyArIG1lc3NhZ2UgOiAnJ31gO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVG9uQ29ubmVjdEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxufVxuVG9uQ29ubmVjdEVycm9yLnByZWZpeCA9ICdbVE9OX0NPTk5FQ1RfU0RLX0VSUk9SXSc7XG5cbi8qKlxuICogVGhyb3duIHdoZW4gcGFzc2VkIERhcHBNZXRhZGF0YSBpcyBpbiBpbmNvcnJlY3QgZm9ybWF0LlxuICovXG5jbGFzcyBEYXBwTWV0YWRhdGFFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnUGFzc2VkIERhcHBNZXRhZGF0YSBpcyBpbiBpbmNvcnJlY3QgZm9ybWF0Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBEYXBwTWV0YWRhdGFFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBwYXNzZWQgbWFuaWZlc3QgY29udGFpbnMgZXJyb3JzLlxuICovXG5jbGFzcyBNYW5pZmVzdENvbnRlbnRFcnJvckVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQgYHRvbmNvbm5lY3QtbWFuaWZlc3QuanNvbmAgY29udGFpbnMgZXJyb3JzLiBDaGVjayBmb3JtYXQgb2YgeW91ciBtYW5pZmVzdC4gU2VlIG1vcmUgaHR0cHM6Ly9naXRodWIuY29tL3Rvbi1jb25uZWN0L2RvY3MvYmxvYi9tYWluL3JlcXVlc3RzLXJlc3BvbnNlcy5tZCNhcHAtbWFuaWZlc3QnO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTWFuaWZlc3RDb250ZW50RXJyb3JFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB3YWxsZXQgY2FuJ3QgZ2V0IG1hbmlmZXN0IGJ5IHBhc3NlZCBtYW5pZmVzdFVybC5cbiAqL1xuY2xhc3MgTWFuaWZlc3ROb3RGb3VuZEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdNYW5pZmVzdCBub3QgZm91bmQuIE1ha2Ugc3VyZSB5b3UgYWRkZWQgYHRvbmNvbm5lY3QtbWFuaWZlc3QuanNvbmAgdG8gdGhlIHJvb3Qgb2YgeW91ciBhcHAgb3IgcGFzc2VkIGNvcnJlY3QgbWFuaWZlc3RVcmwuIFNlZSBtb3JlIGh0dHBzOi8vZ2l0aHViLmNvbS90b24tY29ubmVjdC9kb2NzL2Jsb2IvbWFpbi9yZXF1ZXN0cy1yZXNwb25zZXMubWQjYXBwLW1hbmlmZXN0JztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIE1hbmlmZXN0Tm90Rm91bmRFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB3YWxsZXQgY29ubmVjdGlvbiBjYWxsZWQgYnV0IHdhbGxldCBhbHJlYWR5IGNvbm5lY3RlZC4gVG8gYXZvaWQgdGhlIGVycm9yLCBkaXNjb25uZWN0IHRoZSB3YWxsZXQgYmVmb3JlIGRvaW5nIGEgbmV3IGNvbm5lY3Rpb24uXG4gKi9cbmNsYXNzIFdhbGxldEFscmVhZHlDb25uZWN0ZWRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnV2FsbGV0IGNvbm5lY3Rpb24gY2FsbGVkIGJ1dCB3YWxsZXQgYWxyZWFkeSBjb25uZWN0ZWQuIFRvIGF2b2lkIHRoZSBlcnJvciwgZGlzY29ubmVjdCB0aGUgd2FsbGV0IGJlZm9yZSBkb2luZyBhIG5ldyBjb25uZWN0aW9uLic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXYWxsZXRBbHJlYWR5Q29ubmVjdGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gc2VuZCB0cmFuc2FjdGlvbiBvciBvdGhlciBwcm90b2NvbCBtZXRob2RzIGNhbGxlZCB3aGlsZSB3YWxsZXQgaXMgbm90IGNvbm5lY3RlZC5cbiAqL1xuY2xhc3MgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1NlbmQgdHJhbnNhY3Rpb24gb3Igb3RoZXIgcHJvdG9jb2wgbWV0aG9kcyBjYWxsZWQgd2hpbGUgd2FsbGV0IGlzIG5vdCBjb25uZWN0ZWQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdhbGxldE5vdENvbm5lY3RlZEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc1dhbGxldENvbm5lY3Rpb25Tb3VyY2VKUyh2YWx1ZSkge1xuICAgIHJldHVybiAnanNCcmlkZ2VLZXknIGluIHZhbHVlO1xufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHVzZXIgcmVqZWN0cyB0aGUgYWN0aW9uIGluIHRoZSB3YWxsZXQuXG4gKi9cbmNsYXNzIFVzZXJSZWplY3RzRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1VzZXIgcmVqZWN0cyB0aGUgYWN0aW9uIGluIHRoZSB3YWxsZXQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFVzZXJSZWplY3RzRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gcmVxdWVzdCB0byB0aGUgd2FsbGV0IGNvbnRhaW5zIGVycm9ycy5cbiAqL1xuY2xhc3MgQmFkUmVxdWVzdEVycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdSZXF1ZXN0IHRvIHRoZSB3YWxsZXQgY29udGFpbnMgZXJyb3JzLic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBCYWRSZXF1ZXN0RXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYXBwIHRyaWVzIHRvIHNlbmQgcnBjIHJlcXVlc3QgdG8gdGhlIGluamVjdGVkIHdhbGxldCB3aGlsZSBub3QgY29ubmVjdGVkLlxuICovXG5jbGFzcyBVbmtub3duQXBwRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ0FwcCB0cmllcyB0byBzZW5kIHJwYyByZXF1ZXN0IHRvIHRoZSBpbmplY3RlZCB3YWxsZXQgd2hpbGUgbm90IGNvbm5lY3RlZC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgVW5rbm93bkFwcEVycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHRoZXJlIGlzIGFuIGF0dGVtcHQgdG8gY29ubmVjdCB0byB0aGUgaW5qZWN0ZWQgd2FsbGV0IHdoaWxlIGl0IGlzIG5vdCBleGlzdHMgaW4gdGhlIHdlYnBhZ2UuXG4gKi9cbmNsYXNzIFdhbGxldE5vdEluamVjdGVkRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1RoZXJlIGlzIGFuIGF0dGVtcHQgdG8gY29ubmVjdCB0byB0aGUgaW5qZWN0ZWQgd2FsbGV0IHdoaWxlIGl0IGlzIG5vdCBleGlzdHMgaW4gdGhlIHdlYnBhZ2UuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIFdhbGxldE5vdEluamVjdGVkRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYFN0b3JhZ2VgIHdhcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBgRGFwcE1ldGFkYXRhYCBhbmQgZGVmYXVsdCBgbG9jYWxTdG9yYWdlYCB3YXMgbm90IGRldGVjdGVkIGluIHRoZSBlbnZpcm9ubWVudC5cbiAqL1xuY2xhc3MgTG9jYWxzdG9yYWdlTm90Rm91bmRFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiAnU3RvcmFnZSB3YXMgbm90IHNwZWNpZmllZCBpbiB0aGUgYERhcHBNZXRhZGF0YWAgYW5kIGRlZmF1bHQgYGxvY2FsU3RvcmFnZWAgd2FzIG5vdCBkZXRlY3RlZCBpbiB0aGUgZW52aXJvbm1lbnQuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIExvY2Fsc3RvcmFnZU5vdEZvdW5kRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogVGhyb3duIHdoZW4gYW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgZmV0Y2hpbmcgdGhlIHdhbGxldHMgbGlzdC5cbiAqL1xuY2xhc3MgRmV0Y2hXYWxsZXRzRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ0FuIGVycm9yIG9jY3VycmVkIHdoaWxlIGZldGNoaW5nIHRoZSB3YWxsZXRzIGxpc3QuJztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBzdXBlciguLi5hcmdzKTtcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIEZldGNoV2FsbGV0c0Vycm9yLnByb3RvdHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRocm93biB3aGVuIHBhc3NlZCBhZGRyZXNzIGlzIGluIGluY29ycmVjdCBmb3JtYXQuXG4gKi9cbmNsYXNzIFdyb25nQWRkcmVzc0Vycm9yIGV4dGVuZHMgVG9uQ29ubmVjdEVycm9yIHtcbiAgICBnZXQgaW5mbygpIHtcbiAgICAgICAgcmV0dXJuICdQYXNzZWQgYWRkcmVzcyBpcyBpbiBpbmNvcnJlY3QgZm9ybWF0Lic7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBXcm9uZ0FkZHJlc3NFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiBwYXNzZWQgaGV4IGlzIGluIGluY29ycmVjdCBmb3JtYXQuXG4gKi9cbmNsYXNzIFBhcnNlSGV4RXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGdldCBpbmZvKCkge1xuICAgICAgICByZXR1cm4gJ1Bhc3NlZCBoZXggaXMgaW4gaW5jb3JyZWN0IGZvcm1hdC4nO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgUGFyc2VIZXhFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBVbmhhbmRlZCB1bmtub3duIGVycm9yLlxuICovXG5jbGFzcyBVbmtub3duRXJyb3IgZXh0ZW5kcyBUb25Db25uZWN0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJncyk7XG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBVbmtub3duRXJyb3IucHJvdG90eXBlKTtcbiAgICB9XG59XG5cbmNvbnN0IGNvbm5lY3RFdmVudEVycm9yc0NvZGVzID0ge1xuICAgIFtDT05ORUNUX0VWRU5UX0VSUk9SX0NPREVTLlVOS05PV05fRVJST1JdOiBVbmtub3duRXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuVVNFUl9SRUpFQ1RTX0VSUk9SXTogVXNlclJlamVjdHNFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5CQURfUkVRVUVTVF9FUlJPUl06IEJhZFJlcXVlc3RFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5VTktOT1dOX0FQUF9FUlJPUl06IFVua25vd25BcHBFcnJvcixcbiAgICBbQ09OTkVDVF9FVkVOVF9FUlJPUl9DT0RFUy5NQU5JRkVTVF9OT1RfRk9VTkRfRVJST1JdOiBNYW5pZmVzdE5vdEZvdW5kRXJyb3IsXG4gICAgW0NPTk5FQ1RfRVZFTlRfRVJST1JfQ09ERVMuTUFOSUZFU1RfQ09OVEVOVF9FUlJPUl06IE1hbmlmZXN0Q29udGVudEVycm9yRXJyb3Jcbn07XG5jbGFzcyBDb25uZWN0RXJyb3JzUGFyc2VyIHtcbiAgICBwYXJzZUVycm9yKGVycm9yKSB7XG4gICAgICAgIGxldCBFcnJvckNvbnN0cnVjdG9yID0gVW5rbm93bkVycm9yO1xuICAgICAgICBpZiAoZXJyb3IuY29kZSBpbiBjb25uZWN0RXZlbnRFcnJvcnNDb2Rlcykge1xuICAgICAgICAgICAgRXJyb3JDb25zdHJ1Y3RvciA9IGNvbm5lY3RFdmVudEVycm9yc0NvZGVzW2Vycm9yLmNvZGVdIHx8IFVua25vd25FcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEVycm9yQ29uc3RydWN0b3IoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxufVxuY29uc3QgY29ubmVjdEVycm9yc1BhcnNlciA9IG5ldyBDb25uZWN0RXJyb3JzUGFyc2VyKCk7XG5cbmNsYXNzIFJwY1BhcnNlciB7XG4gICAgaXNFcnJvcihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gJ2Vycm9yJyBpbiByZXNwb25zZTtcbiAgICB9XG59XG5cbmNvbnN0IHNlbmRUcmFuc2FjdGlvbkVycm9ycyA9IHtcbiAgICBbU0VORF9UUkFOU0FDVElPTl9FUlJPUl9DT0RFUy5VTktOT1dOX0VSUk9SXTogVW5rbm93bkVycm9yLFxuICAgIFtTRU5EX1RSQU5TQUNUSU9OX0VSUk9SX0NPREVTLlVTRVJfUkVKRUNUU19FUlJPUl06IFVzZXJSZWplY3RzRXJyb3IsXG4gICAgW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuQkFEX1JFUVVFU1RfRVJST1JdOiBCYWRSZXF1ZXN0RXJyb3IsXG4gICAgW1NFTkRfVFJBTlNBQ1RJT05fRVJST1JfQ09ERVMuVU5LTk9XTl9BUFBfRVJST1JdOiBVbmtub3duQXBwRXJyb3Jcbn07XG5jbGFzcyBTZW5kVHJhbnNhY3Rpb25QYXJzZXIgZXh0ZW5kcyBScGNQYXJzZXIge1xuICAgIGNvbnZlcnRUb1JwY1JlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWV0aG9kOiAnc2VuZFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgIHBhcmFtczogW0pTT04uc3RyaW5naWZ5KHJlcXVlc3QpXVxuICAgICAgICB9O1xuICAgIH1cbiAgICBwYXJzZUFuZFRocm93RXJyb3IocmVzcG9uc2UpIHtcbiAgICAgICAgbGV0IEVycm9yQ29uc3RydWN0b3IgPSBVbmtub3duRXJyb3I7XG4gICAgICAgIGlmIChyZXNwb25zZS5lcnJvci5jb2RlIGluIHNlbmRUcmFuc2FjdGlvbkVycm9ycykge1xuICAgICAgICAgICAgRXJyb3JDb25zdHJ1Y3RvciA9IHNlbmRUcmFuc2FjdGlvbkVycm9yc1tyZXNwb25zZS5lcnJvci5jb2RlXSB8fCBVbmtub3duRXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yQ29uc3RydWN0b3IocmVzcG9uc2UuZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIGNvbnZlcnRGcm9tUnBjUmVzcG9uc2UocnBjUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJvYzogcnBjUmVzcG9uc2UucmVzdWx0XG4gICAgICAgIH07XG4gICAgfVxufVxuY29uc3Qgc2VuZFRyYW5zYWN0aW9uUGFyc2VyID0gbmV3IFNlbmRUcmFuc2FjdGlvblBhcnNlcigpO1xuXG5jbGFzcyBIdHRwQnJpZGdlR2F0ZXdheVN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIGJyaWRnZVVybCkge1xuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgICAgICB0aGlzLnN0b3JlS2V5ID0gJ3Rvbi1jb25uZWN0LXN0b3JhZ2VfaHR0cC1icmlkZ2UtZ2F0ZXdheTo6JyArIGJyaWRnZVVybDtcbiAgICB9XG4gICAgc3RvcmVMYXN0RXZlbnRJZChsYXN0RXZlbnRJZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmVLZXksIGxhc3RFdmVudElkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUxhc3RFdmVudElkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMuc3RvcmVLZXkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0TGFzdEV2ZW50SWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWQgPSB5aWVsZCB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnN0b3JlS2V5KTtcbiAgICAgICAgICAgIGlmICghc3RvcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVkO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVVybExhc3RTbGFzaCh1cmwpIHtcbiAgICBpZiAodXJsLnNsaWNlKC0xKSA9PT0gJy8nKSB7XG4gICAgICAgIHJldHVybiB1cmwuc2xpY2UoMCwgLTEpO1xuICAgIH1cbiAgICByZXR1cm4gdXJsO1xufVxuZnVuY3Rpb24gYWRkUGF0aFRvVXJsKHVybCwgcGF0aCkge1xuICAgIHJldHVybiByZW1vdmVVcmxMYXN0U2xhc2godXJsKSArICcvJyArIHBhdGg7XG59XG5mdW5jdGlvbiBpc1RlbGVncmFtVXJsKGxpbmspIHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGxpbmspO1xuICAgIHJldHVybiB1cmwucHJvdG9jb2wgPT09ICd0ZzonIHx8IHVybC5ob3N0bmFtZSA9PT0gJ3QubWUnO1xufVxuXG5jbGFzcyBCcmlkZ2VHYXRld2F5IHtcbiAgICBjb25zdHJ1Y3RvcihzdG9yYWdlLCBicmlkZ2VVcmwsIHNlc3Npb25JZCwgbGlzdGVuZXIsIGVycm9yc0xpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuYnJpZGdlVXJsID0gYnJpZGdlVXJsO1xuICAgICAgICB0aGlzLnNlc3Npb25JZCA9IHNlc3Npb25JZDtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyID0gZXJyb3JzTGlzdGVuZXI7XG4gICAgICAgIHRoaXMuc3NlUGF0aCA9ICdldmVudHMnO1xuICAgICAgICB0aGlzLnBvc3RQYXRoID0gJ21lc3NhZ2UnO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdE1lc3NhZ2UgPSAnaGVhcnRiZWF0JztcbiAgICAgICAgdGhpcy5kZWZhdWx0VHRsID0gMzAwO1xuICAgICAgICB0aGlzLmlzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnJpZGdlR2F0ZXdheVN0b3JhZ2UgPSBuZXcgSHR0cEJyaWRnZUdhdGV3YXlTdG9yYWdlKHN0b3JhZ2UsIGJyaWRnZVVybCk7XG4gICAgfVxuICAgIHJlZ2lzdGVyU2Vzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYWRkUGF0aFRvVXJsKHRoaXMuYnJpZGdlVXJsLCB0aGlzLnNzZVBhdGgpKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdjbGllbnRfaWQnLCB0aGlzLnNlc3Npb25JZCk7XG4gICAgICAgICAgICBjb25zdCBsYXN0RXZlbnRJZCA9IHlpZWxkIHRoaXMuYnJpZGdlR2F0ZXdheVN0b3JhZ2UuZ2V0TGFzdEV2ZW50SWQoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RFdmVudElkKSB7XG4gICAgICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ2xhc3RfZXZlbnRfaWQnLCBsYXN0RXZlbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlID0gbmV3IEV2ZW50U291cmNlKHVybC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRTb3VyY2Uub25vcGVuID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlLm9uZXJyb3IgPSB0aGlzLmVycm9yc0hhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ldmVudFNvdXJjZS5vbm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzSGFuZGxlci5iaW5kKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZChtZXNzYWdlLCByZWNlaXZlciwgdG9waWMsIHR0bCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTChhZGRQYXRoVG9VcmwodGhpcy5icmlkZ2VVcmwsIHRoaXMucG9zdFBhdGgpKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdjbGllbnRfaWQnLCB0aGlzLnNlc3Npb25JZCk7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndG8nLCByZWNlaXZlcik7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndHRsJywgKHR0bCB8fCB0aGlzLmRlZmF1bHRUdGwpLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ3RvcGljJywgdG9waWMpO1xuICAgICAgICAgICAgeWllbGQgZmV0Y2godXJsLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiAncG9zdCcsXG4gICAgICAgICAgICAgICAgYm9keTogQmFzZTY0LmVuY29kZShtZXNzYWdlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmV2ZW50U291cmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICB9XG4gICAgdW5QYXVzZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJTZXNzaW9uKCk7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICAoX2EgPSB0aGlzLmV2ZW50U291cmNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICB9XG4gICAgc2V0TGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICAgIH1cbiAgICBzZXRFcnJvcnNMaXN0ZW5lcihlcnJvcnNMaXN0ZW5lcikge1xuICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyID0gZXJyb3JzTGlzdGVuZXI7XG4gICAgfVxuICAgIGVycm9yc0hhbmRsZXIoZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgIGlmICgoKF9hID0gdGhpcy5ldmVudFNvdXJjZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSBFdmVudFNvdXJjZS5DTE9TRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWdpc3RlclNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKChfYiA9IHRoaXMuZXZlbnRTb3VyY2UpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWFkeVN0YXRlKSA9PT0gRXZlbnRTb3VyY2UuQ09OTkVDVElORykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tUT05fQ09OTkVUX1NES19FUlJPUl06IEJyaWRnZSBlcnJvcicsIEpTT04uc3RyaW5naWZ5KGUpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmVycm9yc0xpc3RlbmVyKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lc3NhZ2VzSGFuZGxlcihlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoZS5kYXRhID09PSB0aGlzLmhlYXJ0YmVhdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmJyaWRnZUdhdGV3YXlTdG9yYWdlLnN0b3JlTGFzdEV2ZW50SWQoZS5sYXN0RXZlbnRJZCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYnJpZGdlSW5jb21pbmdNZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGJyaWRnZUluY29taW5nTWVzc2FnZSA9IEpTT04ucGFyc2UoZS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgQnJpZGdlIG1lc3NhZ2UgcGFyc2UgZmFpbGVkLCBtZXNzYWdlICR7ZS5kYXRhfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyKGJyaWRnZUluY29taW5nTWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgQnJpZGdlQ29ubmVjdGlvblN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy5zdG9yZUtleSA9ICd0b24tY29ubmVjdC1zdG9yYWdlX2JyaWRnZS1jb25uZWN0aW9uJztcbiAgICB9XG4gICAgc3RvcmVDb25uZWN0aW9uKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdpbmplY3RlZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnNldEl0ZW0odGhpcy5zdG9yZUtleSwgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmF3U2Vzc2lvbiA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uS2V5UGFpcjogY29ubmVjdGlvbi5zZXNzaW9uLnNlc3Npb25DcnlwdG8uc3RyaW5naWZ5S2V5cGFpcigpLFxuICAgICAgICAgICAgICAgIHdhbGxldFB1YmxpY0tleTogY29ubmVjdGlvbi5zZXNzaW9uLndhbGxldFB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICBicmlkZ2VVcmw6IGNvbm5lY3Rpb24uc2Vzc2lvbi5icmlkZ2VVcmxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByYXdDb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdodHRwJyxcbiAgICAgICAgICAgICAgICBjb25uZWN0RXZlbnQ6IGNvbm5lY3Rpb24uY29ubmVjdEV2ZW50LFxuICAgICAgICAgICAgICAgIHNlc3Npb246IHJhd1Nlc3Npb24sXG4gICAgICAgICAgICAgICAgbGFzdFdhbGxldEV2ZW50SWQ6IGNvbm5lY3Rpb24ubGFzdFdhbGxldEV2ZW50SWQsXG4gICAgICAgICAgICAgICAgbmV4dFJwY1JlcXVlc3RJZDogY29ubmVjdGlvbi5uZXh0UnBjUmVxdWVzdElkXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zZXRJdGVtKHRoaXMuc3RvcmVLZXksIEpTT04uc3RyaW5naWZ5KHJhd0Nvbm5lY3Rpb24pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0geWllbGQgdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdpbmplY3RlZCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25DcnlwdG8gPSBuZXcgU2Vzc2lvbkNyeXB0byhjb25uZWN0aW9uLnNlc3Npb24uc2Vzc2lvbktleVBhaXIpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgY29ubmVjdEV2ZW50OiBjb25uZWN0aW9uLmNvbm5lY3RFdmVudCxcbiAgICAgICAgICAgICAgICBsYXN0V2FsbGV0RXZlbnRJZDogY29ubmVjdGlvbi5sYXN0V2FsbGV0RXZlbnRJZCxcbiAgICAgICAgICAgICAgICBuZXh0UnBjUmVxdWVzdElkOiBjb25uZWN0aW9uLm5leHRScGNSZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbjoge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uQ3J5cHRvLFxuICAgICAgICAgICAgICAgICAgICBicmlkZ2VVcmw6IGNvbm5lY3Rpb24uc2Vzc2lvbi5icmlkZ2VVcmwsXG4gICAgICAgICAgICAgICAgICAgIHdhbGxldFB1YmxpY0tleTogY29ubmVjdGlvbi5zZXNzaW9uLndhbGxldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRIdHRwQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEhUVFAgY29ubmVjdGlvbiBzb3VyY2Ugd2hpbGUgbm90aGluZyBpcyBzdG9yZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uLnR5cGUgPT09ICdpbmplY3RlZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVG9uQ29ubmVjdEVycm9yKCdUcnlpbmcgdG8gcmVhZCBIVFRQIGNvbm5lY3Rpb24gc291cmNlIHdoaWxlIGluamVjdGVkIGNvbm5lY3Rpb24gaXMgc3RvcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEluamVjdGVkQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEluamVjdGVkIGJyaWRnZSBjb25uZWN0aW9uIHNvdXJjZSB3aGlsZSBub3RoaW5nIGlzIHN0b3JlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChjb25uZWN0aW9uID09PSBudWxsIHx8IGNvbm5lY3Rpb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbm5lY3Rpb24udHlwZSkgPT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUb25Db25uZWN0RXJyb3IoJ1RyeWluZyB0byByZWFkIEluamVjdGVkIGJyaWRnZSBjb25uZWN0aW9uIHNvdXJjZSB3aGlsZSBIVFRQIGNvbm5lY3Rpb24gaXMgc3RvcmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0b3JlZENvbm5lY3Rpb25UeXBlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkID0geWllbGQgdGhpcy5zdG9yYWdlLmdldEl0ZW0odGhpcy5zdG9yZUtleSk7XG4gICAgICAgICAgICBpZiAoIXN0b3JlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IEpTT04ucGFyc2Uoc3RvcmVkKTtcbiAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLnR5cGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdG9yZUxhc3RXYWxsZXRFdmVudElkKGlkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgdGhpcy5nZXRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoY29ubmVjdGlvbiAmJiBjb25uZWN0aW9uLnR5cGUgPT09ICdodHRwJykge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb24ubGFzdFdhbGxldEV2ZW50SWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRMYXN0V2FsbGV0RXZlbnRJZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uICYmICdsYXN0V2FsbGV0RXZlbnRJZCcgaW4gY29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLmxhc3RXYWxsZXRFdmVudElkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY3JlYXNlTmV4dFJwY1JlcXVlc3RJZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB5aWVsZCB0aGlzLmdldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdElkID0gY29ubmVjdGlvbi5uZXh0UnBjUmVxdWVzdElkIHx8IDA7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5uZXh0UnBjUmVxdWVzdElkID0gbGFzdElkICsgMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdG9yZUNvbm5lY3Rpb24oY29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXROZXh0UnBjUmVxdWVzdElkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuZ2V0Q29ubmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKGNvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5uZXh0UnBjUmVxdWVzdElkIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBQUk9UT0NPTF9WRVJTSU9OID0gMjtcblxuZnVuY3Rpb24gbG9nRGVidWcoLi4uYXJncykge1xuICAgIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoJ1tUT05fQ09OTkVDVF9TREtdJywgLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICB9XG59XG5mdW5jdGlvbiBsb2dFcnJvciguLi5hcmdzKSB7XG4gICAge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignW1RPTl9DT05ORUNUX1NES10nLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGxvZ1dhcm5pbmcoLi4uYXJncykge1xuICAgIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignW1RPTl9DT05ORUNUX1NES10nLCAuLi5hcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgIH1cbn1cblxuY2xhc3MgQnJpZGdlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIHdhbGxldENvbm5lY3Rpb25Tb3VyY2UpIHtcbiAgICAgICAgdGhpcy5zdG9yYWdlID0gc3RvcmFnZTtcbiAgICAgICAgdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlID0gd2FsbGV0Q29ubmVjdGlvblNvdXJjZTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2h0dHAnO1xuICAgICAgICB0aGlzLnN0YW5kYXJkVW5pdmVyc2FsTGluayA9ICd0YzovLyc7XG4gICAgICAgIHRoaXMucGVuZGluZ1JlcXVlc3RzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhdGV3YXkgPSBudWxsO1xuICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5cyA9IFtdO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlID0gbmV3IEJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlKHN0b3JhZ2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0b3JhZ2Uoc3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UgPSBuZXcgQnJpZGdlQ29ubmVjdGlvblN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UuZ2V0SHR0cENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQnJpZGdlUHJvdmlkZXIoc3RvcmFnZSwgeyBicmlkZ2VVcmw6IGNvbm5lY3Rpb24uc2Vzc2lvbi5icmlkZ2VVcmwgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25uZWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5jbG9zZUdhdGV3YXlzKCk7XG4gICAgICAgIGNvbnN0IHNlc3Npb25DcnlwdG8gPSBuZXcgU2Vzc2lvbkNyeXB0bygpO1xuICAgICAgICBsZXQgYnJpZGdlVXJsID0gJyc7XG4gICAgICAgIGxldCB1bml2ZXJzYWxMaW5rID0gdGhpcy5zdGFuZGFyZFVuaXZlcnNhbExpbms7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZSkpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzID0gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLm1hcChzb3VyY2UgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGdhdGV3YXkgPSBuZXcgQnJpZGdlR2F0ZXdheSh0aGlzLnN0b3JhZ2UsIHNvdXJjZS5icmlkZ2VVcmwsIHNlc3Npb25DcnlwdG8uc2Vzc2lvbklkLCAoKSA9PiB7IH0sIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGdhdGV3YXkuc2V0TGlzdGVuZXIobWVzc2FnZSA9PiB0aGlzLnBlbmRpbmdHYXRld2F5c0xpc3RlbmVyKGdhdGV3YXksIHNvdXJjZS5icmlkZ2VVcmwsIG1lc3NhZ2UpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2F0ZXdheTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nR2F0ZXdheXMuZm9yRWFjaChicmlkZ2UgPT4gYnJpZGdlLnJlZ2lzdGVyU2Vzc2lvbigpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGJyaWRnZVVybCA9IHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS5icmlkZ2VVcmw7XG4gICAgICAgICAgICBpZiAodGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLnVuaXZlcnNhbExpbmspIHtcbiAgICAgICAgICAgICAgICB1bml2ZXJzYWxMaW5rID0gdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLnVuaXZlcnNhbExpbms7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdhdGV3YXkgPSBuZXcgQnJpZGdlR2F0ZXdheSh0aGlzLnN0b3JhZ2UsIHRoaXMud2FsbGV0Q29ubmVjdGlvblNvdXJjZS5icmlkZ2VVcmwsIHNlc3Npb25DcnlwdG8uc2Vzc2lvbklkLCB0aGlzLmdhdGV3YXlMaXN0ZW5lci5iaW5kKHRoaXMpLCB0aGlzLmdhdGV3YXlFcnJvcnNMaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHRoaXMuZ2F0ZXdheS5yZWdpc3RlclNlc3Npb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlc3Npb24gPSB7XG4gICAgICAgICAgICBzZXNzaW9uQ3J5cHRvLFxuICAgICAgICAgICAgYnJpZGdlVXJsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlVW5pdmVyc2FsTGluayh1bml2ZXJzYWxMaW5rLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgcmVzdG9yZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLndhbGxldENvbm5lY3Rpb25Tb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignSW50ZXJuYWwgZXJyb3IuIENvbm5lY3Rpb24gc291cmNlIGlzIGFycmF5IHdoaWxlIFdhbGxldENvbm5lY3Rpb25Tb3VyY2VIVFRQIHdhcyBleHBlY3RlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xvc2VHYXRld2F5cygpO1xuICAgICAgICAgICAgY29uc3Qgc3RvcmVkQ29ubmVjdGlvbiA9IHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuZ2V0SHR0cENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIGlmICghc3RvcmVkQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbiA9IHN0b3JlZENvbm5lY3Rpb24uc2Vzc2lvbjtcbiAgICAgICAgICAgIHRoaXMuZ2F0ZXdheSA9IG5ldyBCcmlkZ2VHYXRld2F5KHRoaXMuc3RvcmFnZSwgdGhpcy53YWxsZXRDb25uZWN0aW9uU291cmNlLmJyaWRnZVVybCwgc3RvcmVkQ29ubmVjdGlvbi5zZXNzaW9uLnNlc3Npb25DcnlwdG8uc2Vzc2lvbklkLCB0aGlzLmdhdGV3YXlMaXN0ZW5lci5iaW5kKHRoaXMpLCB0aGlzLmdhdGV3YXlFcnJvcnNMaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2F0ZXdheS5yZWdpc3RlclNlc3Npb24oKTtcbiAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoc3RvcmVkQ29ubmVjdGlvbi5jb25uZWN0RXZlbnQpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRSZXF1ZXN0KHJlcXVlc3QsIG9uUmVxdWVzdFNlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5nYXRld2F5IHx8ICF0aGlzLnNlc3Npb24gfHwgISgnd2FsbGV0UHVibGljS2V5JyBpbiB0aGlzLnNlc3Npb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcignVHJ5aW5nIHRvIHNlbmQgYnJpZGdlIHJlcXVlc3Qgd2l0aG91dCBzZXNzaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9ICh5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLmdldE5leHRScGNSZXF1ZXN0SWQoKSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UuaW5jcmVhc2VOZXh0UnBjUmVxdWVzdElkKCk7XG4gICAgICAgICAgICBsb2dEZWJ1ZygnU2VuZCBodHRwLWJyaWRnZSByZXF1ZXN0OicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQgfSkpO1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZFJlcXVlc3QgPSB0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5lbmNyeXB0KEpTT04uc3RyaW5naWZ5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVxdWVzdCksIHsgaWQgfSkpLCBoZXhUb0J5dGVBcnJheSh0aGlzLnNlc3Npb24ud2FsbGV0UHVibGljS2V5KSk7XG4gICAgICAgICAgICB0aGlzLmdhdGV3YXlcbiAgICAgICAgICAgICAgICAuc2VuZChlbmNvZGVkUmVxdWVzdCwgdGhpcy5zZXNzaW9uLndhbGxldFB1YmxpY0tleSwgcmVxdWVzdC5tZXRob2QpXG4gICAgICAgICAgICAgICAgLmNhdGNoKHJlamVjdCk7XG4gICAgICAgICAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cy5zZXQoaWQudG9TdHJpbmcoKSwgcmVzb2x2ZSk7XG4gICAgICAgICAgICBvblJlcXVlc3RTZW50ID09PSBudWxsIHx8IG9uUmVxdWVzdFNlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUmVxdWVzdFNlbnQoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBjbG9zZUNvbm5lY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2xvc2VHYXRld2F5cygpO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLnNlc3Npb24gPSBudWxsO1xuICAgICAgICB0aGlzLmdhdGV3YXkgPSBudWxsO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uUmVxdWVzdFNlbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlQnJpZGdlQW5kU2Vzc2lvbigpLnRoZW4ocmVzb2x2ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNlbmRSZXF1ZXN0KHsgbWV0aG9kOiAnZGlzY29ubmVjdCcsIHBhcmFtczogW10gfSwgb25SZXF1ZXN0U2VudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUJyaWRnZUFuZFNlc3Npb24oKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGlzdGVuKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gKCkgPT4gKHRoaXMubGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lcnMuZmlsdGVyKGxpc3RlbmVyID0+IGxpc3RlbmVyICE9PSBjYWxsYmFjaykpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmdhdGV3YXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5cy5mb3JFYWNoKGJyaWRnZSA9PiBicmlkZ2UucGF1c2UoKSk7XG4gICAgfVxuICAgIHVuUGF1c2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IHRoaXMucGVuZGluZ0dhdGV3YXlzLm1hcChicmlkZ2UgPT4gYnJpZGdlLnVuUGF1c2UoKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5nYXRld2F5KSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaCh0aGlzLmdhdGV3YXkudW5QYXVzZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlbmRpbmdHYXRld2F5c0xpc3RlbmVyKGdhdGV3YXksIGJyaWRnZVVybCwgYnJpZGdlSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGVuZGluZ0dhdGV3YXlzLmluY2x1ZGVzKGdhdGV3YXkpKSB7XG4gICAgICAgICAgICAgICAgZ2F0ZXdheS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xvc2VHYXRld2F5cyh7IGV4Y2VwdDogZ2F0ZXdheSB9KTtcbiAgICAgICAgICAgIHRoaXMuc2Vzc2lvbi5icmlkZ2VVcmwgPSBicmlkZ2VVcmw7XG4gICAgICAgICAgICB0aGlzLmdhdGV3YXkgPSBnYXRld2F5O1xuICAgICAgICAgICAgdGhpcy5nYXRld2F5LnNldEVycm9yc0xpc3RlbmVyKHRoaXMuZ2F0ZXdheUVycm9yc0xpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgdGhpcy5nYXRld2F5LnNldExpc3RlbmVyKHRoaXMuZ2F0ZXdheUxpc3RlbmVyLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2F0ZXdheUxpc3RlbmVyKGJyaWRnZUluY29taW5nTWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnYXRld2F5TGlzdGVuZXIoYnJpZGdlSW5jb21pbmdNZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRNZXNzYWdlID0gSlNPTi5wYXJzZSh0aGlzLnNlc3Npb24uc2Vzc2lvbkNyeXB0by5kZWNyeXB0KEJhc2U2NC5kZWNvZGUoYnJpZGdlSW5jb21pbmdNZXNzYWdlLm1lc3NhZ2UpLnRvVWludDhBcnJheSgpLCBoZXhUb0J5dGVBcnJheShicmlkZ2VJbmNvbWluZ01lc3NhZ2UuZnJvbSkpKTtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXQgbWVzc2FnZSByZWNlaXZlZDonLCB3YWxsZXRNZXNzYWdlKTtcbiAgICAgICAgICAgIGlmICghKCdldmVudCcgaW4gd2FsbGV0TWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZCA9IHdhbGxldE1lc3NhZ2UuaWQudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlID0gdGhpcy5wZW5kaW5nUmVxdWVzdHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoYFJlc3BvbnNlIGlkICR7aWR9IGRvZXNuJ3QgbWF0Y2ggYW55IHJlcXVlc3QncyBpZGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc29sdmUod2FsbGV0TWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUmVxdWVzdHMuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FsbGV0TWVzc2FnZS5pZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFzdElkID0geWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5nZXRMYXN0V2FsbGV0RXZlbnRJZCgpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SWQgIT09IHVuZGVmaW5lZCAmJiB3YWxsZXRNZXNzYWdlLmlkIDw9IGxhc3RJZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dFcnJvcihgUmVjZWl2ZWQgZXZlbnQgaWQgKD0ke3dhbGxldE1lc3NhZ2UuaWR9KSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBzdG9yZWQgbGFzdCB3YWxsZXQgZXZlbnQgaWQgKD0ke2xhc3RJZH0pIGApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh3YWxsZXRNZXNzYWdlLmV2ZW50ICE9PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5zdG9yZUxhc3RXYWxsZXRFdmVudElkKHdhbGxldE1lc3NhZ2UuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGB0aGlzLmxpc3RlbmVyc2AgbWlnaHQgYmUgbW9kaWZpZWQgaW4gdGhlIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzO1xuICAgICAgICAgICAgaWYgKHdhbGxldE1lc3NhZ2UuZXZlbnQgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMudXBkYXRlU2Vzc2lvbih3YWxsZXRNZXNzYWdlLCBicmlkZ2VJbmNvbWluZ01lc3NhZ2UuZnJvbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAod2FsbGV0TWVzc2FnZS5ldmVudCA9PT0gJ2Rpc2Nvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5yZW1vdmVCcmlkZ2VBbmRTZXNzaW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsaXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcih3YWxsZXRNZXNzYWdlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnYXRld2F5RXJyb3JzTGlzdGVuZXIoZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcihgQnJpZGdlIGVycm9yICR7SlNPTi5zdHJpbmdpZnkoZSl9YCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1cGRhdGVTZXNzaW9uKGNvbm5lY3RFdmVudCwgd2FsbGV0UHVibGljS2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb24gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc2Vzc2lvbiksIHsgd2FsbGV0UHVibGljS2V5IH0pO1xuICAgICAgICAgICAgY29uc3QgdG9uQWRkckl0ZW0gPSBjb25uZWN0RXZlbnQucGF5bG9hZC5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSAndG9uX2FkZHInKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RFdmVudFRvU2F2ZSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY29ubmVjdEV2ZW50KSwgeyBwYXlsb2FkOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbm5lY3RFdmVudC5wYXlsb2FkKSwgeyBpdGVtczogW3RvbkFkZHJJdGVtXSB9KSB9KTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2Uuc3RvcmVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnaHR0cCcsXG4gICAgICAgICAgICAgICAgc2Vzc2lvbjogdGhpcy5zZXNzaW9uLFxuICAgICAgICAgICAgICAgIGxhc3RXYWxsZXRFdmVudElkOiBjb25uZWN0RXZlbnQuaWQsXG4gICAgICAgICAgICAgICAgY29ubmVjdEV2ZW50OiBjb25uZWN0RXZlbnRUb1NhdmUsXG4gICAgICAgICAgICAgICAgbmV4dFJwY1JlcXVlc3RJZDogMFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVCcmlkZ2VBbmRTZXNzaW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdGlvblN0b3JhZ2UucmVtb3ZlQ29ubmVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2VuZXJhdGVVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGlzVGVsZWdyYW1VcmwodW5pdmVyc2FsTGluaykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlVEdVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlUmVndWxhclVuaXZlcnNhbExpbmsodW5pdmVyc2FsTGluaywgbWVzc2FnZSk7XG4gICAgfVxuICAgIGdlbmVyYXRlUmVndWxhclVuaXZlcnNhbExpbmsodW5pdmVyc2FsTGluaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHVuaXZlcnNhbExpbmspO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZCgndicsIFBST1RPQ09MX1ZFUlNJT04udG9TdHJpbmcoKSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdpZCcsIHRoaXMuc2Vzc2lvbi5zZXNzaW9uQ3J5cHRvLnNlc3Npb25JZCk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdyJywgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICAgICAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdlbmVyYXRlVEdVbml2ZXJzYWxMaW5rKHVuaXZlcnNhbExpbmssIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgdXJsVG9XcmFwID0gdGhpcy5nZW5lcmF0ZVJlZ3VsYXJVbml2ZXJzYWxMaW5rKCdhYm91dDpibGFuaycsIG1lc3NhZ2UpO1xuICAgICAgICBjb25zdCBsaW5rUGFyYW1zID0gdXJsVG9XcmFwLnNwbGl0KCc/JylbMV07XG4gICAgICAgIGNvbnN0IHN0YXJ0YXR0YWNoID0gJ3RvbmNvbm5lY3QtJyArXG4gICAgICAgICAgICBsaW5rUGFyYW1zXG4gICAgICAgICAgICAgICAgLnJlcGxhY2VBbGwoJy4nLCAnJTJFJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZUFsbCgnLScsICclMkQnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlQWxsKCdfJywgJyU1RicpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2VBbGwoJyYnLCAnLScpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2VBbGwoJz0nLCAnX18nKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlQWxsKCclJywgJy0tJyk7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodW5pdmVyc2FsTGluayk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdzdGFydGF0dGFjaCcsIHN0YXJ0YXR0YWNoKTtcbiAgICAgICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICBjbG9zZUdhdGV3YXlzKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB0aGlzLmdhdGV3YXkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnBlbmRpbmdHYXRld2F5c1xuICAgICAgICAgICAgLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZXhjZXB0KSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGJyaWRnZSA9PiBicmlkZ2UuY2xvc2UoKSk7XG4gICAgICAgIHRoaXMucGVuZGluZ0dhdGV3YXlzID0gW107XG4gICAgfVxufVxuXG5mdW5jdGlvbiBoYXNQcm9wZXJ0eSh2YWx1ZSwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gaGFzUHJvcGVydGllcyh2YWx1ZSwgW3Byb3BlcnR5S2V5XSk7XG59XG5mdW5jdGlvbiBoYXNQcm9wZXJ0aWVzKHZhbHVlLCBwcm9wZXJ0eUtleXMpIHtcbiAgICBpZiAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcGVydHlLZXlzLmV2ZXJ5KHByb3BlcnR5S2V5ID0+IHByb3BlcnR5S2V5IGluIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gaXNKU0JyaWRnZVdpdGhNZXRhZGF0YSh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICghaGFzUHJvcGVydHkodmFsdWUsICd0b25jb25uZWN0JykgfHwgIWhhc1Byb3BlcnR5KHZhbHVlLnRvbmNvbm5lY3QsICd3YWxsZXRJbmZvJykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFzUHJvcGVydGllcyh2YWx1ZS50b25jb25uZWN0LndhbGxldEluZm8sIFtcbiAgICAgICAgICAgICduYW1lJyxcbiAgICAgICAgICAgICdhcHBfbmFtZScsXG4gICAgICAgICAgICAnaW1hZ2UnLFxuICAgICAgICAgICAgJ2Fib3V0X3VybCcsXG4gICAgICAgICAgICAncGxhdGZvcm1zJ1xuICAgICAgICBdKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFdpbmRvdygpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdztcbn1cbmZ1bmN0aW9uIGdldERvY3VtZW50KCkge1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBkb2N1bWVudDtcbn1cbmZ1bmN0aW9uIGdldFdlYlBhZ2VNYW5pZmVzdCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgb3JpZ2luID0gKF9hID0gZ2V0V2luZG93KCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhdGlvbi5vcmlnaW47XG4gICAgaWYgKG9yaWdpbikge1xuICAgICAgICByZXR1cm4gb3JpZ2luICsgJy90b25jb25uZWN0LW1hbmlmZXN0Lmpzb24nO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbmNsYXNzIEluamVjdGVkUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHN0b3JhZ2UsIGluamVjdGVkV2FsbGV0S2V5KSB7XG4gICAgICAgIHRoaXMuaW5qZWN0ZWRXYWxsZXRLZXkgPSBpbmplY3RlZFdhbGxldEtleTtcbiAgICAgICAgdGhpcy50eXBlID0gJ2luamVjdGVkJztcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZUNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgdGhpcy5saXN0ZW5TdWJzY3JpcHRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIGNvbnN0IHdpbmRvdyA9IEluamVjdGVkUHJvdmlkZXIud2luZG93O1xuICAgICAgICBpZiAoIUluamVjdGVkUHJvdmlkZXIuaXNXaW5kb3dDb250YWluc1dhbGxldCh3aW5kb3csIGluamVjdGVkV2FsbGV0S2V5KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdEluamVjdGVkRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlID0gbmV3IEJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlKHN0b3JhZ2UpO1xuICAgICAgICB0aGlzLmluamVjdGVkV2FsbGV0ID0gd2luZG93W2luamVjdGVkV2FsbGV0S2V5XS50b25jb25uZWN0O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0b3JhZ2Uoc3RvcmFnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UgPSBuZXcgQnJpZGdlQ29ubmVjdGlvblN0b3JhZ2Uoc3RvcmFnZSk7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geWllbGQgYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2UuZ2V0SW5qZWN0ZWRDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEluamVjdGVkUHJvdmlkZXIoc3RvcmFnZSwgY29ubmVjdGlvbi5qc0JyaWRnZUtleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgaXNXYWxsZXRJbmplY3RlZChpbmplY3RlZFdhbGxldEtleSkge1xuICAgICAgICByZXR1cm4gSW5qZWN0ZWRQcm92aWRlci5pc1dpbmRvd0NvbnRhaW5zV2FsbGV0KHRoaXMud2luZG93LCBpbmplY3RlZFdhbGxldEtleSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luc2lkZVdhbGxldEJyb3dzZXIoaW5qZWN0ZWRXYWxsZXRLZXkpIHtcbiAgICAgICAgaWYgKEluamVjdGVkUHJvdmlkZXIuaXNXaW5kb3dDb250YWluc1dhbGxldCh0aGlzLndpbmRvdywgaW5qZWN0ZWRXYWxsZXRLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aW5kb3dbaW5qZWN0ZWRXYWxsZXRLZXldLnRvbmNvbm5lY3QuaXNXYWxsZXRCcm93c2VyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3RhdGljIGdldEN1cnJlbnRseUluamVjdGVkV2FsbGV0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLndpbmRvdykge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdhbGxldHMgPSBPYmplY3QuZW50cmllcyh0aGlzLndpbmRvdykuZmlsdGVyKChbXywgdmFsdWVdKSA9PiBpc0pTQnJpZGdlV2l0aE1ldGFkYXRhKHZhbHVlKSk7XG4gICAgICAgIHJldHVybiB3YWxsZXRzLm1hcCgoW2pzQnJpZGdlS2V5LCB3YWxsZXRdKSA9PiAoe1xuICAgICAgICAgICAgbmFtZTogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5uYW1lLFxuICAgICAgICAgICAgYXBwTmFtZTogd2FsbGV0LnRvbmNvbm5lY3Qud2FsbGV0SW5mby5hcHBfbmFtZSxcbiAgICAgICAgICAgIGFib3V0VXJsOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLmFib3V0X3VybCxcbiAgICAgICAgICAgIGltYWdlVXJsOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLmltYWdlLFxuICAgICAgICAgICAgdG9uZG5zOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLnRvbmRucyxcbiAgICAgICAgICAgIGpzQnJpZGdlS2V5LFxuICAgICAgICAgICAgaW5qZWN0ZWQ6IHRydWUsXG4gICAgICAgICAgICBlbWJlZGRlZDogd2FsbGV0LnRvbmNvbm5lY3QuaXNXYWxsZXRCcm93c2VyLFxuICAgICAgICAgICAgcGxhdGZvcm1zOiB3YWxsZXQudG9uY29ubmVjdC53YWxsZXRJbmZvLnBsYXRmb3Jtc1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHN0YXRpYyBpc1dpbmRvd0NvbnRhaW5zV2FsbGV0KHdpbmRvdywgaW5qZWN0ZWRXYWxsZXRLZXkpIHtcbiAgICAgICAgcmV0dXJuICghIXdpbmRvdyAmJlxuICAgICAgICAgICAgaW5qZWN0ZWRXYWxsZXRLZXkgaW4gd2luZG93ICYmXG4gICAgICAgICAgICB0eXBlb2Ygd2luZG93W2luamVjdGVkV2FsbGV0S2V5XSA9PT0gJ29iamVjdCcgJiZcbiAgICAgICAgICAgICd0b25jb25uZWN0JyBpbiB3aW5kb3dbaW5qZWN0ZWRXYWxsZXRLZXldKTtcbiAgICB9XG4gICAgY29ubmVjdChtZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3QoUFJPVE9DT0xfVkVSU0lPTiwgbWVzc2FnZSk7XG4gICAgfVxuICAgIHJlc3RvcmVDb25uZWN0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhgSW5qZWN0ZWQgUHJvdmlkZXIgcmVzdG9yaW5nIGNvbm5lY3Rpb24uLi5gKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnQgPSB5aWVsZCB0aGlzLmluamVjdGVkV2FsbGV0LnJlc3RvcmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgbG9nRGVidWcoJ0luamVjdGVkIFByb3ZpZGVyIHJlc3RvcmluZyBjb25uZWN0aW9uIHJlc3BvbnNlJywgY29ubmVjdEV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdEV2ZW50LmV2ZW50ID09PSAnY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGNvbm5lY3RFdmVudCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnJlbW92ZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VDb25uZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5TdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmluamVjdGVkV2FsbGV0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsb3NlQWxsTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb25SZXF1ZXN0U2VudCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZUFsbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnJlbW92ZUNvbm5lY3Rpb24oKS50aGVuKHJlc29sdmUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmplY3RlZFdhbGxldC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIG9uUmVxdWVzdFNlbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nRGVidWcoZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnZGlzY29ubmVjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdXG4gICAgICAgICAgICAgICAgICAgIH0sIG9uUmVxdWVzdFNlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xvc2VBbGxMaXN0ZW5lcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5saXN0ZW5TdWJzY3JpcHRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzID0gW107XG4gICAgICAgIChfYSA9IHRoaXMudW5zdWJzY3JpYmVDYWxsYmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIGxpc3RlbihldmVudHNDYWxsYmFjaykge1xuICAgICAgICB0aGlzLmxpc3RlbmVycy5wdXNoKGV2ZW50c0NhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+ICh0aGlzLmxpc3RlbmVycyA9IHRoaXMubGlzdGVuZXJzLmZpbHRlcihsaXN0ZW5lciA9PiBsaXN0ZW5lciAhPT0gZXZlbnRzQ2FsbGJhY2spKTtcbiAgICB9XG4gICAgc2VuZFJlcXVlc3QocmVxdWVzdCwgb25SZXF1ZXN0U2VudCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaWQgPSAoeWllbGQgdGhpcy5jb25uZWN0aW9uU3RvcmFnZS5nZXROZXh0UnBjUmVxdWVzdElkKCkpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLmluY3JlYXNlTmV4dFJwY1JlcXVlc3RJZCgpO1xuICAgICAgICAgICAgbG9nRGVidWcoJ1NlbmQgaW5qZWN0ZWQtYnJpZGdlIHJlcXVlc3Q6JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZCB9KSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmluamVjdGVkV2FsbGV0LnNlbmQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXF1ZXN0KSwgeyBpZCB9KSk7XG4gICAgICAgICAgICByZXN1bHQudGhlbihyZXNwb25zZSA9PiBsb2dEZWJ1ZygnV2FsbGV0IG1lc3NhZ2UgcmVjZWl2ZWQ6JywgcmVzcG9uc2UpKTtcbiAgICAgICAgICAgIG9uUmVxdWVzdFNlbnQgPT09IG51bGwgfHwgb25SZXF1ZXN0U2VudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb25SZXF1ZXN0U2VudCgpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9jb25uZWN0KHByb3RvY29sVmVyc2lvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhgSW5qZWN0ZWQgUHJvdmlkZXIgY29ubmVjdCByZXF1ZXN0OiBwcm90b2NvbFZlcnNpb246ICR7cHJvdG9jb2xWZXJzaW9ufSwgbWVzc2FnZTpgLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnQgPSB5aWVsZCB0aGlzLmluamVjdGVkV2FsbGV0LmNvbm5lY3QocHJvdG9jb2xWZXJzaW9uLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZygnSW5qZWN0ZWQgUHJvdmlkZXIgY29ubmVjdCByZXNwb25zZTonLCBjb25uZWN0RXZlbnQpO1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0RXZlbnQuZXZlbnQgPT09ICdjb25uZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVwZGF0ZVNlc3Npb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYWtlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGNvbm5lY3RFdmVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBsb2dEZWJ1ZyhlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25uZWN0RXZlbnRFcnJvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQ6ICdjb25uZWN0X2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS50b1N0cmluZygpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdGVuZXJzLmZvckVhY2gobGlzdGVuZXIgPT4gbGlzdGVuZXIoY29ubmVjdEV2ZW50RXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1ha2VTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICB0aGlzLmxpc3RlblN1YnNjcmlwdGlvbnMgPSB0cnVlO1xuICAgICAgICB0aGlzLnVuc3Vic2NyaWJlQ2FsbGJhY2sgPSB0aGlzLmluamVjdGVkV2FsbGV0Lmxpc3RlbihlID0+IHtcbiAgICAgICAgICAgIGxvZ0RlYnVnKCdXYWxsZXQgbWVzc2FnZSByZWNlaXZlZDonLCBlKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmxpc3RlblN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVycy5mb3JFYWNoKGxpc3RlbmVyID0+IGxpc3RlbmVyKGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlLmV2ZW50ID09PSAnZGlzY29ubmVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlc3Npb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb25TdG9yYWdlLnN0b3JlQ29ubmVjdGlvbih7XG4gICAgICAgICAgICB0eXBlOiAnaW5qZWN0ZWQnLFxuICAgICAgICAgICAganNCcmlkZ2VLZXk6IHRoaXMuaW5qZWN0ZWRXYWxsZXRLZXksXG4gICAgICAgICAgICBuZXh0UnBjUmVxdWVzdElkOiAwXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbkluamVjdGVkUHJvdmlkZXIud2luZG93ID0gZ2V0V2luZG93KCk7XG5cbmNsYXNzIERlZmF1bHRTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgY29uc3Qgd2luZG93ID0gZ2V0V2luZG93KCk7XG4gICAgICAgIGlmICghKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhbFN0b3JhZ2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTG9jYWxzdG9yYWdlTm90Rm91bmRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIH1cbiAgICBnZXRJdGVtKGtleSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLndpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZUl0ZW0oa2V5KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLndpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2V0SXRlbShrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMud2luZG93LmxvY2FsU3RvcmFnZS5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RhYmxlYCBhbmQgYFdhbGxldEluZm9gIGlzIGluamVjdGVkIHRvIHRoZSBjdXJyZW50IHdlYnBhZ2UgKGB3YWxsZXRJbmZvLmluamVjdGVkID09PSB0cnVlYCkuXG4gKiBAcGFyYW0gdmFsdWUgV2FsbGV0SW5mbyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gaXNXYWxsZXRJbmZvSW5qZWN0YWJsZSh2YWx1ZSkgJiYgdmFsdWUuaW5qZWN0ZWQ7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RhYmxlYCBhbmQgZEFwcCBpcyBvcGVuZWQgaW5zaWRlIHRoaXMgd2FsbGV0J3MgYnJvd3Nlci5cbiAqIEBwYXJhbSB2YWx1ZSBXYWxsZXRJbmZvIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluZm9DdXJyZW50bHlFbWJlZGRlZCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1dhbGxldEluZm9DdXJyZW50bHlJbmplY3RlZCh2YWx1ZSkgJiYgdmFsdWUuZW1iZWRkZWQ7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9JbmplY3RlZGAsIGJ1dCBkb2Vzbid0IGNoZWNrIGlmIGl0IGlzIGluamVjdGVkIHRvIHRoZSBwYWdlIG9yIG5vdC5cbiAqIEBwYXJhbSB2YWx1ZSBXYWxsZXRJbmZvIHRvIGNoZWNrLlxuICovXG5mdW5jdGlvbiBpc1dhbGxldEluZm9JbmplY3RhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICdqc0JyaWRnZUtleScgaW4gdmFsdWU7XG59XG4vKipcbiAqIENoZWNrcyBpZiBgV2FsbGV0SW5mb2AgaXMgYFdhbGxldEluZm9SZW1vdGVgLlxuICogQHBhcmFtIHZhbHVlIFdhbGxldEluZm8gdG8gY2hlY2suXG4gKi9cbmZ1bmN0aW9uIGlzV2FsbGV0SW5mb1JlbW90ZSh2YWx1ZSkge1xuICAgIHJldHVybiAnYnJpZGdlVXJsJyBpbiB2YWx1ZTtcbn1cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlIGBpc1dhbGxldEluZm9JbmplY3RhYmxlYCBvciBgaXNXYWxsZXRJbmZvQ3VycmVudGx5SW5qZWN0ZWRgIGluc3RlYWQuXG4gKiBAcGFyYW0gdmFsdWUgV2FsbGV0SW5mbyB0byBjaGVjay5cbiAqL1xuZnVuY3Rpb24gaXNXYWxsZXRJbmZvSW5qZWN0ZWQodmFsdWUpIHtcbiAgICByZXR1cm4gJ2pzQnJpZGdlS2V5JyBpbiB2YWx1ZTtcbn1cblxuY29uc3QgRkFMTEJBQ0tfV0FMTEVUU19MSVNUID0gW1xuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICd0b25rZWVwZXInLFxuICAgICAgICBuYW1lOiAnVG9ua2VlcGVyJyxcbiAgICAgICAgaW1hZ2U6ICdodHRwczovL3RvbmtlZXBlci5jb20vYXNzZXRzL3RvbmNvbm5lY3QtaWNvbi5wbmcnLFxuICAgICAgICB0b25kbnM6ICd0b25rZWVwZXIudG9uJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly90b25rZWVwZXIuY29tJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vYXBwLnRvbmtlZXBlci5jb20vdG9uLWNvbm5lY3QnLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2JyaWRnZS50b25hcGkuaW8vYnJpZGdlJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ3RvbmtlZXBlcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2lvcycsICdhbmRyb2lkJywgJ2Nocm9tZScsICdmaXJlZm94J11cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdvcGVubWFzaycsXG4gICAgICAgIG5hbWU6ICdPcGVuTWFzaycsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL09wZW5Qcm9kdWN0L29wZW5tYXNrLWV4dGVuc2lvbi9tYWluL3B1YmxpYy9vcGVubWFzay1sb2dvLTI4OC5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3d3dy5vcGVubWFzay5hcHAvJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdvcGVubWFzaydcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgcGxhdGZvcm1zOiBbJ2Nocm9tZSddXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAnbXl0b253YWxsZXQnLFxuICAgICAgICBuYW1lOiAnTXlUb25XYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vbXl0b253YWxsZXQuaW8vaWNvbi0yNTYucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9teXRvbndhbGxldC5pbycsXG4gICAgICAgIHVuaXZlcnNhbF91cmw6ICdodHRwczovL2Nvbm5lY3QubXl0b253YWxsZXQub3JnJyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICdteXRvbndhbGxldCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3NzZScsXG4gICAgICAgICAgICAgICAgdXJsOiAnaHR0cHM6Ly90b25jb25uZWN0YnJpZGdlLm15dG9ud2FsbGV0Lm9yZy9icmlkZ2UvJ1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJywgJ3dpbmRvd3MnLCAnbWFjb3MnLCAnbGludXgnXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3Rvbmh1YicsXG4gICAgICAgIG5hbWU6ICdUb25odWInLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vdG9uaHViLmNvbS90b25jb25uZWN0X2xvZ28ucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly90b25odWIuY29tJyxcbiAgICAgICAgdW5pdmVyc2FsX3VybDogJ2h0dHBzOi8vdG9uaHViLmNvbS90b24tY29ubmVjdCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAndG9uaHViJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3NlJyxcbiAgICAgICAgICAgICAgICB1cmw6ICdodHRwczovL2Nvbm5lY3QudG9uaHViYXBpLmNvbS90b25jb25uZWN0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnaW9zJywgJ2FuZHJvaWQnXVxuICAgIH0sXG4gICAge1xuICAgICAgICBhcHBfbmFtZTogJ3RvbmZsb3cnLFxuICAgICAgICBuYW1lOiAnVG9uRmxvdycsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly90b25mbG93Lm5ldC9hc3NldHMvaW1hZ2VzL3RvbmZsb3dfaWNvXzE5Mi5wbmcnLFxuICAgICAgICBhYm91dF91cmw6ICdodHRwczovL3RvbmZsb3cubmV0JyxcbiAgICAgICAgYnJpZGdlOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2pzJyxcbiAgICAgICAgICAgICAgICBrZXk6ICd0b25mbG93J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJ11cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICdkZXdhbGxldCcsXG4gICAgICAgIG5hbWU6ICdEZVdhbGxldCcsXG4gICAgICAgIGltYWdlOiAnaHR0cHM6Ly9hcHAuZGVsYWJ3YWxsZXQuY29tL2xvZ29fYmxhY2sucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9kZWxhYndhbGxldC5jb20nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ2Rld2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJ11cbiAgICB9LFxuICAgIHtcbiAgICAgICAgYXBwX25hbWU6ICd4dG9ud2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ1hUT05XYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8veHRvbndhbGxldC5jb20vYXNzZXRzL2ltZy9pY29uLTI1Ni1iYWNrLnBuZycsXG4gICAgICAgIGFib3V0X3VybDogJ2h0dHBzOi8veHRvbndhbGxldC5jb20nLFxuICAgICAgICBicmlkZ2U6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnanMnLFxuICAgICAgICAgICAgICAgIGtleTogJ3h0b253YWxsZXQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHBsYXRmb3JtczogWydjaHJvbWUnLCAnZmlyZWZveCddXG4gICAgfSxcbiAgICB7XG4gICAgICAgIGFwcF9uYW1lOiAndG9ud2FsbGV0JyxcbiAgICAgICAgbmFtZTogJ1RPTiBXYWxsZXQnLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vd2FsbGV0LnRvbi5vcmcvYXNzZXRzL3VpL3FyLWxvZ28ucG5nJyxcbiAgICAgICAgYWJvdXRfdXJsOiAnaHR0cHM6Ly9jaHJvbWUuZ29vZ2xlLmNvbS93ZWJzdG9yZS9kZXRhaWwvdG9uLXdhbGxldC9ucGhwbHBnb2FraGhqY2hra2htaWdnYWtpam5raGZuZCcsXG4gICAgICAgIGJyaWRnZTogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdqcycsXG4gICAgICAgICAgICAgICAga2V5OiAndG9ud2FsbGV0J1xuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgICBwbGF0Zm9ybXM6IFsnY2hyb21lJ11cbiAgICB9XG5dO1xuXG5jbGFzcyBXYWxsZXRzTGlzdE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy53YWxsZXRzTGlzdENhY2hlID0gbnVsbDtcbiAgICAgICAgdGhpcy53YWxsZXRzTGlzdENhY2hlQ3JlYXRpb25UaW1lc3RhbXAgPSBudWxsO1xuICAgICAgICB0aGlzLndhbGxldHNMaXN0U291cmNlID0gJ2h0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS90b24tYmxvY2tjaGFpbi93YWxsZXRzLWxpc3QvbWFpbi93YWxsZXRzLmpzb24nO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndhbGxldHNMaXN0U291cmNlKSB7XG4gICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0U291cmNlID0gb3B0aW9ucy53YWxsZXRzTGlzdFNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhY2hlVFRMTXMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FjaGVUVExNcyA9IG9wdGlvbnMuY2FjaGVUVExNcztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRXYWxsZXRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FjaGVUVExNcyAmJlxuICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3RDYWNoZUNyZWF0aW9uVGltZXN0YW1wICYmXG4gICAgICAgICAgICAgICAgRGF0ZS5ub3coKSA+IHRoaXMud2FsbGV0c0xpc3RDYWNoZUNyZWF0aW9uVGltZXN0YW1wICsgdGhpcy5jYWNoZVRUTE1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdENhY2hlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy53YWxsZXRzTGlzdENhY2hlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdENhY2hlID0gdGhpcy5mZXRjaFdhbGxldHNMaXN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdENhY2hlXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53YWxsZXRzTGlzdENhY2hlQ3JlYXRpb25UaW1lc3RhbXAgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3RDYWNoZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FsbGV0c0xpc3RDYWNoZUNyZWF0aW9uVGltZXN0YW1wID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndhbGxldHNMaXN0Q2FjaGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFbWJlZGRlZFdhbGxldCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldHNMaXN0ID0geWllbGQgdGhpcy5nZXRXYWxsZXRzKCk7XG4gICAgICAgICAgICBjb25zdCBlbWJlZGRlZFdhbGxldHMgPSB3YWxsZXRzTGlzdC5maWx0ZXIoaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQpO1xuICAgICAgICAgICAgaWYgKGVtYmVkZGVkV2FsbGV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBlbWJlZGRlZFdhbGxldHNbMF07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmZXRjaFdhbGxldHNMaXN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHdhbGxldHNMaXN0ID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldHNSZXNwb25zZSA9IHlpZWxkIGZldGNoKHRoaXMud2FsbGV0c0xpc3RTb3VyY2UpO1xuICAgICAgICAgICAgICAgIHdhbGxldHNMaXN0ID0geWllbGQgd2FsbGV0c1Jlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkod2FsbGV0c0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGZXRjaFdhbGxldHNFcnJvcignV3Jvbmcgd2FsbGV0cyBsaXN0IGZvcm1hdCwgd2FsbGV0cyBsaXN0IG11c3QgYmUgYW4gYXJyYXkuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHdyb25nRm9ybWF0V2FsbGV0cyA9IHdhbGxldHNMaXN0LmZpbHRlcih3YWxsZXQgPT4gIXRoaXMuaXNDb3JyZWN0V2FsbGV0Q29uZmlnRFRPKHdhbGxldCkpO1xuICAgICAgICAgICAgICAgIGlmICh3cm9uZ0Zvcm1hdFdhbGxldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGBXYWxsZXQocykgJHt3cm9uZ0Zvcm1hdFdhbGxldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAod2FsbGV0ID0+IHdhbGxldC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJywgJyl9IGNvbmZpZyBmb3JtYXQgaXMgd3JvbmcuIFRoZXkgd2VyZSByZW1vdmVkIGZyb20gdGhlIHdhbGxldHMgbGlzdC5gKTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0c0xpc3QgPSB3YWxsZXRzTGlzdC5maWx0ZXIod2FsbGV0ID0+IHRoaXMuaXNDb3JyZWN0V2FsbGV0Q29uZmlnRFRPKHdhbGxldCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nRXJyb3IoZSk7XG4gICAgICAgICAgICAgICAgd2FsbGV0c0xpc3QgPSBGQUxMQkFDS19XQUxMRVRTX0xJU1Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseUluamVjdGVkV2FsbGV0cyA9IEluamVjdGVkUHJvdmlkZXIuZ2V0Q3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ0Vycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWVyZ2VXYWxsZXRzTGlzdHModGhpcy53YWxsZXRDb25maWdEVE9MaXN0VG9XYWxsZXRDb25maWdMaXN0KHdhbGxldHNMaXN0KSwgY3VycmVudGx5SW5qZWN0ZWRXYWxsZXRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhbGxldENvbmZpZ0RUT0xpc3RUb1dhbGxldENvbmZpZ0xpc3Qod2FsbGV0Q29uZmlnRFRPKSB7XG4gICAgICAgIHJldHVybiB3YWxsZXRDb25maWdEVE8ubWFwKHdhbGxldENvbmZpZ0RUTyA9PiB7XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRDb25maWdCYXNlID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHdhbGxldENvbmZpZ0RUTy5uYW1lLFxuICAgICAgICAgICAgICAgIGFwcE5hbWU6IHdhbGxldENvbmZpZ0RUTy5hcHBfbmFtZSxcbiAgICAgICAgICAgICAgICBpbWFnZVVybDogd2FsbGV0Q29uZmlnRFRPLmltYWdlLFxuICAgICAgICAgICAgICAgIGFib3V0VXJsOiB3YWxsZXRDb25maWdEVE8uYWJvdXRfdXJsLFxuICAgICAgICAgICAgICAgIHRvbmRuczogd2FsbGV0Q29uZmlnRFRPLnRvbmRucyxcbiAgICAgICAgICAgICAgICBwbGF0Zm9ybXM6IHdhbGxldENvbmZpZ0RUTy5wbGF0Zm9ybXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB3YWxsZXRDb25maWcgPSB3YWxsZXRDb25maWdCYXNlO1xuICAgICAgICAgICAgd2FsbGV0Q29uZmlnRFRPLmJyaWRnZS5mb3JFYWNoKGJyaWRnZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGJyaWRnZS50eXBlID09PSAnc3NlJykge1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWcuYnJpZGdlVXJsID0gYnJpZGdlLnVybDtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnLnVuaXZlcnNhbExpbmsgPVxuICAgICAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnRFRPLnVuaXZlcnNhbF91cmw7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENvbmZpZy5kZWVwTGluayA9IHdhbGxldENvbmZpZ0RUTy5kZWVwTGluaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJyaWRnZS50eXBlID09PSAnanMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzQnJpZGdlS2V5ID0gYnJpZGdlLmtleTtcbiAgICAgICAgICAgICAgICAgICAgd2FsbGV0Q29uZmlnLmpzQnJpZGdlS2V5ID0ganNCcmlkZ2VLZXk7XG4gICAgICAgICAgICAgICAgICAgIHdhbGxldENvbmZpZy5pbmplY3RlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmplY3RlZFByb3ZpZGVyLmlzV2FsbGV0SW5qZWN0ZWQoanNCcmlkZ2VLZXkpO1xuICAgICAgICAgICAgICAgICAgICB3YWxsZXRDb25maWcuZW1iZWRkZWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgSW5qZWN0ZWRQcm92aWRlci5pc0luc2lkZVdhbGxldEJyb3dzZXIoanNCcmlkZ2VLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdhbGxldENvbmZpZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1lcmdlV2FsbGV0c0xpc3RzKGxpc3QxLCBsaXN0Mikge1xuICAgICAgICBjb25zdCBuYW1lcyA9IG5ldyBTZXQobGlzdDEuY29uY2F0KGxpc3QyKS5tYXAoaXRlbSA9PiBpdGVtLm5hbWUpKTtcbiAgICAgICAgcmV0dXJuIFsuLi5uYW1lcy52YWx1ZXMoKV0ubWFwKG5hbWUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdDFJdGVtID0gbGlzdDEuZmluZChpdGVtID0+IGl0ZW0ubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgICAgICBjb25zdCBsaXN0Mkl0ZW0gPSBsaXN0Mi5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChsaXN0MUl0ZW0gJiYgT2JqZWN0LmFzc2lnbih7fSwgbGlzdDFJdGVtKSkpLCAobGlzdDJJdGVtICYmIE9iamVjdC5hc3NpZ24oe30sIGxpc3QySXRlbSkpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG4gICAgaXNDb3JyZWN0V2FsbGV0Q29uZmlnRFRPKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUgfHwgISh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zTmFtZSA9ICduYW1lJyBpbiB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29udGFpbnNBcHBOYW1lID0gJ2FwcF9uYW1lJyBpbiB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29udGFpbnNJbWFnZSA9ICdpbWFnZScgaW4gdmFsdWU7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5zQWJvdXQgPSAnYWJvdXRfdXJsJyBpbiB2YWx1ZTtcbiAgICAgICAgY29uc3QgY29udGFpbnNQbGF0Zm9ybXMgPSAncGxhdGZvcm1zJyBpbiB2YWx1ZTtcbiAgICAgICAgaWYgKCFjb250YWluc05hbWUgfHxcbiAgICAgICAgICAgICFjb250YWluc0ltYWdlIHx8XG4gICAgICAgICAgICAhY29udGFpbnNBYm91dCB8fFxuICAgICAgICAgICAgIWNvbnRhaW5zUGxhdGZvcm1zIHx8XG4gICAgICAgICAgICAhY29udGFpbnNBcHBOYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZS5wbGF0Zm9ybXMgfHxcbiAgICAgICAgICAgICFBcnJheS5pc0FycmF5KHZhbHVlLnBsYXRmb3JtcykgfHxcbiAgICAgICAgICAgICF2YWx1ZS5wbGF0Zm9ybXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoJ2JyaWRnZScgaW4gdmFsdWUpIHx8XG4gICAgICAgICAgICAhQXJyYXkuaXNBcnJheSh2YWx1ZS5icmlkZ2UpIHx8XG4gICAgICAgICAgICAhdmFsdWUuYnJpZGdlLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJyaWRnZSA9IHZhbHVlLmJyaWRnZTtcbiAgICAgICAgaWYgKGJyaWRnZS5zb21lKGl0ZW0gPT4gIWl0ZW0gfHwgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8ICEoJ3R5cGUnIGluIGl0ZW0pKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNzZUJyaWRnZSA9IGJyaWRnZS5maW5kKGl0ZW0gPT4gaXRlbS50eXBlID09PSAnc3NlJyk7XG4gICAgICAgIGlmIChzc2VCcmlkZ2UpIHtcbiAgICAgICAgICAgIGlmICghKCd1cmwnIGluIHNzZUJyaWRnZSkgfHxcbiAgICAgICAgICAgICAgICAhc3NlQnJpZGdlLnVybCB8fFxuICAgICAgICAgICAgICAgICF2YWx1ZS51bml2ZXJzYWxfdXJsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGpzQnJpZGdlID0gYnJpZGdlLmZpbmQoaXRlbSA9PiBpdGVtLnR5cGUgPT09ICdqcycpO1xuICAgICAgICBpZiAoanNCcmlkZ2UpIHtcbiAgICAgICAgICAgIGlmICghKCdrZXknIGluIGpzQnJpZGdlKSB8fCAhanNCcmlkZ2Uua2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBUaHJvd24gd2hlbiB3YWxsZXQgZG9lc24ndCBzdXBwb3J0IHJlcXVlc3RlZCBmZWF0dXJlIG1ldGhvZC5cbiAqL1xuY2xhc3MgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvciBleHRlbmRzIFRvbkNvbm5lY3RFcnJvciB7XG4gICAgZ2V0IGluZm8oKSB7XG4gICAgICAgIHJldHVybiBcIldhbGxldCBkb2Vzbid0IHN1cHBvcnQgcmVxdWVzdGVkIGZlYXR1cmUgbWV0aG9kLlwiO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvci5wcm90b3R5cGUpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tTZW5kVHJhbnNhY3Rpb25TdXBwb3J0KGZlYXR1cmVzLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgc3VwcG9ydHNEZXByZWNhdGVkU2VuZFRyYW5zYWN0aW9uRmVhdHVyZSA9IGZlYXR1cmVzLmluY2x1ZGVzKCdTZW5kVHJhbnNhY3Rpb24nKTtcbiAgICBjb25zdCBzZW5kVHJhbnNhY3Rpb25GZWF0dXJlID0gZmVhdHVyZXMuZmluZChmZWF0dXJlID0+IGZlYXR1cmUgJiYgdHlwZW9mIGZlYXR1cmUgPT09ICdvYmplY3QnICYmIGZlYXR1cmUubmFtZSA9PT0gJ1NlbmRUcmFuc2FjdGlvbicpO1xuICAgIGlmICghc3VwcG9ydHNEZXByZWNhdGVkU2VuZFRyYW5zYWN0aW9uRmVhdHVyZSAmJiAhc2VuZFRyYW5zYWN0aW9uRmVhdHVyZSkge1xuICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90U3VwcG9ydEZlYXR1cmVFcnJvcihcIldhbGxldCBkb2Vzbid0IHN1cHBvcnQgU2VuZFRyYW5zYWN0aW9uIGZlYXR1cmUuXCIpO1xuICAgIH1cbiAgICBpZiAoc2VuZFRyYW5zYWN0aW9uRmVhdHVyZSAmJiBzZW5kVHJhbnNhY3Rpb25GZWF0dXJlLm1heE1lc3NhZ2VzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNlbmRUcmFuc2FjdGlvbkZlYXR1cmUubWF4TWVzc2FnZXMgPCBvcHRpb25zLnJlcXVpcmVkTWVzc2FnZXNOdW1iZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RTdXBwb3J0RmVhdHVyZUVycm9yKGBXYWxsZXQgaXMgbm90IGFibGUgdG8gaGFuZGxlIHN1Y2ggU2VuZFRyYW5zYWN0aW9uIHJlcXVlc3QuIE1heCBzdXBwb3J0IG1lc3NhZ2VzIG51bWJlciBpcyAke3NlbmRUcmFuc2FjdGlvbkZlYXR1cmUubWF4TWVzc2FnZXN9LCBidXQgJHtvcHRpb25zLnJlcXVpcmVkTWVzc2FnZXNOdW1iZXJ9IGlzIHJlcXVpcmVkLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbG9nV2FybmluZyhcIkNvbm5lY3RlZCB3YWxsZXQgZGlkbid0IHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgbWF4IGFsbG93ZWQgbWVzc2FnZXMgaW4gdGhlIFNlbmRUcmFuc2FjdGlvbiByZXF1ZXN0LiBSZXF1ZXN0IG1heSBiZSByZWplY3RlZCBieSB0aGUgd2FsbGV0LlwiKTtcbn1cblxuY2xhc3MgVG9uQ29ubmVjdCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLndhbGxldHNMaXN0ID0gbmV3IFdhbGxldHNMaXN0TWFuYWdlcigpO1xuICAgICAgICB0aGlzLl93YWxsZXQgPSBudWxsO1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdGF0dXNDaGFuZ2VTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zID0gW107XG4gICAgICAgIHRoaXMuZGFwcFNldHRpbmdzID0ge1xuICAgICAgICAgICAgbWFuaWZlc3RVcmw6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWFuaWZlc3RVcmwpIHx8IGdldFdlYlBhZ2VNYW5pZmVzdCgpLFxuICAgICAgICAgICAgc3RvcmFnZTogKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdG9yYWdlKSB8fCBuZXcgRGVmYXVsdFN0b3JhZ2UoKVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndhbGxldHNMaXN0ID0gbmV3IFdhbGxldHNMaXN0TWFuYWdlcih7XG4gICAgICAgICAgICB3YWxsZXRzTGlzdFNvdXJjZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndhbGxldHNMaXN0U291cmNlLFxuICAgICAgICAgICAgY2FjaGVUVExNczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLndhbGxldHNMaXN0Q2FjaGVUVExNc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCF0aGlzLmRhcHBTZXR0aW5ncy5tYW5pZmVzdFVybCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IERhcHBNZXRhZGF0YUVycm9yKCdEYXBwIHRvbmNvbm5lY3QtbWFuaWZlc3QuanNvbiBtdXN0IGJlIHNwZWNpZmllZCBpZiB3aW5kb3cubG9jYXRpb24ub3JpZ2luIGlzIHVuZGVmaW5lZC4gU2VlIG1vcmUgaHR0cHM6Ly9naXRodWIuY29tL3Rvbi1jb25uZWN0L2RvY3MvYmxvYi9tYWluL3JlcXVlc3RzLXJlc3BvbnNlcy5tZCNhcHAtbWFuaWZlc3QnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlID0gbmV3IEJyaWRnZUNvbm5lY3Rpb25TdG9yYWdlKHRoaXMuZGFwcFNldHRpbmdzLnN0b3JhZ2UpO1xuICAgICAgICBpZiAoIShvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzYWJsZUF1dG9QYXVzZUNvbm5lY3Rpb24pKSB7XG4gICAgICAgICAgICB0aGlzLmFkZFdpbmRvd0ZvY3VzQW5kQmx1clN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGF2YWlsYWJsZSB3YWxsZXRzIGxpc3QuXG4gICAgICovXG4gICAgc3RhdGljIGdldFdhbGxldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLndhbGxldHNMaXN0LmdldFdhbGxldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgaWYgdGhlIHdhbGxldCBpcyBjb25uZWN0ZWQgcmlnaHQgbm93LlxuICAgICAqL1xuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWxsZXQgIT09IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY29ubmVjdGVkIGFjY291bnQgb3IgbnVsbCBpZiBubyBhY2NvdW50IGlzIGNvbm5lY3RlZC5cbiAgICAgKi9cbiAgICBnZXQgYWNjb3VudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMuX3dhbGxldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjY291bnQpIHx8IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgY29ubmVjdGVkIHdhbGxldCBvciBudWxsIGlmIG5vIGFjY291bnQgaXMgY29ubmVjdGVkLlxuICAgICAqL1xuICAgIGdldCB3YWxsZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWxsZXQ7XG4gICAgfVxuICAgIHNldCB3YWxsZXQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fd2FsbGV0ID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlU3Vic2NyaXB0aW9ucy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKHRoaXMuX3dhbGxldCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGF2YWlsYWJsZSB3YWxsZXRzIGxpc3QuXG4gICAgICovXG4gICAgZ2V0V2FsbGV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FsbGV0c0xpc3QuZ2V0V2FsbGV0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGxvd3MgdG8gc3Vic2NyaWJlIHRvIGNvbm5lY3Rpb24gc3RhdHVzIGNoYW5nZXMgYW5kIGhhbmRsZSBjb25uZWN0aW9uIGVycm9ycy5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgY29ubmVjdGlvbnMgc3RhdHVzIGNoYW5nZXMgd2l0aCBhY3R1YWwgd2FsbGV0IG9yIG51bGwuXG4gICAgICogQHBhcmFtIGVycm9yc0hhbmRsZXIgKG9wdGlvbmFsKSB3aWxsIGJlIGNhbGxlZCB3aXRoIHNvbWUgaW5zdGFuY2Ugb2YgVG9uQ29ubmVjdEVycm9yIHdoZW4gY29ubmVjdCBlcnJvciBpcyByZWNlaXZlZC5cbiAgICAgKiBAcmV0dXJucyB1bnN1YnNjcmliZSBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBvblN0YXR1c0NoYW5nZShjYWxsYmFjaywgZXJyb3JzSGFuZGxlcikge1xuICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZVN1YnNjcmlwdGlvbnMucHVzaChjYWxsYmFjayk7XG4gICAgICAgIGlmIChlcnJvcnNIYW5kbGVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZUVycm9yU3Vic2NyaXB0aW9ucy5wdXNoKGVycm9yc0hhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZVN1YnNjcmlwdGlvbnMgPSB0aGlzLnN0YXR1c0NoYW5nZVN1YnNjcmlwdGlvbnMuZmlsdGVyKGl0ZW0gPT4gaXRlbSAhPT0gY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGVycm9yc0hhbmRsZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1c0NoYW5nZUVycm9yU3Vic2NyaXB0aW9ucyA9IHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zLmZpbHRlcihpdGVtID0+IGl0ZW0gIT09IGVycm9yc0hhbmRsZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25uZWN0KHdhbGxldCwgcmVxdWVzdCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldEFscmVhZHlDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbG9zZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHRoaXMuY3JlYXRlUHJvdmlkZXIod2FsbGV0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuY29ubmVjdCh0aGlzLmNyZWF0ZUNvbm5lY3RSZXF1ZXN0KHJlcXVlc3QpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ5IHRvIHJlc3RvcmUgZXhpc3Rpbmcgc2Vzc2lvbiBhbmQgcmVjb25uZWN0IHRvIHRoZSBjb3JyZXNwb25kaW5nIHdhbGxldC4gQ2FsbCBpdCBpbW1lZGlhdGVseSB3aGVuIHlvdXIgYXBwIGlzIGxvYWRlZC5cbiAgICAgKi9cbiAgICByZXN0b3JlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IFticmlkZ2VDb25uZWN0aW9uVHlwZSwgZW1iZWRkZWRXYWxsZXRdID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuYnJpZGdlQ29ubmVjdGlvblN0b3JhZ2Uuc3RvcmVkQ29ubmVjdGlvblR5cGUoKSxcbiAgICAgICAgICAgICAgICB0aGlzLndhbGxldHNMaXN0LmdldEVtYmVkZGVkV2FsbGV0KClcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGJyaWRnZUNvbm5lY3Rpb25UeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2h0dHAnOlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IHlpZWxkIEJyaWRnZVByb3ZpZGVyLmZyb21TdG9yYWdlKHRoaXMuZGFwcFNldHRpbmdzLnN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2luamVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIgPSB5aWVsZCBJbmplY3RlZFByb3ZpZGVyLmZyb21TdG9yYWdlKHRoaXMuZGFwcFNldHRpbmdzLnN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZW1iZWRkZWRXYWxsZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3ZpZGVyID0geWllbGQgdGhpcy5jcmVhdGVQcm92aWRlcihlbWJlZGRlZFdhbGxldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5icmlkZ2VDb25uZWN0aW9uU3RvcmFnZS5yZW1vdmVDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm92aWRlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm92aWRlci5saXN0ZW4odGhpcy53YWxsZXRFdmVudHNMaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnJlc3RvcmVDb25uZWN0aW9uKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc2tzIGNvbm5lY3RlZCB3YWxsZXQgdG8gc2lnbiBhbmQgc2VuZCB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHRyYW5zYWN0aW9uIHRyYW5zYWN0aW9uIHRvIHNlbmQuXG4gICAgICogQHJldHVybnMgc2lnbmVkIHRyYW5zYWN0aW9uIGJvYyB0aGF0IGFsbG93cyB5b3UgdG8gZmluZCB0aGUgdHJhbnNhY3Rpb24gaW4gdGhlIGJsb2NrY2hhaW4uXG4gICAgICogSWYgdXNlciByZWplY3RzIHRyYW5zYWN0aW9uLCBtZXRob2Qgd2lsbCB0aHJvdyB0aGUgY29ycmVzcG9uZGluZyBlcnJvci5cbiAgICAgKi9cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aW9uKCk7XG4gICAgICAgICAgICBjaGVja1NlbmRUcmFuc2FjdGlvblN1cHBvcnQodGhpcy53YWxsZXQuZGV2aWNlLmZlYXR1cmVzLCB7XG4gICAgICAgICAgICAgICAgcmVxdWlyZWRNZXNzYWdlc051bWJlcjogdHJhbnNhY3Rpb24ubWVzc2FnZXMubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsaWRVbnRpbCB9ID0gdHJhbnNhY3Rpb24sIHR4ID0gX19yZXN0KHRyYW5zYWN0aW9uLCBbXCJ2YWxpZFVudGlsXCJdKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb20gPSB0cmFuc2FjdGlvbi5mcm9tIHx8IHRoaXMuYWNjb3VudC5hZGRyZXNzO1xuICAgICAgICAgICAgY29uc3QgbmV0d29yayA9IHRyYW5zYWN0aW9uLm5ldHdvcmsgfHwgdGhpcy5hY2NvdW50LmNoYWluO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmRSZXF1ZXN0KHNlbmRUcmFuc2FjdGlvblBhcnNlci5jb252ZXJ0VG9ScGNSZXF1ZXN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdHgpLCB7IHZhbGlkX3VudGlsOiB2YWxpZFVudGlsLCBmcm9tLFxuICAgICAgICAgICAgICAgIG5ldHdvcmsgfSkpKTtcbiAgICAgICAgICAgIGlmIChzZW5kVHJhbnNhY3Rpb25QYXJzZXIuaXNFcnJvcihyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VuZFRyYW5zYWN0aW9uUGFyc2VyLnBhcnNlQW5kVGhyb3dFcnJvcihyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2VuZFRyYW5zYWN0aW9uUGFyc2VyLmNvbnZlcnRGcm9tUnBjUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmb3JtIHRodyBjb25uZWN0ZWQgd2FsbGV0IGFuZCBkcm9wIGN1cnJlbnQgc2Vzc2lvbi5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdGhpcy5wcm92aWRlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLm9uV2FsbGV0RGlzY29ubmVjdGVkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXVzZSBicmlkZ2UgSFRUUCBjb25uZWN0aW9uLiBNaWdodCBiZSBoZWxwZnVsLCBpZiB5b3Ugd2FudCB0byBwYXVzZSBjb25uZWN0aW9ucyB3aGlsZSBicm93c2VyIHRhYiBpcyB1bmZvY3VzZWQsXG4gICAgICogb3IgaWYgeW91IHVzZSBTREsgd2l0aCBOb2RlSlMgYW5kIHdhbnQgdG8gc2F2ZSBzZXJ2ZXIgcmVzb3VyY2VzLlxuICAgICAqL1xuICAgIHBhdXNlQ29ubmVjdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMucHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50eXBlKSAhPT0gJ2h0dHAnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wcm92aWRlci5wYXVzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVbnBhdXNlIGJyaWRnZSBIVFRQIGNvbm5lY3Rpb24gaWYgaXQgaXMgcGF1c2VkLlxuICAgICAqL1xuICAgIHVuUGF1c2VDb25uZWN0aW9uKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5wcm92aWRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpICE9PSAnaHR0cCcpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci51blBhdXNlKCk7XG4gICAgfVxuICAgIGFkZFdpbmRvd0ZvY3VzQW5kQmx1clN1YnNjcmlwdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQoKTtcbiAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXVzZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5QYXVzZUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignQ2Fubm90IHN1YnNjcmliZSB0byB0aGUgZG9jdW1lbnQudmlzaWJpbGl0eWNoYW5nZTogJywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUHJvdmlkZXIod2FsbGV0KSB7XG4gICAgICAgIGxldCBwcm92aWRlcjtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHdhbGxldCkgJiYgaXNXYWxsZXRDb25uZWN0aW9uU291cmNlSlMod2FsbGV0KSkge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBuZXcgSW5qZWN0ZWRQcm92aWRlcih0aGlzLmRhcHBTZXR0aW5ncy5zdG9yYWdlLCB3YWxsZXQuanNCcmlkZ2VLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvdmlkZXIgPSBuZXcgQnJpZGdlUHJvdmlkZXIodGhpcy5kYXBwU2V0dGluZ3Muc3RvcmFnZSwgd2FsbGV0KTtcbiAgICAgICAgfVxuICAgICAgICBwcm92aWRlci5saXN0ZW4odGhpcy53YWxsZXRFdmVudHNMaXN0ZW5lci5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgIH1cbiAgICB3YWxsZXRFdmVudHNMaXN0ZW5lcihlKSB7XG4gICAgICAgIHN3aXRjaCAoZS5ldmVudCkge1xuICAgICAgICAgICAgY2FzZSAnY29ubmVjdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbldhbGxldENvbm5lY3RlZChlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY29ubmVjdF9lcnJvcic6XG4gICAgICAgICAgICAgICAgdGhpcy5vbldhbGxldENvbm5lY3RFcnJvcihlLnBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vbldhbGxldERpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uV2FsbGV0Q29ubmVjdGVkKGNvbm5lY3RFdmVudCkge1xuICAgICAgICBjb25zdCB0b25BY2NvdW50SXRlbSA9IGNvbm5lY3RFdmVudC5pdGVtcy5maW5kKGl0ZW0gPT4gaXRlbS5uYW1lID09PSAndG9uX2FkZHInKTtcbiAgICAgICAgY29uc3QgdG9uUHJvb2ZJdGVtID0gY29ubmVjdEV2ZW50Lml0ZW1zLmZpbmQoaXRlbSA9PiBpdGVtLm5hbWUgPT09ICd0b25fcHJvb2YnKTtcbiAgICAgICAgaWYgKCF0b25BY2NvdW50SXRlbSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRvbkNvbm5lY3RFcnJvcigndG9uX2FkZHIgY29ubmVjdGlvbiBpdGVtIHdhcyBub3QgZm91bmQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3YWxsZXQgPSB7XG4gICAgICAgICAgICBkZXZpY2U6IGNvbm5lY3RFdmVudC5kZXZpY2UsXG4gICAgICAgICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlci50eXBlLFxuICAgICAgICAgICAgYWNjb3VudDoge1xuICAgICAgICAgICAgICAgIGFkZHJlc3M6IHRvbkFjY291bnRJdGVtLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgY2hhaW46IHRvbkFjY291bnRJdGVtLm5ldHdvcmssXG4gICAgICAgICAgICAgICAgd2FsbGV0U3RhdGVJbml0OiB0b25BY2NvdW50SXRlbS53YWxsZXRTdGF0ZUluaXQsXG4gICAgICAgICAgICAgICAgcHVibGljS2V5OiB0b25BY2NvdW50SXRlbS5wdWJsaWNLZXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRvblByb29mSXRlbSkge1xuICAgICAgICAgICAgd2FsbGV0LmNvbm5lY3RJdGVtcyA9IHtcbiAgICAgICAgICAgICAgICB0b25Qcm9vZjogdG9uUHJvb2ZJdGVtXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMud2FsbGV0ID0gd2FsbGV0O1xuICAgIH1cbiAgICBvbldhbGxldENvbm5lY3RFcnJvcihjb25uZWN0RXZlbnRFcnJvcikge1xuICAgICAgICBjb25zdCBlcnJvciA9IGNvbm5lY3RFcnJvcnNQYXJzZXIucGFyc2VFcnJvcihjb25uZWN0RXZlbnRFcnJvcik7XG4gICAgICAgIHRoaXMuc3RhdHVzQ2hhbmdlRXJyb3JTdWJzY3JpcHRpb25zLmZvckVhY2goZXJyb3JzSGFuZGxlciA9PiBlcnJvcnNIYW5kbGVyKGVycm9yKSk7XG4gICAgICAgIGNvbnNvbGUuZGVidWcoZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNYW5pZmVzdE5vdEZvdW5kRXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBNYW5pZmVzdENvbnRlbnRFcnJvckVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9uV2FsbGV0RGlzY29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLndhbGxldCA9IG51bGw7XG4gICAgfVxuICAgIGNoZWNrQ29ubmVjdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlQ29ubmVjdFJlcXVlc3QocmVxdWVzdCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiAndG9uX2FkZHInXG4gICAgICAgICAgICB9XG4gICAgICAgIF07XG4gICAgICAgIGlmIChyZXF1ZXN0ID09PSBudWxsIHx8IHJlcXVlc3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlcXVlc3QudG9uUHJvb2YpIHtcbiAgICAgICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIG5hbWU6ICd0b25fcHJvb2YnLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IHJlcXVlc3QudG9uUHJvb2ZcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYW5pZmVzdFVybDogdGhpcy5kYXBwU2V0dGluZ3MubWFuaWZlc3RVcmwsXG4gICAgICAgICAgICBpdGVtc1xuICAgICAgICB9O1xuICAgIH1cbn1cblRvbkNvbm5lY3Qud2FsbGV0c0xpc3QgPSBuZXcgV2FsbGV0c0xpc3RNYW5hZ2VyKCk7XG4vKipcbiAqIENoZWNrIGlmIHNwZWNpZmllZCB3YWxsZXQgaXMgaW5qZWN0ZWQgYW5kIGF2YWlsYWJsZSB0byB1c2Ugd2l0aCB0aGUgYXBwLlxuICogQHBhcmFtIHdhbGxldEpTS2V5IHRhcmdldCB3YWxsZXQncyBqcyBicmlkZ2Uga2V5LlxuICovXG5Ub25Db25uZWN0LmlzV2FsbGV0SW5qZWN0ZWQgPSAod2FsbGV0SlNLZXkpID0+IEluamVjdGVkUHJvdmlkZXIuaXNXYWxsZXRJbmplY3RlZCh3YWxsZXRKU0tleSk7XG4vKipcbiAqIENoZWNrIGlmIHRoZSBhcHAgaXMgb3BlbmVkIGluc2lkZSBzcGVjaWZpZWQgd2FsbGV0J3MgYnJvd3Nlci5cbiAqIEBwYXJhbSB3YWxsZXRKU0tleSB0YXJnZXQgd2FsbGV0J3MganMgYnJpZGdlIGtleS5cbiAqL1xuVG9uQ29ubmVjdC5pc0luc2lkZVdhbGxldEJyb3dzZXIgPSAod2FsbGV0SlNLZXkpID0+IEluamVjdGVkUHJvdmlkZXIuaXNJbnNpZGVXYWxsZXRCcm93c2VyKHdhbGxldEpTS2V5KTtcblxuY29uc3QgYm91bmNlYWJsZVRhZyA9IDB4MTE7XG5jb25zdCB0ZXN0T25seVRhZyA9IDB4ODA7XG4vKipcbiAqIENvbnZlcnRzIHJhdyBUT04gYWRkcmVzcyB0byBib3VuY2VhYmxlIHVzZXItZnJpZW5kbHkgZm9ybWF0LiBbU2VlIGRldGFpbHNde0BsaW5rIGh0dHBzOi8vdG9uLm9yZy9kb2NzL2xlYXJuL292ZXJ2aWV3cy9hZGRyZXNzZXMjdXNlci1mcmllbmRseS1hZGRyZXNzfVxuICogQHBhcmFtIGhleEFkZHJlc3MgcmF3IFRPTiBhZGRyZXNzIGZvcm1hdHRlZCBhcyBcIjA6PGhleCBzdHJpbmcgd2l0aG91dCAweD5cIi5cbiAqIEBwYXJhbSBbdGVzdE9ubHk9ZmFsc2VdIGNvbnZlcnQgYWRkcmVzcyB0byB0ZXN0LW9ubHkgZm9ybS4gW1NlZSBkZXRhaWxzXXtAbGluayBodHRwczovL3Rvbi5vcmcvZG9jcy9sZWFybi9vdmVydmlld3MvYWRkcmVzc2VzI3VzZXItZnJpZW5kbHktYWRkcmVzc31cbiAqL1xuZnVuY3Rpb24gdG9Vc2VyRnJpZW5kbHlBZGRyZXNzKGhleEFkZHJlc3MsIHRlc3RPbmx5ID0gZmFsc2UpIHtcbiAgICBjb25zdCB7IHdjLCBoZXggfSA9IHBhcnNlSGV4QWRkcmVzcyhoZXhBZGRyZXNzKTtcbiAgICBsZXQgdGFnID0gYm91bmNlYWJsZVRhZztcbiAgICBpZiAodGVzdE9ubHkpIHtcbiAgICAgICAgdGFnIHw9IHRlc3RPbmx5VGFnO1xuICAgIH1cbiAgICBjb25zdCBhZGRyID0gbmV3IEludDhBcnJheSgzNCk7XG4gICAgYWRkclswXSA9IHRhZztcbiAgICBhZGRyWzFdID0gd2M7XG4gICAgYWRkci5zZXQoaGV4LCAyKTtcbiAgICBjb25zdCBhZGRyZXNzV2l0aENoZWNrc3VtID0gbmV3IFVpbnQ4QXJyYXkoMzYpO1xuICAgIGFkZHJlc3NXaXRoQ2hlY2tzdW0uc2V0KGFkZHIpO1xuICAgIGFkZHJlc3NXaXRoQ2hlY2tzdW0uc2V0KGNyYzE2KGFkZHIpLCAzNCk7XG4gICAgbGV0IGFkZHJlc3NCYXNlNjQgPSBCYXNlNjQuZW5jb2RlKGFkZHJlc3NXaXRoQ2hlY2tzdW0pO1xuICAgIHJldHVybiBhZGRyZXNzQmFzZTY0LnJlcGxhY2UoL1xcKy9nLCAnLScpLnJlcGxhY2UoL1xcLy9nLCAnXycpO1xufVxuZnVuY3Rpb24gcGFyc2VIZXhBZGRyZXNzKGhleEFkZHJlc3MpIHtcbiAgICBpZiAoIWhleEFkZHJlc3MuaW5jbHVkZXMoJzonKSkge1xuICAgICAgICB0aHJvdyBuZXcgV3JvbmdBZGRyZXNzRXJyb3IoYFdyb25nIGFkZHJlc3MgJHtoZXhBZGRyZXNzfS4gQWRkcmVzcyBtdXN0IGluY2x1ZGUgXCI6XCIuYCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRzID0gaGV4QWRkcmVzcy5zcGxpdCgnOicpO1xuICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdyb25nQWRkcmVzc0Vycm9yKGBXcm9uZyBhZGRyZXNzICR7aGV4QWRkcmVzc30uIEFkZHJlc3MgbXVzdCBpbmNsdWRlIFwiOlwiIG9ubHkgb25jZS5gKTtcbiAgICB9XG4gICAgY29uc3Qgd2MgPSBwYXJzZUludChwYXJ0c1swXSk7XG4gICAgaWYgKHdjICE9PSAwICYmIHdjICE9PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgV3JvbmdBZGRyZXNzRXJyb3IoYFdyb25nIGFkZHJlc3MgJHtoZXhBZGRyZXNzfS4gV0MgbXVzdCBiZSBlcSAwIG9yIC0xLCBidXQgJHt3Y30gcmVjZWl2ZWQuYCk7XG4gICAgfVxuICAgIGNvbnN0IGhleCA9IHBhcnRzWzFdO1xuICAgIGlmICgoaGV4ID09PSBudWxsIHx8IGhleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogaGV4Lmxlbmd0aCkgIT09IDY0KSB7XG4gICAgICAgIHRocm93IG5ldyBXcm9uZ0FkZHJlc3NFcnJvcihgV3JvbmcgYWRkcmVzcyAke2hleEFkZHJlc3N9LiBIZXggcGFydCBtdXN0IGJlIDY0Ynl0ZXMgbGVuZ3RoLCBidXQgJHtoZXggPT09IG51bGwgfHwgaGV4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBoZXgubGVuZ3RofSByZWNlaXZlZC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2MsXG4gICAgICAgIGhleDogaGV4VG9CeXRlcyhoZXgpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyYzE2KGRhdGEpIHtcbiAgICBjb25zdCBwb2x5ID0gMHgxMDIxO1xuICAgIGxldCByZWcgPSAwO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBuZXcgVWludDhBcnJheShkYXRhLmxlbmd0aCArIDIpO1xuICAgIG1lc3NhZ2Uuc2V0KGRhdGEpO1xuICAgIGZvciAobGV0IGJ5dGUgb2YgbWVzc2FnZSkge1xuICAgICAgICBsZXQgbWFzayA9IDB4ODA7XG4gICAgICAgIHdoaWxlIChtYXNrID4gMCkge1xuICAgICAgICAgICAgcmVnIDw8PSAxO1xuICAgICAgICAgICAgaWYgKGJ5dGUgJiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgcmVnICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXNrID4+PSAxO1xuICAgICAgICAgICAgaWYgKHJlZyA+IDB4ZmZmZikge1xuICAgICAgICAgICAgICAgIHJlZyAmPSAweGZmZmY7XG4gICAgICAgICAgICAgICAgcmVnIF49IHBvbHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KFtNYXRoLmZsb29yKHJlZyAvIDI1NiksIHJlZyAlIDI1Nl0pO1xufVxuY29uc3QgdG9CeXRlTWFwID0ge307XG5mb3IgKGxldCBvcmQgPSAwOyBvcmQgPD0gMHhmZjsgb3JkKyspIHtcbiAgICBsZXQgcyA9IG9yZC50b1N0cmluZygxNik7XG4gICAgaWYgKHMubGVuZ3RoIDwgMikge1xuICAgICAgICBzID0gJzAnICsgcztcbiAgICB9XG4gICAgdG9CeXRlTWFwW3NdID0gb3JkO1xufVxuZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBoZXggPSBoZXgudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBsZW5ndGgyID0gaGV4Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoMiAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFBhcnNlSGV4RXJyb3IoJ0hleCBzdHJpbmcgbXVzdCBoYXZlIGxlbmd0aCBhIG11bHRpcGxlIG9mIDI6ICcgKyBoZXgpO1xuICAgIH1cbiAgICBjb25zdCBsZW5ndGggPSBsZW5ndGgyIC8gMjtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZG91YmxlZCA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhTdWJzdHJpbmcgPSBoZXguc3Vic3RyaW5nKGRvdWJsZWQsIGRvdWJsZWQgKyAyKTtcbiAgICAgICAgaWYgKCF0b0J5dGVNYXAuaGFzT3duUHJvcGVydHkoaGV4U3Vic3RyaW5nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcnNlSGV4RXJyb3IoJ0ludmFsaWQgaGV4IGNoYXJhY3RlcjogJyArIGhleFN1YnN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2ldID0gdG9CeXRlTWFwW2hleFN1YnN0cmluZ107XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IEJhZFJlcXVlc3RFcnJvciwgRmV0Y2hXYWxsZXRzRXJyb3IsIExvY2Fsc3RvcmFnZU5vdEZvdW5kRXJyb3IsIFBhcnNlSGV4RXJyb3IsIFRvbkNvbm5lY3QsIFRvbkNvbm5lY3RFcnJvciwgVW5rbm93bkFwcEVycm9yLCBVbmtub3duRXJyb3IsIFVzZXJSZWplY3RzRXJyb3IsIFdhbGxldEFscmVhZHlDb25uZWN0ZWRFcnJvciwgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IsIFdhbGxldE5vdEluamVjdGVkRXJyb3IsIFdhbGxldHNMaXN0TWFuYWdlciwgV3JvbmdBZGRyZXNzRXJyb3IsIFRvbkNvbm5lY3QgYXMgZGVmYXVsdCwgaXNUZWxlZ3JhbVVybCwgaXNXYWxsZXRJbmZvQ3VycmVudGx5RW1iZWRkZWQsIGlzV2FsbGV0SW5mb0N1cnJlbnRseUluamVjdGVkLCBpc1dhbGxldEluZm9JbmplY3RhYmxlLCBpc1dhbGxldEluZm9JbmplY3RlZCwgaXNXYWxsZXRJbmZvUmVtb3RlLCB0b1VzZXJGcmllbmRseUFkZHJlc3MgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@tonconnect/ui/node_modules/@tonconnect/sdk/lib/esm/index.mjs\n");

/***/ })

};
;